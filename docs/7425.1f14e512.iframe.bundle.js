"use strict";(self.webpackChunk_juki_team_base_ui=self.webpackChunk_juki_team_base_ui||[]).push([[7425],{"./node_modules/react-dnd/dist/index.js":function(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__){__webpack_require__.r(__webpack_exports__),__webpack_require__.d(__webpack_exports__,{DndContext:function(){return DndContext.L},DndProvider:function(){return DndProvider},DragPreviewImage:function(){return DragPreviewImage},useDrag:function(){return useDrag.c},useDragDropManager:function(){return useDragDropManager.N},useDragLayer:function(){return useDragLayer},useDrop:function(){return useDrop.L}});var DndContext=__webpack_require__("./node_modules/react-dnd/dist/core/DndContext.js"),jsx_runtime=__webpack_require__("./node_modules/react/jsx-runtime.js");function formatProdErrorMessage(code){return"Minified Redux error #"+code+"; visit https://redux.js.org/Errors?code="+code+" for the full message or use the non-minified dev environment for full errors. "}var $$observable="function"==typeof Symbol&&Symbol.observable||"@@observable",randomString=function randomString(){return Math.random().toString(36).substring(7).split("").join(".")},ActionTypes={INIT:"@@redux/INIT"+randomString(),REPLACE:"@@redux/REPLACE"+randomString(),PROBE_UNKNOWN_ACTION:function PROBE_UNKNOWN_ACTION(){return"@@redux/PROBE_UNKNOWN_ACTION"+randomString()}};function isPlainObject(obj){if("object"!=typeof obj||null===obj)return!1;for(var proto=obj;null!==Object.getPrototypeOf(proto);)proto=Object.getPrototypeOf(proto);return Object.getPrototypeOf(obj)===proto}function createStore(reducer,preloadedState,enhancer){var _ref2;if("function"==typeof preloadedState&&"function"==typeof enhancer||"function"==typeof enhancer&&"function"==typeof arguments[3])throw new Error(formatProdErrorMessage(0));if("function"==typeof preloadedState&&void 0===enhancer&&(enhancer=preloadedState,preloadedState=void 0),void 0!==enhancer){if("function"!=typeof enhancer)throw new Error(formatProdErrorMessage(1));return enhancer(createStore)(reducer,preloadedState)}if("function"!=typeof reducer)throw new Error(formatProdErrorMessage(2));var currentReducer=reducer,currentState=preloadedState,currentListeners=[],nextListeners=currentListeners,isDispatching=!1;function ensureCanMutateNextListeners(){nextListeners===currentListeners&&(nextListeners=currentListeners.slice())}function getState(){if(isDispatching)throw new Error(formatProdErrorMessage(3));return currentState}function subscribe(listener){if("function"!=typeof listener)throw new Error(formatProdErrorMessage(4));if(isDispatching)throw new Error(formatProdErrorMessage(5));var isSubscribed=!0;return ensureCanMutateNextListeners(),nextListeners.push(listener),function unsubscribe(){if(isSubscribed){if(isDispatching)throw new Error(formatProdErrorMessage(6));isSubscribed=!1,ensureCanMutateNextListeners();var index=nextListeners.indexOf(listener);nextListeners.splice(index,1),currentListeners=null}}}function dispatch(action){if(!isPlainObject(action))throw new Error(formatProdErrorMessage(7));if(void 0===action.type)throw new Error(formatProdErrorMessage(8));if(isDispatching)throw new Error(formatProdErrorMessage(9));try{isDispatching=!0,currentState=currentReducer(currentState,action)}finally{isDispatching=!1}for(var listeners=currentListeners=nextListeners,i=0;i<listeners.length;i++){(0,listeners[i])()}return action}function replaceReducer(nextReducer){if("function"!=typeof nextReducer)throw new Error(formatProdErrorMessage(10));currentReducer=nextReducer,dispatch({type:ActionTypes.REPLACE})}function observable(){var _ref,outerSubscribe=subscribe;return(_ref={subscribe:function subscribe(observer){if("object"!=typeof observer||null===observer)throw new Error(formatProdErrorMessage(11));function observeState(){observer.next&&observer.next(getState())}return observeState(),{unsubscribe:outerSubscribe(observeState)}}})[$$observable]=function(){return this},_ref}return dispatch({type:ActionTypes.INIT}),(_ref2={dispatch:dispatch,subscribe:subscribe,getState:getState,replaceReducer:replaceReducer})[$$observable]=observable,_ref2}var dist=__webpack_require__("./node_modules/@react-dnd/invariant/dist/index.js");function isObject(input){return"object"==typeof input}const BEGIN_DRAG="dnd-core/BEGIN_DRAG",HOVER="dnd-core/HOVER",DROP="dnd-core/DROP",END_DRAG="dnd-core/END_DRAG";function setClientOffset(clientOffset,sourceClientOffset){return{type:"dnd-core/INIT_COORDS",payload:{sourceClientOffset:sourceClientOffset||null,clientOffset:clientOffset||null}}}const ResetCoordinatesAction={type:"dnd-core/INIT_COORDS",payload:{clientOffset:null,sourceClientOffset:null}};function createBeginDrag(manager){return function beginDrag(sourceIds=[],options={publishSource:!0}){const{publishSource:publishSource=!0,clientOffset:clientOffset,getSourceClientOffset:getSourceClientOffset}=options,monitor=manager.getMonitor(),registry=manager.getRegistry();manager.dispatch(setClientOffset(clientOffset)),function verifyInvariants(sourceIds,monitor,registry){(0,dist.k)(!monitor.isDragging(),"Cannot call beginDrag while dragging."),sourceIds.forEach((function(sourceId){(0,dist.k)(registry.getSource(sourceId),"Expected sourceIds to be registered.")}))}(sourceIds,monitor,registry);const sourceId=function getDraggableSource(sourceIds,monitor){let sourceId=null;for(let i=sourceIds.length-1;i>=0;i--)if(monitor.canDragSource(sourceIds[i])){sourceId=sourceIds[i];break}return sourceId}(sourceIds,monitor);if(null==sourceId)return void manager.dispatch(ResetCoordinatesAction);let sourceClientOffset=null;if(clientOffset){if(!getSourceClientOffset)throw new Error("getSourceClientOffset must be defined");!function verifyGetSourceClientOffsetIsFunction(getSourceClientOffset){(0,dist.k)("function"==typeof getSourceClientOffset,"When clientOffset is provided, getSourceClientOffset must be a function.")}(getSourceClientOffset),sourceClientOffset=getSourceClientOffset(sourceId)}manager.dispatch(setClientOffset(clientOffset,sourceClientOffset));const item=registry.getSource(sourceId).beginDrag(monitor,sourceId);if(null==item)return;!function verifyItemIsObject(item){(0,dist.k)(isObject(item),"Item must be an object.")}(item),registry.pinSource(sourceId);const itemType=registry.getSourceType(sourceId);return{type:BEGIN_DRAG,payload:{itemType:itemType,item:item,sourceId:sourceId,clientOffset:clientOffset||null,sourceClientOffset:sourceClientOffset||null,isSourcePublic:!!publishSource}}}}function _defineProperty(obj,key,value){return key in obj?Object.defineProperty(obj,key,{value:value,enumerable:!0,configurable:!0,writable:!0}):obj[key]=value,obj}function drop_objectSpread(target){for(var i=1;i<arguments.length;i++){var source=null!=arguments[i]?arguments[i]:{},ownKeys=Object.keys(source);"function"==typeof Object.getOwnPropertySymbols&&(ownKeys=ownKeys.concat(Object.getOwnPropertySymbols(source).filter((function(sym){return Object.getOwnPropertyDescriptor(source,sym).enumerable})))),ownKeys.forEach((function(key){_defineProperty(target,key,source[key])}))}return target}function createDrop(manager){return function drop(options={}){const monitor=manager.getMonitor(),registry=manager.getRegistry();!function drop_verifyInvariants(monitor){(0,dist.k)(monitor.isDragging(),"Cannot call drop while not dragging."),(0,dist.k)(!monitor.didDrop(),"Cannot call drop twice during one drag operation.")}(monitor);const targetIds=function getDroppableTargets(monitor){const targetIds=monitor.getTargetIds().filter(monitor.canDropOnTarget,monitor);return targetIds.reverse(),targetIds}(monitor);targetIds.forEach(((targetId,index)=>{const dropResult=function determineDropResult(targetId,index,registry,monitor){const target=registry.getTarget(targetId);let dropResult=target?target.drop(monitor,targetId):void 0;(function verifyDropResultType(dropResult){(0,dist.k)(void 0===dropResult||isObject(dropResult),"Drop result must either be an object or undefined.")})(dropResult),void 0===dropResult&&(dropResult=0===index?{}:monitor.getDropResult());return dropResult}(targetId,index,registry,monitor),action={type:DROP,payload:{dropResult:drop_objectSpread({},options,dropResult)}};manager.dispatch(action)}))}}function createEndDrag(manager){return function endDrag(){const monitor=manager.getMonitor(),registry=manager.getRegistry();!function verifyIsDragging(monitor){(0,dist.k)(monitor.isDragging(),"Cannot call endDrag while not dragging.")}(monitor);const sourceId=monitor.getSourceId();if(null!=sourceId){registry.getSource(sourceId,!0).endDrag(monitor,sourceId),registry.unpinSource()}return{type:END_DRAG}}}function matchesType(targetType,draggedItemType){return null===draggedItemType?null===targetType:Array.isArray(targetType)?targetType.some((t=>t===draggedItemType)):targetType===draggedItemType}function createHover(manager){return function hover(targetIdsArg,{clientOffset:clientOffset}={}){!function verifyTargetIdsIsArray(targetIdsArg){(0,dist.k)(Array.isArray(targetIdsArg),"Expected targetIds to be an array.")}(targetIdsArg);const targetIds=targetIdsArg.slice(0),monitor=manager.getMonitor(),registry=manager.getRegistry();return function removeNonMatchingTargetIds(targetIds,registry,draggedItemType){for(let i=targetIds.length-1;i>=0;i--){const targetId=targetIds[i];matchesType(registry.getTargetType(targetId),draggedItemType)||targetIds.splice(i,1)}}(targetIds,registry,monitor.getItemType()),function checkInvariants(targetIds,monitor,registry){(0,dist.k)(monitor.isDragging(),"Cannot call hover while not dragging."),(0,dist.k)(!monitor.didDrop(),"Cannot call hover after drop.");for(let i=0;i<targetIds.length;i++){const targetId=targetIds[i];(0,dist.k)(targetIds.lastIndexOf(targetId)===i,"Expected targetIds to be unique in the passed array.");const target=registry.getTarget(targetId);(0,dist.k)(target,"Expected targetIds to be registered.")}}(targetIds,monitor,registry),function hoverAllTargets(targetIds,monitor,registry){targetIds.forEach((function(targetId){registry.getTarget(targetId).hover(monitor,targetId)}))}(targetIds,monitor,registry),{type:HOVER,payload:{targetIds:targetIds,clientOffset:clientOffset||null}}}}function createPublishDragSource(manager){return function publishDragSource(){if(manager.getMonitor().isDragging())return{type:"dnd-core/PUBLISH_DRAG_SOURCE"}}}class DragDropManagerImpl{receiveBackend(backend){this.backend=backend}getMonitor(){return this.monitor}getBackend(){return this.backend}getRegistry(){return this.monitor.registry}getActions(){const manager=this,{dispatch:dispatch}=this.store;const actions=function createDragDropActions(manager){return{beginDrag:createBeginDrag(manager),publishDragSource:createPublishDragSource(manager),hover:createHover(manager),drop:createDrop(manager),endDrag:createEndDrag(manager)}}(this);return Object.keys(actions).reduce(((boundActions,key)=>{const action=actions[key];return boundActions[key]=function bindActionCreator(actionCreator){return(...args)=>{const action=actionCreator.apply(manager,args);void 0!==action&&dispatch(action)}}(action),boundActions}),{})}dispatch(action){this.store.dispatch(action)}constructor(store,monitor){this.isSetUp=!1,this.handleRefCountChange=()=>{const shouldSetUp=this.store.getState().refCount>0;this.backend&&(shouldSetUp&&!this.isSetUp?(this.backend.setup(),this.isSetUp=!0):!shouldSetUp&&this.isSetUp&&(this.backend.teardown(),this.isSetUp=!1))},this.store=store,this.monitor=monitor,store.subscribe(this.handleRefCountChange)}}function subtract(a,b){return{x:a.x-b.x,y:a.y-b.y}}const NONE=[],ALL=[];NONE.__IS_NONE__=!0,ALL.__IS_ALL__=!0;class DragDropMonitorImpl{subscribeToStateChange(listener,options={}){const{handlerIds:handlerIds}=options;(0,dist.k)("function"==typeof listener,"listener must be a function."),(0,dist.k)(void 0===handlerIds||Array.isArray(handlerIds),"handlerIds, when specified, must be an array of strings.");let prevStateId=this.store.getState().stateId;return this.store.subscribe((()=>{const state=this.store.getState(),currentStateId=state.stateId;try{const canSkipListener=currentStateId===prevStateId||currentStateId===prevStateId+1&&!function areDirty(dirtyIds,handlerIds){return dirtyIds!==NONE&&(dirtyIds===ALL||void 0===handlerIds||function intersection(itemsA,itemsB){return itemsA.filter((t=>itemsB.indexOf(t)>-1))}(handlerIds,dirtyIds).length>0)}(state.dirtyHandlerIds,handlerIds);canSkipListener||listener()}finally{prevStateId=currentStateId}}))}subscribeToOffsetChange(listener){(0,dist.k)("function"==typeof listener,"listener must be a function.");let previousState=this.store.getState().dragOffset;return this.store.subscribe((()=>{const nextState=this.store.getState().dragOffset;nextState!==previousState&&(previousState=nextState,listener())}))}canDragSource(sourceId){if(!sourceId)return!1;const source=this.registry.getSource(sourceId);return(0,dist.k)(source,`Expected to find a valid source. sourceId=${sourceId}`),!this.isDragging()&&source.canDrag(this,sourceId)}canDropOnTarget(targetId){if(!targetId)return!1;const target=this.registry.getTarget(targetId);if((0,dist.k)(target,`Expected to find a valid target. targetId=${targetId}`),!this.isDragging()||this.didDrop())return!1;return matchesType(this.registry.getTargetType(targetId),this.getItemType())&&target.canDrop(this,targetId)}isDragging(){return Boolean(this.getItemType())}isDraggingSource(sourceId){if(!sourceId)return!1;const source=this.registry.getSource(sourceId,!0);if((0,dist.k)(source,`Expected to find a valid source. sourceId=${sourceId}`),!this.isDragging()||!this.isSourcePublic())return!1;return this.registry.getSourceType(sourceId)===this.getItemType()&&source.isDragging(this,sourceId)}isOverTarget(targetId,options={shallow:!1}){if(!targetId)return!1;const{shallow:shallow}=options;if(!this.isDragging())return!1;const targetType=this.registry.getTargetType(targetId),draggedItemType=this.getItemType();if(draggedItemType&&!matchesType(targetType,draggedItemType))return!1;const targetIds=this.getTargetIds();if(!targetIds.length)return!1;const index=targetIds.indexOf(targetId);return shallow?index===targetIds.length-1:index>-1}getItemType(){return this.store.getState().dragOperation.itemType}getItem(){return this.store.getState().dragOperation.item}getSourceId(){return this.store.getState().dragOperation.sourceId}getTargetIds(){return this.store.getState().dragOperation.targetIds}getDropResult(){return this.store.getState().dragOperation.dropResult}didDrop(){return this.store.getState().dragOperation.didDrop}isSourcePublic(){return Boolean(this.store.getState().dragOperation.isSourcePublic)}getInitialClientOffset(){return this.store.getState().dragOffset.initialClientOffset}getInitialSourceClientOffset(){return this.store.getState().dragOffset.initialSourceClientOffset}getClientOffset(){return this.store.getState().dragOffset.clientOffset}getSourceClientOffset(){return function getSourceClientOffset(state){const{clientOffset:clientOffset,initialClientOffset:initialClientOffset,initialSourceClientOffset:initialSourceClientOffset}=state;return clientOffset&&initialClientOffset&&initialSourceClientOffset?subtract(function add(a,b){return{x:a.x+b.x,y:a.y+b.y}}(clientOffset,initialSourceClientOffset),initialClientOffset):null}(this.store.getState().dragOffset)}getDifferenceFromInitialOffset(){return function getDifferenceFromInitialOffset(state){const{clientOffset:clientOffset,initialClientOffset:initialClientOffset}=state;return clientOffset&&initialClientOffset?subtract(clientOffset,initialClientOffset):null}(this.store.getState().dragOffset)}constructor(store,registry){this.store=store,this.registry=registry}}const scope="undefined"!=typeof global?global:self,BrowserMutationObserver=scope.MutationObserver||scope.WebKitMutationObserver;function makeRequestCallFromTimer(callback){return function requestCall(){const timeoutHandle=setTimeout(handleTimer,0),intervalHandle=setInterval(handleTimer,50);function handleTimer(){clearTimeout(timeoutHandle),clearInterval(intervalHandle),callback()}}}const makeRequestCall="function"==typeof BrowserMutationObserver?function makeRequestCallFromMutationObserver(callback){let toggle=1;const observer=new BrowserMutationObserver(callback),node=document.createTextNode("");return observer.observe(node,{characterData:!0}),function requestCall(){toggle=-toggle,node.data=toggle}}:makeRequestCallFromTimer;class RawTask{call(){try{this.task&&this.task()}catch(error){this.onError(error)}finally{this.task=null,this.release(this)}}constructor(onError,release){this.onError=onError,this.release=release,this.task=null}}const asapQueue=new class AsapQueue{enqueueTask(task){const{queue:q,requestFlush:requestFlush}=this;q.length||(requestFlush(),this.flushing=!0),q[q.length]=task}constructor(){this.queue=[],this.pendingErrors=[],this.flushing=!1,this.index=0,this.capacity=1024,this.flush=()=>{const{queue:q}=this;for(;this.index<q.length;){const currentIndex=this.index;if(this.index++,q[currentIndex].call(),this.index>this.capacity){for(let scan=0,newLength=q.length-this.index;scan<newLength;scan++)q[scan]=q[scan+this.index];q.length-=this.index,this.index=0}}q.length=0,this.index=0,this.flushing=!1},this.registerPendingError=err=>{this.pendingErrors.push(err),this.requestErrorThrow()},this.requestFlush=makeRequestCall(this.flush),this.requestErrorThrow=makeRequestCallFromTimer((()=>{if(this.pendingErrors.length)throw this.pendingErrors.shift()}))}},taskFactory=new class TaskFactory{create(task){const tasks=this.freeTasks,t1=tasks.length?tasks.pop():new RawTask(this.onError,(t=>tasks[tasks.length]=t));return t1.task=task,t1}constructor(onError){this.onError=onError,this.freeTasks=[]}}(asapQueue.registerPendingError);const REMOVE_TARGET="dnd-core/REMOVE_TARGET";function validateType(type,allowArray){allowArray&&Array.isArray(type)?type.forEach((t=>validateType(t,!1))):(0,dist.k)("string"==typeof type||"symbol"==typeof type,allowArray?"Type can only be a string, a symbol, or an array of either.":"Type can only be a string or a symbol.")}var HandlerRole;!function(HandlerRole){HandlerRole.SOURCE="SOURCE",HandlerRole.TARGET="TARGET"}(HandlerRole||(HandlerRole={}));let nextUniqueId=0;function getNextHandlerId(role){const id=function getNextUniqueId(){return nextUniqueId++}().toString();switch(role){case HandlerRole.SOURCE:return`S${id}`;case HandlerRole.TARGET:return`T${id}`;default:throw new Error(`Unknown Handler Role: ${role}`)}}function parseRoleFromHandlerId(handlerId){switch(handlerId[0]){case"S":return HandlerRole.SOURCE;case"T":return HandlerRole.TARGET;default:throw new Error(`Cannot parse handler ID: ${handlerId}`)}}function mapContainsValue(map,searchValue){const entries=map.entries();let isDone=!1;do{const{done:done,value:[,value]}=entries.next();if(value===searchValue)return!0;isDone=!!done}while(!isDone);return!1}class HandlerRegistryImpl{addSource(type,source){validateType(type),function validateSourceContract(source){(0,dist.k)("function"==typeof source.canDrag,"Expected canDrag to be a function."),(0,dist.k)("function"==typeof source.beginDrag,"Expected beginDrag to be a function."),(0,dist.k)("function"==typeof source.endDrag,"Expected endDrag to be a function.")}(source);const sourceId=this.addHandler(HandlerRole.SOURCE,type,source);return this.store.dispatch(function addSource(sourceId){return{type:"dnd-core/ADD_SOURCE",payload:{sourceId:sourceId}}}(sourceId)),sourceId}addTarget(type,target){validateType(type,!0),function validateTargetContract(target){(0,dist.k)("function"==typeof target.canDrop,"Expected canDrop to be a function."),(0,dist.k)("function"==typeof target.hover,"Expected hover to be a function."),(0,dist.k)("function"==typeof target.drop,"Expected beginDrag to be a function.")}(target);const targetId=this.addHandler(HandlerRole.TARGET,type,target);return this.store.dispatch(function addTarget(targetId){return{type:"dnd-core/ADD_TARGET",payload:{targetId:targetId}}}(targetId)),targetId}containsHandler(handler){return mapContainsValue(this.dragSources,handler)||mapContainsValue(this.dropTargets,handler)}getSource(sourceId,includePinned=!1){(0,dist.k)(this.isSourceId(sourceId),"Expected a valid source ID.");return includePinned&&sourceId===this.pinnedSourceId?this.pinnedSource:this.dragSources.get(sourceId)}getTarget(targetId){return(0,dist.k)(this.isTargetId(targetId),"Expected a valid target ID."),this.dropTargets.get(targetId)}getSourceType(sourceId){return(0,dist.k)(this.isSourceId(sourceId),"Expected a valid source ID."),this.types.get(sourceId)}getTargetType(targetId){return(0,dist.k)(this.isTargetId(targetId),"Expected a valid target ID."),this.types.get(targetId)}isSourceId(handlerId){return parseRoleFromHandlerId(handlerId)===HandlerRole.SOURCE}isTargetId(handlerId){return parseRoleFromHandlerId(handlerId)===HandlerRole.TARGET}removeSource(sourceId){(0,dist.k)(this.getSource(sourceId),"Expected an existing source."),this.store.dispatch(function removeSource(sourceId){return{type:"dnd-core/REMOVE_SOURCE",payload:{sourceId:sourceId}}}(sourceId)),function asap(task){asapQueue.enqueueTask(taskFactory.create(task))}((()=>{this.dragSources.delete(sourceId),this.types.delete(sourceId)}))}removeTarget(targetId){(0,dist.k)(this.getTarget(targetId),"Expected an existing target."),this.store.dispatch(function removeTarget(targetId){return{type:REMOVE_TARGET,payload:{targetId:targetId}}}(targetId)),this.dropTargets.delete(targetId),this.types.delete(targetId)}pinSource(sourceId){const source=this.getSource(sourceId);(0,dist.k)(source,"Expected an existing source."),this.pinnedSourceId=sourceId,this.pinnedSource=source}unpinSource(){(0,dist.k)(this.pinnedSource,"No source is pinned at the time."),this.pinnedSourceId=null,this.pinnedSource=null}addHandler(role,type,handler){const id=getNextHandlerId(role);return this.types.set(id,type),role===HandlerRole.SOURCE?this.dragSources.set(id,handler):role===HandlerRole.TARGET&&this.dropTargets.set(id,handler),id}constructor(store){this.types=new Map,this.dragSources=new Map,this.dropTargets=new Map,this.pinnedSourceId=null,this.pinnedSource=null,this.store=store}}const strictEquality=(a,b)=>a===b;function reduce(_state=NONE,action){switch(action.type){case HOVER:break;case"dnd-core/ADD_SOURCE":case"dnd-core/ADD_TARGET":case REMOVE_TARGET:case"dnd-core/REMOVE_SOURCE":return NONE;default:return ALL}const{targetIds:targetIds=[],prevTargetIds:prevTargetIds=[]}=action.payload,result=function xor(itemsA,itemsB){const map=new Map,insertItem=item=>{map.set(item,map.has(item)?map.get(item)+1:1)};itemsA.forEach(insertItem),itemsB.forEach(insertItem);const result=[];return map.forEach(((count,key)=>{1===count&&result.push(key)})),result}(targetIds,prevTargetIds);if(!(result.length>0||!function areArraysEqual(a,b,isEqual=strictEquality){if(a.length!==b.length)return!1;for(let i=0;i<a.length;++i)if(!isEqual(a[i],b[i]))return!1;return!0}(targetIds,prevTargetIds)))return NONE;const prevInnermostTargetId=prevTargetIds[prevTargetIds.length-1],innermostTargetId=targetIds[targetIds.length-1];return prevInnermostTargetId!==innermostTargetId&&(prevInnermostTargetId&&result.push(prevInnermostTargetId),innermostTargetId&&result.push(innermostTargetId)),result}function dragOffset_defineProperty(obj,key,value){return key in obj?Object.defineProperty(obj,key,{value:value,enumerable:!0,configurable:!0,writable:!0}):obj[key]=value,obj}const initialState={initialSourceClientOffset:null,initialClientOffset:null,clientOffset:null};function dragOffset_reduce(state=initialState,action){const{payload:payload}=action;switch(action.type){case"dnd-core/INIT_COORDS":case BEGIN_DRAG:return{initialSourceClientOffset:payload.sourceClientOffset,initialClientOffset:payload.clientOffset,clientOffset:payload.clientOffset};case HOVER:return function areCoordsEqual(offsetA,offsetB){return!offsetA&&!offsetB||!(!offsetA||!offsetB)&&offsetA.x===offsetB.x&&offsetA.y===offsetB.y}(state.clientOffset,payload.clientOffset)?state:function dragOffset_objectSpread(target){for(var i=1;i<arguments.length;i++){var source=null!=arguments[i]?arguments[i]:{},ownKeys=Object.keys(source);"function"==typeof Object.getOwnPropertySymbols&&(ownKeys=ownKeys.concat(Object.getOwnPropertySymbols(source).filter((function(sym){return Object.getOwnPropertyDescriptor(source,sym).enumerable})))),ownKeys.forEach((function(key){dragOffset_defineProperty(target,key,source[key])}))}return target}({},state,{clientOffset:payload.clientOffset});case END_DRAG:case DROP:return initialState;default:return state}}function dragOperation_defineProperty(obj,key,value){return key in obj?Object.defineProperty(obj,key,{value:value,enumerable:!0,configurable:!0,writable:!0}):obj[key]=value,obj}function dragOperation_objectSpread(target){for(var i=1;i<arguments.length;i++){var source=null!=arguments[i]?arguments[i]:{},ownKeys=Object.keys(source);"function"==typeof Object.getOwnPropertySymbols&&(ownKeys=ownKeys.concat(Object.getOwnPropertySymbols(source).filter((function(sym){return Object.getOwnPropertyDescriptor(source,sym).enumerable})))),ownKeys.forEach((function(key){dragOperation_defineProperty(target,key,source[key])}))}return target}const dragOperation_initialState={itemType:null,item:null,sourceId:null,targetIds:[],dropResult:null,didDrop:!1,isSourcePublic:null};function dragOperation_reduce(state=dragOperation_initialState,action){const{payload:payload}=action;switch(action.type){case BEGIN_DRAG:return dragOperation_objectSpread({},state,{itemType:payload.itemType,item:payload.item,sourceId:payload.sourceId,isSourcePublic:payload.isSourcePublic,dropResult:null,didDrop:!1});case"dnd-core/PUBLISH_DRAG_SOURCE":return dragOperation_objectSpread({},state,{isSourcePublic:!0});case HOVER:return dragOperation_objectSpread({},state,{targetIds:payload.targetIds});case REMOVE_TARGET:return-1===state.targetIds.indexOf(payload.targetId)?state:dragOperation_objectSpread({},state,{targetIds:(items=state.targetIds,item=payload.targetId,items.filter((i=>i!==item)))});case DROP:return dragOperation_objectSpread({},state,{dropResult:payload.dropResult,didDrop:!0,targetIds:[]});case END_DRAG:return dragOperation_objectSpread({},state,{itemType:null,item:null,sourceId:null,dropResult:null,didDrop:!1,isSourcePublic:null,targetIds:[]});default:return state}var items,item}function refCount_reduce(state=0,action){switch(action.type){case"dnd-core/ADD_SOURCE":case"dnd-core/ADD_TARGET":return state+1;case"dnd-core/REMOVE_SOURCE":case REMOVE_TARGET:return state-1;default:return state}}function stateId_reduce(state=0){return state+1}function reducers_defineProperty(obj,key,value){return key in obj?Object.defineProperty(obj,key,{value:value,enumerable:!0,configurable:!0,writable:!0}):obj[key]=value,obj}function reducers_objectSpread(target){for(var i=1;i<arguments.length;i++){var source=null!=arguments[i]?arguments[i]:{},ownKeys=Object.keys(source);"function"==typeof Object.getOwnPropertySymbols&&(ownKeys=ownKeys.concat(Object.getOwnPropertySymbols(source).filter((function(sym){return Object.getOwnPropertyDescriptor(source,sym).enumerable})))),ownKeys.forEach((function(key){reducers_defineProperty(target,key,source[key])}))}return target}function reducers_reduce(state={},action){return{dirtyHandlerIds:reduce(state.dirtyHandlerIds,{type:action.type,payload:reducers_objectSpread({},action.payload,{prevTargetIds:(obj=state,path="dragOperation.targetIds",defaultValue=[],path.split(".").reduce(((a,c)=>a&&a[c]?a[c]:defaultValue||null),obj))})}),dragOffset:dragOffset_reduce(state.dragOffset,action),refCount:refCount_reduce(state.refCount,action),dragOperation:dragOperation_reduce(state.dragOperation,action),stateId:stateId_reduce(state.stateId)};var obj,path,defaultValue}function createDragDropManager(backendFactory,globalContext,backendOptions={},debugMode=!1){const store=function makeStoreInstance(debugMode){const reduxDevTools="undefined"!=typeof window&&window.__REDUX_DEVTOOLS_EXTENSION__;return createStore(reducers_reduce,debugMode&&reduxDevTools&&reduxDevTools({name:"dnd-core",instanceId:"dnd-core"}))}(debugMode),monitor=new DragDropMonitorImpl(store,new HandlerRegistryImpl(store)),manager=new DragDropManagerImpl(store,monitor),backend=backendFactory(manager,globalContext,backendOptions);return manager.receiveBackend(backend),manager}var react=__webpack_require__("./node_modules/react/index.js");function _objectWithoutProperties(source,excluded){if(null==source)return{};var key,i,target=function _objectWithoutPropertiesLoose(source,excluded){if(null==source)return{};var key,i,target={},sourceKeys=Object.keys(source);for(i=0;i<sourceKeys.length;i++)key=sourceKeys[i],excluded.indexOf(key)>=0||(target[key]=source[key]);return target}(source,excluded);if(Object.getOwnPropertySymbols){var sourceSymbolKeys=Object.getOwnPropertySymbols(source);for(i=0;i<sourceSymbolKeys.length;i++)key=sourceSymbolKeys[i],excluded.indexOf(key)>=0||Object.prototype.propertyIsEnumerable.call(source,key)&&(target[key]=source[key])}return target}let refCount=0;const INSTANCE_SYM=Symbol.for("__REACT_DND_CONTEXT_INSTANCE__");var DndProvider=(0,react.memo)((function DndProvider(_param){var{children:children}=_param,props=_objectWithoutProperties(_param,["children"]);const[manager,isGlobalInstance]=function getDndContextValue(props){if("manager"in props){return[{dragDropManager:props.manager},!1]}const manager=function createSingletonDndContext(backend,context=getGlobalContext(),options,debugMode){const ctx=context;ctx[INSTANCE_SYM]||(ctx[INSTANCE_SYM]={dragDropManager:createDragDropManager(backend,context,options,debugMode)});return ctx[INSTANCE_SYM]}(props.backend,props.context,props.options,props.debugMode),isGlobalInstance=!props.context;return[manager,isGlobalInstance]}(props);return(0,react.useEffect)((()=>{if(isGlobalInstance){const context=getGlobalContext();return++refCount,()=>{0==--refCount&&(context[INSTANCE_SYM]=null)}}}),[]),(0,jsx_runtime.jsx)(DndContext.L.Provider,{value:manager,children:children})}));function getGlobalContext(){return"undefined"!=typeof global?global:window}const DragPreviewImage=(0,react.memo)((function DragPreviewImage({connect:connect,src:src}){return(0,react.useEffect)((()=>{if("undefined"==typeof Image)return;let connected=!1;const img=new Image;return img.src=src,img.onload=()=>{connect(img),connected=!0},()=>{connected&&connect(null)}})),null}));var useDrag=__webpack_require__("./node_modules/react-dnd/dist/hooks/useDrag/useDrag.js"),useDragDropManager=__webpack_require__("./node_modules/react-dnd/dist/hooks/useDragDropManager.js"),useCollector=__webpack_require__("./node_modules/react-dnd/dist/hooks/useCollector.js");function useDragLayer(collect){const monitor=(0,useDragDropManager.N)().getMonitor(),[collected,updateCollected]=(0,useCollector.r)(monitor,collect);return(0,react.useEffect)((()=>monitor.subscribeToOffsetChange(updateCollected))),(0,react.useEffect)((()=>monitor.subscribeToStateChange(updateCollected))),collected}var useDrop=__webpack_require__("./node_modules/react-dnd/dist/hooks/useDrop/useDrop.js")}}]);