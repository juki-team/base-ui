{"version":3,"file":"5999.0165229f.iframe.bundle.js","mappings":";;;AA2DA;;ACIA;ACWA;;AC45BA;;ACv5BA;ACUA;;ACPA;AAMA;AACA;AACA;;;;AAOA;;;AAOA;AAMA;AACA;AACA;AACA;;;;;AAQA;;ACo+EA;AC1pEA;;;AC7TA;AAIA;;AC6vBA;ACxzBA;ACWA;AAEA;AAgBA;AAgBA;AAgBA;;AC1DA;AC1EA;ACSA;ACDA;ACyIA;AA0HA;ACnJA","sources":["webpack://@juki-team/base-ui/./node_modules/handsontable/3rdparty/walkontable/src/renderer/colGroup.mjs","webpack://@juki-team/base-ui/./node_modules/handsontable/3rdparty/walkontable/src/renderer/rows.mjs","webpack://@juki-team/base-ui/./node_modules/handsontable/i18n/utils.mjs","webpack://@juki-team/base-ui/./node_modules/handsontable/selection/selection.mjs","webpack://@juki-team/base-ui/./node_modules/handsontable/shortcuts/context.mjs","webpack://@juki-team/base-ui/./node_modules/handsontable/shortcuts/manager.mjs","webpack://@juki-team/base-ui/./node_modules/handsontable/helpers/mixed.mjs","webpack://@juki-team/base-ui/./node_modules/handsontable/pluginHooks.mjs","webpack://@juki-team/base-ui/./node_modules/handsontable/plugins/columnSummary/columnSummary.mjs","webpack://@juki-team/base-ui/./node_modules/handsontable/plugins/filters/conditionCollection.mjs","webpack://@juki-team/base-ui/./node_modules/handsontable/plugins/filters/filters.mjs","webpack://@juki-team/base-ui/./node_modules/handsontable/plugins/formulas/engine/register.mjs","webpack://@juki-team/base-ui/./node_modules/handsontable/plugins/mergeCells/cellCoords.mjs","webpack://@juki-team/base-ui/./node_modules/handsontable/plugins/mergeCells/cellsCollection.mjs","webpack://@juki-team/base-ui/./node_modules/handsontable/plugins/multiColumnSorting/utils.mjs","webpack://@juki-team/base-ui/./node_modules/handsontable/plugins/nestedHeaders/stateManager/nodeModifiers/hideColumn.mjs","webpack://@juki-team/base-ui/./node_modules/handsontable/plugins/nestedHeaders/stateManager/nodeModifiers/showColumn.mjs","webpack://@juki-team/base-ui/./node_modules/handsontable/plugins/nestedHeaders/nestedHeaders.mjs","webpack://@juki-team/base-ui/./node_modules/handsontable/plugins/nestedRows/utils/rowMoveController.mjs"],"sourcesContent":["import BaseRenderer from \"./_base.mjs\";\nimport { warn } from \"./../../../../helpers/console.mjs\";\nimport { toSingleLine } from \"./../../../../helpers/templateLiteralTag.mjs\";\nimport { addClass } from \"./../../../../helpers/dom/element.mjs\";\nlet performanceWarningAppeared = false;\n\n/**\n * Colgroup renderer responsible for managing (inserting, tracking, rendering) COL elements.\n *\n *   <colgroup> (root node)\n *     ├ <col>   \\\n *     ├ <col>    \\\n *     ├ <col>     - ColGroupRenderer\n *     ├ <col>    /\n *     └ <col>   /.\n *\n * @class {ColGroupRenderer}\n */\nexport default class ColGroupRenderer extends BaseRenderer {\n  constructor(rootNode) {\n    super(null, rootNode); // NodePool is not implemented for this renderer yet\n  }\n\n  /**\n   * Adjusts the number of the rendered elements.\n   */\n  adjust() {\n    const {\n      columnsToRender,\n      rowHeadersCount\n    } = this.table;\n    const allColumnsToRender = columnsToRender + rowHeadersCount;\n    while (this.renderedNodes < allColumnsToRender) {\n      this.rootNode.appendChild(this.table.rootDocument.createElement('col'));\n      this.renderedNodes += 1;\n    }\n    while (this.renderedNodes > allColumnsToRender) {\n      this.rootNode.removeChild(this.rootNode.lastChild);\n      this.renderedNodes -= 1;\n    }\n  }\n\n  /**\n   * Renders the col group elements.\n   */\n  render() {\n    this.adjust();\n    const {\n      columnsToRender,\n      rowHeadersCount\n    } = this.table;\n    if (!performanceWarningAppeared && columnsToRender > 1000) {\n      performanceWarningAppeared = true;\n      warn(toSingleLine`Performance tip: Handsontable rendered more than 1000 visible columns.\\x20\n        Consider limiting the number of rendered columns by specifying the table width and/or\\x20\n        turning off the \"renderAllColumns\" option.`);\n    }\n\n    // Render column nodes for row headers\n    for (let visibleColumnIndex = 0; visibleColumnIndex < rowHeadersCount; visibleColumnIndex++) {\n      const sourceColumnIndex = this.table.renderedColumnToSource(visibleColumnIndex);\n      const width = this.table.columnUtils.getHeaderWidth(sourceColumnIndex);\n      this.rootNode.childNodes[visibleColumnIndex].style.width = `${width}px`;\n    }\n\n    // Render column nodes for cells\n    for (let visibleColumnIndex = 0; visibleColumnIndex < columnsToRender; visibleColumnIndex++) {\n      const sourceColumnIndex = this.table.renderedColumnToSource(visibleColumnIndex);\n      const width = this.table.columnUtils.getStretchedColumnWidth(sourceColumnIndex);\n      this.rootNode.childNodes[visibleColumnIndex + rowHeadersCount].style.width = `${width}px`;\n    }\n    const firstChild = this.rootNode.firstChild;\n    if (firstChild) {\n      addClass(firstChild, 'rowHeader');\n    }\n  }\n}","import \"core-js/modules/es.error.cause.js\";\nfunction _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == typeof i ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != typeof t || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != typeof i) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\nimport BaseRenderer from \"./_base.mjs\";\nimport { warn } from \"./../../../../helpers/console.mjs\";\nimport { toSingleLine } from \"./../../../../helpers/templateLiteralTag.mjs\";\nimport { OrderView } from \"./../utils/orderView/index.mjs\";\nimport { addClass, removeClass, setAttribute } from \"../../../../helpers/dom/element.mjs\";\nimport { A11Y_ROW, A11Y_ROWGROUP, A11Y_ROWINDEX } from \"../../../../helpers/a11y.mjs\";\nconst ROW_CLASSNAMES = {\n  rowEven: 'ht__row_even',\n  rowOdd: 'ht__row_odd'\n};\nlet performanceWarningAppeared = false;\n\n/**\n * Rows renderer responsible for managing (inserting, tracking, rendering) TR elements belongs to TBODY.\n *\n *   <tbody> (root node)\n *     ├ <tr>   \\\n *     ├ <tr>    \\\n *     ├ <tr>     - RowsRenderer\n *     ├ <tr>    /\n *     └ <tr>   /.\n *\n * @class {RowsRenderer}\n */\nexport default class RowsRenderer extends BaseRenderer {\n  constructor(rootNode) {\n    super('TR', rootNode);\n    /**\n     * Cache for OrderView classes connected to specified node.\n     *\n     * @type {WeakMap}\n     */\n    _defineProperty(this, \"orderView\", void 0);\n    this.orderView = new OrderView(rootNode, sourceRowIndex => this.nodesPool.obtain(sourceRowIndex), this.nodeType);\n  }\n\n  /**\n   * Returns currently rendered node.\n   *\n   * @param {string} visualIndex Visual index of the rendered node (it always goeas from 0 to N).\n   * @returns {HTMLTableRowElement}\n   */\n  getRenderedNode(visualIndex) {\n    return this.orderView.getNode(visualIndex);\n  }\n\n  /**\n   * Renders the cells.\n   */\n  render() {\n    const {\n      rowsToRender\n    } = this.table;\n    if (!performanceWarningAppeared && rowsToRender > 1000) {\n      performanceWarningAppeared = true;\n      warn(toSingleLine`Performance tip: Handsontable rendered more than 1000 visible rows.\\x20\n        Consider limiting the number of rendered rows by specifying the table height and/or\\x20\n        turning off the \"renderAllRows\" option.`);\n    }\n    if (this.table.isAriaEnabled()) {\n      setAttribute(this.rootNode, [A11Y_ROWGROUP()]);\n    }\n    this.orderView.setSize(rowsToRender).setOffset(this.table.renderedRowToSource(0)).start();\n    for (let visibleRowIndex = 0; visibleRowIndex < rowsToRender; visibleRowIndex++) {\n      this.orderView.render();\n      const TR = this.orderView.getCurrentNode();\n      const sourceRowIndex = this.table.renderedRowToSource(visibleRowIndex);\n      if (this.table.isAriaEnabled()) {\n        var _this$table$rowUtils$, _this$table$rowUtils;\n        setAttribute(TR, [A11Y_ROW(),\n        // `aria-rowindex` is incremented by both tbody and thead rows.\n        A11Y_ROWINDEX(sourceRowIndex + ((_this$table$rowUtils$ = (_this$table$rowUtils = this.table.rowUtils) === null || _this$table$rowUtils === void 0 || (_this$table$rowUtils = _this$table$rowUtils.dataAccessObject) === null || _this$table$rowUtils === void 0 ? void 0 : _this$table$rowUtils.columnHeaders.length) !== null && _this$table$rowUtils$ !== void 0 ? _this$table$rowUtils$ : 0) + 1)]);\n      }\n      removeClass(TR, [ROW_CLASSNAMES.rowEven, ROW_CLASSNAMES.rowOdd]);\n      if ((sourceRowIndex + 1) % 2 === 0) {\n        addClass(TR, ROW_CLASSNAMES.rowEven);\n      } else {\n        addClass(TR, ROW_CLASSNAMES.rowOdd);\n      }\n    }\n    this.orderView.end();\n  }\n}","import { isUndefined, isDefined } from \"./../helpers/mixed.mjs\";\nimport { objectEach } from \"./../helpers/object.mjs\";\nimport { error } from \"./../helpers/console.mjs\";\nimport { toSingleLine } from \"./../helpers/templateLiteralTag.mjs\";\n/**\n * Perform shallow extend of a target object with only this extension's properties which doesn't exist in the target.\n *\n * TODO: Maybe it should be moved to global helpers? It's changed `extend` function.\n *\n * @param {object} target An object that will receive the new properties.\n * @param {object} extension An object containing additional properties to merge into the target.\n * @returns {object}\n */\nexport function extendNotExistingKeys(target, extension) {\n  objectEach(extension, (value, key) => {\n    if (isUndefined(target[key])) {\n      target[key] = value;\n    }\n  });\n  return target;\n}\n\n/**\n * Create range of values basing on cell indexes. For example, it will create below ranges for specified function arguments:\n *\n * createCellHeadersRange(2, 7) => `2-7`\n * createCellHeadersRange(7, 2) => `2-7`\n * createCellHeadersRange(0, 4, 'A', 'D') => `A-D`\n * createCellHeadersRange(4, 0, 'D', 'A') => `A-D`.\n *\n * @param {number} firstRowIndex Index of \"first\" cell.\n * @param {number} nextRowIndex Index of \"next\" cell.\n * @param {*} fromValue Value which will represent \"first\" cell.\n * @param {*} toValue Value which will represent \"next\" cell.\n * @returns {string} Value representing range i.e. A-Z, 11-15.\n */\nexport function createCellHeadersRange(firstRowIndex, nextRowIndex) {\n  let fromValue = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : firstRowIndex;\n  let toValue = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : nextRowIndex;\n  // Will swap `fromValue` with `toValue` if it's necessary.\n  let [from, to] = [fromValue, toValue];\n  if (firstRowIndex > nextRowIndex) {\n    [from, to] = [to, from];\n  }\n  return `${from}-${to}`;\n}\n\n/**\n * Normalize language code. It takes handled languageCode proposition and change it to proper languageCode.\n * For example, when it takes `eN-us` as parameter it return `en-US`.\n *\n * @param {string} languageCode Language code for specific language i.e. 'en-US', 'pt-BR', 'de-DE'.\n * @returns {string}\n */\nexport function normalizeLanguageCode(languageCode) {\n  const languageCodePattern = /^([a-zA-Z]{2})-([a-zA-Z]{2})$/;\n  const partsOfLanguageCode = languageCodePattern.exec(languageCode);\n  if (partsOfLanguageCode) {\n    return `${partsOfLanguageCode[1].toLowerCase()}-${partsOfLanguageCode[2].toUpperCase()}`;\n  }\n  return languageCode;\n}\n\n/**\n *\n * Warn user if there is no registered language.\n *\n * @param {string} languageCode Language code for specific language i.e. 'en-US', 'pt-BR', 'de-DE'.\n */\nexport function warnUserAboutLanguageRegistration(languageCode) {\n  if (isDefined(languageCode)) {\n    error(toSingleLine`Language with code \"${languageCode}\" was not found. You should register particular language\\x20\n    before using it. Read more about this issue at: https://docs.handsontable.com/i18n/missing-language-code.`);\n  }\n}","import \"core-js/modules/es.error.cause.js\";\nimport \"core-js/modules/es.array.push.js\";\nimport \"core-js/modules/es.set.difference.v2.js\";\nimport \"core-js/modules/es.set.intersection.v2.js\";\nimport \"core-js/modules/es.set.is-disjoint-from.v2.js\";\nimport \"core-js/modules/es.set.is-subset-of.v2.js\";\nimport \"core-js/modules/es.set.is-superset-of.v2.js\";\nimport \"core-js/modules/es.set.symmetric-difference.v2.js\";\nimport \"core-js/modules/es.set.union.v2.js\";\nfunction _classPrivateFieldInitSpec(e, t, a) { _checkPrivateRedeclaration(e, t), t.set(e, a); }\nfunction _checkPrivateRedeclaration(e, t) { if (t.has(e)) throw new TypeError(\"Cannot initialize the same private elements twice on an object\"); }\nfunction _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == typeof i ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != typeof t || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != typeof i) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\nfunction _classPrivateFieldGet(s, a) { return s.get(_assertClassBrand(s, a)); }\nfunction _classPrivateFieldSet(s, a, r) { return s.set(_assertClassBrand(s, a), r), r; }\nfunction _assertClassBrand(e, t, n) { if (\"function\" == typeof e ? e === t : e.has(t)) return arguments.length < 3 ? t : n; throw new TypeError(\"Private element is not present on this object\"); }\nimport Highlight, { AREA_TYPE, HEADER_TYPE, FOCUS_TYPE } from \"./highlight/highlight.mjs\";\nimport SelectionRange from \"./range.mjs\";\nimport { createObjectPropListener, mixin } from \"./../helpers/object.mjs\";\nimport { isUndefined } from \"./../helpers/mixed.mjs\";\nimport { clamp } from \"./../helpers/number.mjs\";\nimport { arrayEach } from \"./../helpers/array.mjs\";\nimport localHooks from \"./../mixins/localHooks.mjs\";\nimport Transformation from \"./transformation.mjs\";\nimport { detectSelectionType, normalizeSelectionFactory, SELECTION_TYPE_EMPTY, SELECTION_TYPE_UNRECOGNIZED } from \"./utils.mjs\";\nimport { toSingleLine } from \"./../helpers/templateLiteralTag.mjs\";\nimport { A11Y_SELECTED } from \"../helpers/a11y.mjs\";\n/**\n * @class Selection\n * @util\n */\nvar _transformation = /*#__PURE__*/new WeakMap();\nvar _focusTransformation = /*#__PURE__*/new WeakMap();\nvar _isFocusSelectionChanged = /*#__PURE__*/new WeakMap();\nvar _disableHeadersHighlight = /*#__PURE__*/new WeakMap();\nvar _selectionSource = /*#__PURE__*/new WeakMap();\nvar _expectedLayersCount = /*#__PURE__*/new WeakMap();\nclass Selection {\n  constructor(settings, tableProps) {\n    var _this = this;\n    /**\n     * Handsontable settings instance.\n     *\n     * @type {GridSettings}\n     */\n    _defineProperty(this, \"settings\", void 0);\n    /**\n     * An additional object with dynamically defined properties which describes table state.\n     *\n     * @type {object}\n     */\n    _defineProperty(this, \"tableProps\", void 0);\n    /**\n     * The flag which determines if the selection is in progress.\n     *\n     * @type {boolean}\n     */\n    _defineProperty(this, \"inProgress\", false);\n    /**\n     * Selection data layer (handle visual coordinates).\n     *\n     * @type {SelectionRange}\n     */\n    _defineProperty(this, \"selectedRange\", new SelectionRange((highlight, from, to) => {\n      return this.tableProps.createCellRange(highlight, from, to);\n    }));\n    /**\n     * Visualization layer.\n     *\n     * @type {Highlight}\n     */\n    _defineProperty(this, \"highlight\", void 0);\n    /**\n     * The module for modifying coordinates of the start and end selection.\n     *\n     * @type {Transformation}\n     */\n    _classPrivateFieldInitSpec(this, _transformation, void 0);\n    /**\n     * The module for modifying coordinates of the focus selection.\n     *\n     * @type {Transformation}\n     */\n    _classPrivateFieldInitSpec(this, _focusTransformation, void 0);\n    /**\n     * The collection of the selection layer levels where the whole row was selected using the row header or\n     * the corner header.\n     *\n     * @type {Set<number>}\n     */\n    _defineProperty(this, \"selectedByRowHeader\", new Set());\n    /**\n     * The collection of the selection layer levels where the whole column was selected using the column header or\n     * the corner header.\n     *\n     * @type {Set<number>}\n     */\n    _defineProperty(this, \"selectedByColumnHeader\", new Set());\n    /**\n     * The flag which determines if the focus selection was changed.\n     *\n     * @type {boolean}\n     */\n    _classPrivateFieldInitSpec(this, _isFocusSelectionChanged, false);\n    /**\n     * When sets disable highlighting the headers even when the logical coordinates points on them.\n     *\n     * @type {boolean}\n     */\n    _classPrivateFieldInitSpec(this, _disableHeadersHighlight, false);\n    /**\n     * The source of the selection. It can be one of the following values: `mouse`, `unknown` or any other string.\n     *\n     * @type {'mouse' | 'unknown' | string}\n     */\n    _classPrivateFieldInitSpec(this, _selectionSource, 'unknown');\n    /**\n     * The number of expected layers. It is used mostly to track when the last selection layer of non-contiguous\n     * selection is applied, thus the viewport scroll is triggered.\n     *\n     * @param {number}\n     */\n    _classPrivateFieldInitSpec(this, _expectedLayersCount, -1);\n    this.settings = settings;\n    this.tableProps = tableProps;\n    this.highlight = new Highlight({\n      headerClassName: settings.currentHeaderClassName,\n      activeHeaderClassName: settings.activeHeaderClassName,\n      rowClassName: settings.currentRowClassName,\n      columnClassName: settings.currentColClassName,\n      cellAttributes: [A11Y_SELECTED()],\n      rowIndexMapper: this.tableProps.rowIndexMapper,\n      columnIndexMapper: this.tableProps.columnIndexMapper,\n      disabledCellSelection: (row, column) => this.tableProps.isDisabledCellSelection(row, column),\n      cellCornerVisible: function () {\n        return _this.isCellCornerVisible(...arguments);\n      },\n      areaCornerVisible: function () {\n        return _this.isAreaCornerVisible(...arguments);\n      },\n      visualToRenderableCoords: coords => this.tableProps.visualToRenderableCoords(coords),\n      renderableToVisualCoords: coords => this.tableProps.renderableToVisualCoords(coords),\n      createCellCoords: (row, column) => this.tableProps.createCellCoords(row, column),\n      createCellRange: (highlight, from, to) => this.tableProps.createCellRange(highlight, from, to)\n    });\n    _classPrivateFieldSet(_transformation, this, new Transformation(this.selectedRange, {\n      rowIndexMapper: this.tableProps.rowIndexMapper,\n      columnIndexMapper: this.tableProps.columnIndexMapper,\n      countRenderableRows: () => this.tableProps.countRenderableRows(),\n      countRenderableColumns: () => this.tableProps.countRenderableColumns(),\n      visualToRenderableCoords: coords => this.tableProps.visualToRenderableCoords(coords),\n      renderableToVisualCoords: coords => this.tableProps.renderableToVisualCoords(coords),\n      findFirstNonHiddenRenderableRow: function () {\n        return _this.tableProps.findFirstNonHiddenRenderableRow(...arguments);\n      },\n      findFirstNonHiddenRenderableColumn: function () {\n        return _this.tableProps.findFirstNonHiddenRenderableColumn(...arguments);\n      },\n      createCellCoords: (row, column) => this.tableProps.createCellCoords(row, column),\n      fixedRowsBottom: () => settings.fixedRowsBottom,\n      minSpareRows: () => settings.minSpareRows,\n      minSpareCols: () => settings.minSpareCols,\n      autoWrapRow: () => settings.autoWrapRow,\n      autoWrapCol: () => settings.autoWrapCol\n    }));\n    _classPrivateFieldSet(_focusTransformation, this, new Transformation(this.selectedRange, {\n      rowIndexMapper: this.tableProps.rowIndexMapper,\n      columnIndexMapper: this.tableProps.columnIndexMapper,\n      countRenderableRows: () => {\n        const range = this.selectedRange.current();\n        return this.tableProps.countRenderableRowsInRange(0, range.getOuterBottomEndCorner().row);\n      },\n      countRenderableColumns: () => {\n        const range = this.selectedRange.current();\n        return this.tableProps.countRenderableColumnsInRange(0, range.getOuterBottomEndCorner().col);\n      },\n      visualToRenderableCoords: coords => this.tableProps.visualToRenderableCoords(coords),\n      renderableToVisualCoords: coords => this.tableProps.renderableToVisualCoords(coords),\n      findFirstNonHiddenRenderableRow: function () {\n        return _this.tableProps.findFirstNonHiddenRenderableRow(...arguments);\n      },\n      findFirstNonHiddenRenderableColumn: function () {\n        return _this.tableProps.findFirstNonHiddenRenderableColumn(...arguments);\n      },\n      createCellCoords: (row, column) => this.tableProps.createCellCoords(row, column),\n      fixedRowsBottom: () => 0,\n      minSpareRows: () => 0,\n      minSpareCols: () => 0,\n      autoWrapRow: () => true,\n      autoWrapCol: () => true\n    }));\n    _classPrivateFieldGet(_transformation, this).addLocalHook('beforeTransformStart', function () {\n      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n        args[_key] = arguments[_key];\n      }\n      return _this.runLocalHooks('beforeModifyTransformStart', ...args);\n    });\n    _classPrivateFieldGet(_transformation, this).addLocalHook('afterTransformStart', function () {\n      for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n        args[_key2] = arguments[_key2];\n      }\n      return _this.runLocalHooks('afterModifyTransformStart', ...args);\n    });\n    _classPrivateFieldGet(_transformation, this).addLocalHook('beforeTransformEnd', function () {\n      for (var _len3 = arguments.length, args = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {\n        args[_key3] = arguments[_key3];\n      }\n      return _this.runLocalHooks('beforeModifyTransformEnd', ...args);\n    });\n    _classPrivateFieldGet(_transformation, this).addLocalHook('afterTransformEnd', function () {\n      for (var _len4 = arguments.length, args = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {\n        args[_key4] = arguments[_key4];\n      }\n      return _this.runLocalHooks('afterModifyTransformEnd', ...args);\n    });\n    _classPrivateFieldGet(_transformation, this).addLocalHook('insertRowRequire', function () {\n      for (var _len5 = arguments.length, args = new Array(_len5), _key5 = 0; _key5 < _len5; _key5++) {\n        args[_key5] = arguments[_key5];\n      }\n      return _this.runLocalHooks('insertRowRequire', ...args);\n    });\n    _classPrivateFieldGet(_transformation, this).addLocalHook('insertColRequire', function () {\n      for (var _len6 = arguments.length, args = new Array(_len6), _key6 = 0; _key6 < _len6; _key6++) {\n        args[_key6] = arguments[_key6];\n      }\n      return _this.runLocalHooks('insertColRequire', ...args);\n    });\n    _classPrivateFieldGet(_transformation, this).addLocalHook('beforeRowWrap', function () {\n      for (var _len7 = arguments.length, args = new Array(_len7), _key7 = 0; _key7 < _len7; _key7++) {\n        args[_key7] = arguments[_key7];\n      }\n      return _this.runLocalHooks('beforeRowWrap', ...args);\n    });\n    _classPrivateFieldGet(_transformation, this).addLocalHook('beforeColumnWrap', function () {\n      for (var _len8 = arguments.length, args = new Array(_len8), _key8 = 0; _key8 < _len8; _key8++) {\n        args[_key8] = arguments[_key8];\n      }\n      return _this.runLocalHooks('beforeColumnWrap', ...args);\n    });\n    _classPrivateFieldGet(_focusTransformation, this).addLocalHook('beforeTransformStart', function () {\n      for (var _len9 = arguments.length, args = new Array(_len9), _key9 = 0; _key9 < _len9; _key9++) {\n        args[_key9] = arguments[_key9];\n      }\n      return _this.runLocalHooks('beforeModifyTransformFocus', ...args);\n    });\n    _classPrivateFieldGet(_focusTransformation, this).addLocalHook('afterTransformStart', function () {\n      for (var _len10 = arguments.length, args = new Array(_len10), _key10 = 0; _key10 < _len10; _key10++) {\n        args[_key10] = arguments[_key10];\n      }\n      return _this.runLocalHooks('afterModifyTransformFocus', ...args);\n    });\n  }\n\n  /**\n   * Get data layer for current selection.\n   *\n   * @returns {SelectionRange}\n   */\n  getSelectedRange() {\n    return this.selectedRange;\n  }\n\n  /**\n   * Marks the source of the selection. It can be one of the following values: `mouse`, or any other string.\n   *\n   * @param {'mouse' | 'unknown' | string} sourceName The source name.\n   */\n  markSource(sourceName) {\n    _classPrivateFieldSet(_selectionSource, this, sourceName);\n  }\n\n  /**\n   * Marks end of the selection source. It restores the selection source to default value which is 'unknown'.\n   */\n  markEndSource() {\n    _classPrivateFieldSet(_selectionSource, this, 'unknown');\n  }\n\n  /**\n   * Returns the source of the selection.\n   *\n   * @returns {'mouse' | 'unknown' | string}\n   */\n  getSelectionSource() {\n    return _classPrivateFieldGet(_selectionSource, this);\n  }\n\n  /**\n   * Set the number of expected layers. The method is not obligatory to call. It is used mostly internally\n   * to determine when the last selection layer of non-contiguous is applied, thus the viewport scroll is triggered.\n   *\n   * @param {number} layersCount The number of expected layers.\n   */\n  setExpectedLayers(layersCount) {\n    _classPrivateFieldSet(_expectedLayersCount, this, layersCount);\n  }\n\n  /**\n   * Indicate that selection process began. It sets internally `.inProgress` property to `true`.\n   */\n  begin() {\n    this.inProgress = true;\n  }\n\n  /**\n   * Indicate that selection process finished. It sets internally `.inProgress` property to `false`.\n   */\n  finish() {\n    this.runLocalHooks('afterSelectionFinished', Array.from(this.selectedRange));\n    this.inProgress = false;\n    _classPrivateFieldSet(_expectedLayersCount, this, -1);\n  }\n\n  /**\n   * Check if the process of selecting the cell/cells is in progress.\n   *\n   * @returns {boolean}\n   */\n  isInProgress() {\n    return this.inProgress;\n  }\n\n  /**\n   * Starts selection range on given coordinate object.\n   *\n   * @param {CellCoords} coords Visual coords.\n   * @param {boolean} [multipleSelection] If `true`, selection will be worked in 'multiple' mode. This option works\n   *                                      only when 'selectionMode' is set as 'multiple'. If the argument is not defined\n   *                                      the default trigger will be used.\n   * @param {boolean} [fragment=false] If `true`, the selection will be treated as a partial selection where the\n   *                                   `setRangeEnd` method won't be called on every `setRangeStart` call.\n   * @param {CellCoords} [highlightCoords] If set, allows changing the coordinates of the highlight/focus cell.\n   */\n  setRangeStart(coords, multipleSelection) {\n    let fragment = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n    let highlightCoords = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : coords;\n    const isMultipleMode = this.settings.selectionMode === 'multiple';\n    const isMultipleSelection = isUndefined(multipleSelection) ? this.tableProps.getShortcutManager().isCtrlPressed() : multipleSelection;\n    // We are creating copy. We would like to modify just the start of the selection by below hook. Then original coords\n    // should be handled by next methods.\n    const coordsClone = coords.clone();\n    _classPrivateFieldSet(_isFocusSelectionChanged, this, false);\n    this.runLocalHooks(`beforeSetRangeStart${fragment ? 'Only' : ''}`, coordsClone);\n    if (!isMultipleMode || isMultipleMode && !isMultipleSelection && isUndefined(multipleSelection)) {\n      this.selectedRange.clear();\n    }\n    this.selectedRange.add(coordsClone).current().setHighlight(highlightCoords.clone());\n    if (this.getLayerLevel() === 0) {\n      this.selectedByRowHeader.clear();\n      this.selectedByColumnHeader.clear();\n    }\n    if (!fragment) {\n      this.setRangeEnd(coords);\n    }\n  }\n\n  /**\n   * Starts selection range on given coordinate object.\n   *\n   * @param {CellCoords} coords Visual coords.\n   * @param {boolean} [multipleSelection] If `true`, selection will be worked in 'multiple' mode. This option works\n   *                                      only when 'selectionMode' is set as 'multiple'. If the argument is not defined\n   *                                      the default trigger will be used.\n   * @param {CellCoords} [highlightCoords] If set, allows changing the coordinates of the highlight/focus cell.\n   */\n  setRangeStartOnly(coords, multipleSelection) {\n    let highlightCoords = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : coords;\n    this.setRangeStart(coords, multipleSelection, true, highlightCoords);\n  }\n\n  /**\n   * Ends selection range on given coordinate object.\n   *\n   * @param {CellCoords} coords Visual coords.\n   */\n  setRangeEnd(coords) {\n    if (this.selectedRange.isEmpty()) {\n      return;\n    }\n    const coordsClone = coords.clone();\n    const countRows = this.tableProps.countRows();\n    const countCols = this.tableProps.countCols();\n    const isSingle = this.selectedRange.current().clone().setTo(coords).isSingleHeader();\n\n    // Ignore processing the end range when the header selection starts overlapping the corner and\n    // the selection is not a single header highlight.\n    if ((countRows > 0 || countCols > 0) && (countRows === 0 && coordsClone.col < 0 && !isSingle || countCols === 0 && coordsClone.row < 0 && !isSingle)) {\n      return;\n    }\n    this.runLocalHooks('beforeSetRangeEnd', coordsClone);\n    this.begin();\n    const cellRange = this.selectedRange.current();\n    if (!this.settings.navigableHeaders) {\n      cellRange.highlight.normalize();\n    }\n    if (this.settings.selectionMode === 'single') {\n      cellRange.setFrom(cellRange.highlight);\n      cellRange.setTo(cellRange.highlight);\n    } else {\n      const horizontalDir = cellRange.getHorizontalDirection();\n      const verticalDir = cellRange.getVerticalDirection();\n      const isMultiple = this.isMultiple();\n      cellRange.setTo(coordsClone);\n      if (isMultiple && (horizontalDir !== cellRange.getHorizontalDirection() || cellRange.getWidth() === 1 && !cellRange.includes(cellRange.highlight))) {\n        cellRange.from.assign({\n          col: cellRange.highlight.col\n        });\n      }\n      if (isMultiple && (verticalDir !== cellRange.getVerticalDirection() || cellRange.getHeight() === 1 && !cellRange.includes(cellRange.highlight))) {\n        cellRange.from.assign({\n          row: cellRange.highlight.row\n        });\n      }\n    }\n\n    // Prevent creating \"area\" selection that overlaps headers.\n    if (countRows > 0 && countCols > 0) {\n      if (!this.settings.navigableHeaders || this.settings.navigableHeaders && !cellRange.isSingleHeader()) {\n        cellRange.to.normalize();\n      }\n    }\n    this.runLocalHooks('beforeHighlightSet');\n    this.setRangeFocus(this.selectedRange.current().highlight);\n    this.applyAndCommit();\n    const isLastLayer = _classPrivateFieldGet(_expectedLayersCount, this) === -1 || this.selectedRange.size() === _classPrivateFieldGet(_expectedLayersCount, this);\n    this.runLocalHooks('afterSetRangeEnd', coords, isLastLayer);\n  }\n\n  /**\n   * Applies and commits the selection to all layers (using the Walkontable Selection API) based on the selection (CellRanges)\n   * collected in the `selectedRange` module.\n   *\n   * @param {CellRange} [cellRange] The cell range to apply. If not provided, the current selection is used.\n   * @param {number} [layerLevel] The layer level to apply. If not provided, the current layer level is used.\n   */\n  applyAndCommit() {\n    let cellRange = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.selectedRange.current();\n    let layerLevel = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.getLayerLevel();\n    const countRows = this.tableProps.countRows();\n    const countCols = this.tableProps.countCols();\n\n    // If the next layer level is lower than previous then clear all area and header highlights. This is the\n    // indication that the new selection is performing.\n    if (layerLevel < this.highlight.layerLevel) {\n      arrayEach(this.highlight.getAreas(), highlight => void highlight.clear());\n      arrayEach(this.highlight.getLayeredAreas(), highlight => void highlight.clear());\n      arrayEach(this.highlight.getRowHeaders(), highlight => void highlight.clear());\n      arrayEach(this.highlight.getColumnHeaders(), highlight => void highlight.clear());\n      arrayEach(this.highlight.getActiveRowHeaders(), highlight => void highlight.clear());\n      arrayEach(this.highlight.getActiveColumnHeaders(), highlight => void highlight.clear());\n      arrayEach(this.highlight.getActiveCornerHeaders(), highlight => void highlight.clear());\n      arrayEach(this.highlight.getRowHighlights(), highlight => void highlight.clear());\n      arrayEach(this.highlight.getColumnHighlights(), highlight => void highlight.clear());\n    }\n    this.highlight.useLayerLevel(layerLevel);\n    const areaHighlight = this.highlight.createArea();\n    const layeredAreaHighlight = this.highlight.createLayeredArea();\n    const rowHeaderHighlight = this.highlight.createRowHeader();\n    const columnHeaderHighlight = this.highlight.createColumnHeader();\n    const activeRowHeaderHighlight = this.highlight.createActiveRowHeader();\n    const activeColumnHeaderHighlight = this.highlight.createActiveColumnHeader();\n    const activeCornerHeaderHighlight = this.highlight.createActiveCornerHeader();\n    const rowHighlight = this.highlight.createRowHighlight();\n    const columnHighlight = this.highlight.createColumnHighlight();\n    areaHighlight.clear();\n    layeredAreaHighlight.clear();\n    rowHeaderHighlight.clear();\n    columnHeaderHighlight.clear();\n    activeRowHeaderHighlight.clear();\n    activeColumnHeaderHighlight.clear();\n    activeCornerHeaderHighlight.clear();\n    rowHighlight.clear();\n    columnHighlight.clear();\n    if (this.highlight.isEnabledFor(AREA_TYPE, cellRange.highlight) && (this.isMultiple() || layerLevel >= 1)) {\n      areaHighlight.add(cellRange.from).add(cellRange.to).commit();\n      layeredAreaHighlight.add(cellRange.from).add(cellRange.to).commit();\n      if (layerLevel === 1) {\n        // For single cell selection in the same layer, we do not create area selection to prevent blue background.\n        // When non-consecutive selection is performed we have to add that missing area selection to the previous layer\n        // based on previous coordinates. It only occurs when the previous selection wasn't select multiple cells.\n        const previousRange = this.selectedRange.previous();\n        this.highlight.useLayerLevel(layerLevel - 1);\n        this.highlight.createArea().add(previousRange.from).commit()\n        // Range may start with hidden indexes. Commit would not found start point (as we add just the `from` coords).\n        .syncWith(previousRange);\n        this.highlight.createLayeredArea().add(previousRange.from).commit()\n        // Range may start with hidden indexes. Commit would not found start point (as we add just the `from` coords).\n        .syncWith(previousRange);\n        this.highlight.useLayerLevel(layerLevel);\n      }\n    }\n    if (this.highlight.isEnabledFor(HEADER_TYPE, cellRange.highlight)) {\n      if (!cellRange.isSingleHeader()) {\n        const rowCoordsFrom = this.tableProps.createCellCoords(Math.max(cellRange.from.row, 0), -1);\n        const rowCoordsTo = this.tableProps.createCellCoords(cellRange.to.row, -1);\n        const columnCoordsFrom = this.tableProps.createCellCoords(-1, Math.max(cellRange.from.col, 0));\n        const columnCoordsTo = this.tableProps.createCellCoords(-1, cellRange.to.col);\n        if (this.settings.selectionMode === 'single') {\n          rowHeaderHighlight.add(rowCoordsFrom).commit();\n          columnHeaderHighlight.add(columnCoordsFrom).commit();\n          rowHighlight.add(rowCoordsFrom).commit();\n          columnHighlight.add(columnCoordsFrom).commit();\n        } else {\n          rowHeaderHighlight.add(rowCoordsFrom).add(rowCoordsTo).commit();\n          columnHeaderHighlight.add(columnCoordsFrom).add(columnCoordsTo).commit();\n          rowHighlight.add(rowCoordsFrom).add(rowCoordsTo).commit();\n          columnHighlight.add(columnCoordsFrom).add(columnCoordsTo).commit();\n        }\n      }\n      const highlightRowHeaders = !_classPrivateFieldGet(_disableHeadersHighlight, this) && this.isEntireRowSelected() && (countCols > 0 && countCols === cellRange.getWidth() || countCols === 0 && this.isSelectedByRowHeader());\n      const highlightColumnHeaders = !_classPrivateFieldGet(_disableHeadersHighlight, this) && this.isEntireColumnSelected() && (countRows > 0 && countRows === cellRange.getHeight() || countRows === 0 && this.isSelectedByColumnHeader());\n      if (highlightRowHeaders) {\n        activeRowHeaderHighlight.add(this.tableProps.createCellCoords(Math.max(cellRange.from.row, 0), Math.min(-this.tableProps.countRowHeaders(), -1))).add(this.tableProps.createCellCoords(Math.max(cellRange.to.row, 0), -1)).commit();\n      }\n      if (highlightColumnHeaders) {\n        activeColumnHeaderHighlight.add(this.tableProps.createCellCoords(Math.min(-this.tableProps.countColHeaders(), -1), Math.max(cellRange.from.col, 0))).add(this.tableProps.createCellCoords(-1, Math.max(cellRange.to.col, 0))).commit();\n      }\n      if (highlightRowHeaders && highlightColumnHeaders) {\n        activeCornerHeaderHighlight.add(this.tableProps.createCellCoords(-this.tableProps.countColHeaders(), -this.tableProps.countRowHeaders())).add(this.tableProps.createCellCoords(-1, -1)).commit();\n      }\n    }\n  }\n\n  /**\n   * Sets the selection focus position at the specified coordinates.\n   *\n   * @param {CellCoords} coords The CellCoords instance with defined visual coordinates.\n   */\n  setRangeFocus(coords) {\n    if (this.selectedRange.isEmpty()) {\n      return;\n    }\n    const cellRange = this.selectedRange.current();\n    if (!this.inProgress) {\n      this.runLocalHooks('beforeSetFocus', coords);\n    }\n    const focusHighlight = this.highlight.getFocus();\n    focusHighlight.clear();\n    cellRange.setHighlight(coords);\n    if (!this.inProgress) {\n      this.runLocalHooks('beforeHighlightSet');\n    }\n    if (this.highlight.isEnabledFor(FOCUS_TYPE, cellRange.highlight)) {\n      focusHighlight.add(cellRange.highlight).commit().syncWith(cellRange);\n    }\n    if (!this.inProgress) {\n      _classPrivateFieldSet(_isFocusSelectionChanged, this, true);\n      this.runLocalHooks('afterSetFocus', cellRange.highlight);\n    }\n  }\n\n  /**\n   * Selects cell relative to the current cell (if possible).\n   *\n   * @param {number} rowDelta Rows number to move, value can be passed as negative number.\n   * @param {number} colDelta Columns number to move, value can be passed as negative number.\n   * @param {boolean} [createMissingRecords=false] If `true` the new rows/columns will be created if necessary.\n   * Otherwise, row/column will be created according to `minSpareRows/minSpareCols` settings of Handsontable.\n   */\n  transformStart(rowDelta, colDelta) {\n    let createMissingRecords = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n    if (this.settings.navigableHeaders) {\n      _classPrivateFieldGet(_transformation, this).setOffsetSize({\n        x: this.tableProps.countRowHeaders(),\n        y: this.tableProps.countColHeaders()\n      });\n    } else {\n      _classPrivateFieldGet(_transformation, this).resetOffsetSize();\n    }\n    this.setRangeStart(_classPrivateFieldGet(_transformation, this).transformStart(rowDelta, colDelta, createMissingRecords));\n  }\n\n  /**\n   * Sets selection end cell relative to the current selection end cell (if possible).\n   *\n   * @param {number} rowDelta Rows number to move, value can be passed as negative number.\n   * @param {number} colDelta Columns number to move, value can be passed as negative number.\n   */\n  transformEnd(rowDelta, colDelta) {\n    if (this.settings.navigableHeaders) {\n      _classPrivateFieldGet(_transformation, this).setOffsetSize({\n        x: this.tableProps.countRowHeaders(),\n        y: this.tableProps.countColHeaders()\n      });\n    } else {\n      _classPrivateFieldGet(_transformation, this).resetOffsetSize();\n    }\n    this.setRangeEnd(_classPrivateFieldGet(_transformation, this).transformEnd(rowDelta, colDelta));\n  }\n\n  /**\n   * Transforms the focus cell selection relative to the current focus position.\n   *\n   * @param {number} rowDelta Rows number to move, value can be passed as negative number.\n   * @param {number} colDelta Columns number to move, value can be passed as negative number.\n   */\n  transformFocus(rowDelta, colDelta) {\n    const range = this.selectedRange.current();\n    const {\n      row,\n      col\n    } = range.getOuterTopStartCorner();\n    const columnsInRange = this.tableProps.countRenderableColumnsInRange(0, col - 1);\n    const rowsInRange = this.tableProps.countRenderableRowsInRange(0, row - 1);\n    if (range.highlight.isHeader()) {\n      // for header focus selection calculate the new coords based on the selection including headers\n      _classPrivateFieldGet(_focusTransformation, this).setOffsetSize({\n        x: col < 0 ? Math.abs(col) : -columnsInRange,\n        y: row < 0 ? Math.abs(row) : -rowsInRange\n      });\n    } else {\n      // for focus selection in cells calculate the new coords only based on the selected cells\n      _classPrivateFieldGet(_focusTransformation, this).setOffsetSize({\n        x: col < 0 ? 0 : -columnsInRange,\n        y: row < 0 ? 0 : -rowsInRange\n      });\n    }\n    const focusCoords = _classPrivateFieldGet(_focusTransformation, this).transformStart(rowDelta, colDelta);\n    this.setRangeFocus(focusCoords.normalize());\n  }\n\n  /**\n   * Transforms the last selection layer down or up by the index count.\n   *\n   * @param {number} visualRowIndex Visual row index from which the selection will be shifted.\n   * @param {number} amount The number of rows to shift the selection.\n   */\n  shiftRows(visualRowIndex, amount) {\n    if (!this.isSelected()) {\n      return;\n    }\n    const range = this.selectedRange.current();\n    if (this.isSelectedByCorner()) {\n      this.selectAll(true, true, {\n        disableHeadersHighlight: true\n      });\n    } else if (this.isSelectedByColumnHeader() || range.getOuterTopStartCorner().row >= visualRowIndex) {\n      const {\n        from,\n        to,\n        highlight\n      } = range;\n      const countRows = this.tableProps.countRows();\n      const isSelectedByRowHeader = this.isSelectedByRowHeader();\n      const isSelectedByColumnHeader = this.isSelectedByColumnHeader();\n      const minRow = isSelectedByColumnHeader ? -1 : 0;\n      const coordsStartAmount = isSelectedByColumnHeader ? 0 : amount;\n\n      // Remove from the stack the last added selection as that selection below will be\n      // replaced by new transformed selection.\n      this.getSelectedRange().pop();\n      const coordsStart = this.tableProps.createCellCoords(clamp(from.row + coordsStartAmount, minRow, countRows - 1), from.col);\n      const coordsEnd = this.tableProps.createCellCoords(clamp(to.row + amount, minRow, countRows - 1), to.col);\n      this.markSource('shift');\n      if (highlight.row >= visualRowIndex) {\n        this.setRangeStartOnly(coordsStart, true, this.tableProps.createCellCoords(clamp(highlight.row + amount, 0, countRows - 1), highlight.col));\n      } else {\n        this.setRangeStartOnly(coordsStart, true);\n      }\n      if (isSelectedByRowHeader) {\n        this.selectedByRowHeader.add(this.getLayerLevel());\n      }\n      if (isSelectedByColumnHeader) {\n        this.selectedByColumnHeader.add(this.getLayerLevel());\n      }\n      this.setRangeEnd(coordsEnd);\n      this.markEndSource();\n    }\n  }\n\n  /**\n   * Transforms the last selection layer left or right by the index count.\n   *\n   * @param {number} visualColumnIndex Visual column index from which the selection will be shifted.\n   * @param {number} amount The number of columns to shift the selection.\n   */\n  shiftColumns(visualColumnIndex, amount) {\n    if (!this.isSelected()) {\n      return;\n    }\n    const range = this.selectedRange.current();\n    if (this.isSelectedByCorner()) {\n      this.selectAll(true, true, {\n        disableHeadersHighlight: true\n      });\n    } else if (this.isSelectedByRowHeader() || range.getOuterTopStartCorner().col >= visualColumnIndex) {\n      const {\n        from,\n        to,\n        highlight\n      } = range;\n      const countCols = this.tableProps.countCols();\n      const isSelectedByRowHeader = this.isSelectedByRowHeader();\n      const isSelectedByColumnHeader = this.isSelectedByColumnHeader();\n      const minColumn = isSelectedByRowHeader ? -1 : 0;\n      const coordsStartAmount = isSelectedByRowHeader ? 0 : amount;\n\n      // Remove from the stack the last added selection as that selection below will be\n      // replaced by new transformed selection.\n      this.getSelectedRange().pop();\n      const coordsStart = this.tableProps.createCellCoords(from.row, clamp(from.col + coordsStartAmount, minColumn, countCols - 1));\n      const coordsEnd = this.tableProps.createCellCoords(to.row, clamp(to.col + amount, minColumn, countCols - 1));\n      this.markSource('shift');\n      if (highlight.col >= visualColumnIndex) {\n        this.setRangeStartOnly(coordsStart, true, this.tableProps.createCellCoords(highlight.row, clamp(highlight.col + amount, 0, countCols - 1)));\n      } else {\n        this.setRangeStartOnly(coordsStart, true);\n      }\n      if (isSelectedByRowHeader) {\n        this.selectedByRowHeader.add(this.getLayerLevel());\n      }\n      if (isSelectedByColumnHeader) {\n        this.selectedByColumnHeader.add(this.getLayerLevel());\n      }\n      this.setRangeEnd(coordsEnd);\n      this.markEndSource();\n    }\n  }\n\n  /**\n   * Returns currently used layer level.\n   *\n   * @returns {number} Returns layer level starting from 0. If no selection was added to the table -1 is returned.\n   */\n  getLayerLevel() {\n    return this.selectedRange.size() - 1;\n  }\n\n  /**\n   * Returns `true` if currently there is a selection on the screen, `false` otherwise.\n   *\n   * @returns {boolean}\n   */\n  isSelected() {\n    return !this.selectedRange.isEmpty();\n  }\n\n  /**\n   * Returns information if we have a multi-selection. This method check multi-selection only on the latest layer of\n   * the selection.\n   *\n   * @returns {boolean}\n   */\n  isMultiple() {\n    if (!this.isSelected()) {\n      return false;\n    }\n    const isMultipleListener = createObjectPropListener(!this.selectedRange.current().isSingle());\n    this.runLocalHooks('afterIsMultipleSelection', isMultipleListener);\n    return isMultipleListener.value;\n  }\n\n  /**\n   * Checks if the last selection involves changing the focus cell position only.\n   *\n   * @returns {boolean}\n   */\n  isFocusSelectionChanged() {\n    return this.isSelected() && _classPrivateFieldGet(_isFocusSelectionChanged, this);\n  }\n\n  /**\n   * Returns `true` if the selection was applied by clicking to the row header. If the `layerLevel`\n   * argument is passed then only that layer will be checked. Otherwise, it checks if any row header\n   * was clicked on any selection layer level.\n   *\n   * @param {number} [layerLevel=this.getLayerLevel()] Selection layer level to check.\n   * @returns {boolean}\n   */\n  isSelectedByRowHeader() {\n    let layerLevel = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.getLayerLevel();\n    return !this.isSelectedByCorner(layerLevel) && (layerLevel === -1 ? this.selectedByRowHeader.size > 0 : this.selectedByRowHeader.has(layerLevel));\n  }\n\n  /**\n   * Returns `true` if the selection consists of entire rows (including their headers). If the `layerLevel`\n   * argument is passed then only that layer will be checked. Otherwise, it checks the selection for all layers.\n   *\n   * @param {number} [layerLevel=this.getLayerLevel()] Selection layer level to check.\n   * @returns {boolean}\n   */\n  isEntireRowSelected() {\n    let layerLevel = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.getLayerLevel();\n    const tester = range => {\n      const {\n        col\n      } = range.getOuterTopStartCorner();\n      const rowHeaders = this.tableProps.countRowHeaders();\n      const countCols = this.tableProps.countCols();\n      return (rowHeaders > 0 && col < 0 || rowHeaders === 0) && range.getWidth() === countCols;\n    };\n    if (layerLevel === -1) {\n      return Array.from(this.selectedRange).some(range => tester(range));\n    }\n    const range = this.selectedRange.peekByIndex(layerLevel);\n    return range ? tester(range) : false;\n  }\n\n  /**\n   * Returns `true` if the selection was applied by clicking to the column header. If the `layerLevel`\n   * argument is passed then only that layer will be checked. Otherwise, it checks if any column header\n   * was clicked on any selection layer level.\n   *\n   * @param {number} [layerLevel=this.getLayerLevel()] Selection layer level to check.\n   * @returns {boolean}\n   */\n  isSelectedByColumnHeader() {\n    let layerLevel = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.getLayerLevel();\n    return !this.isSelectedByCorner() && (layerLevel === -1 ? this.selectedByColumnHeader.size > 0 : this.selectedByColumnHeader.has(layerLevel));\n  }\n\n  /**\n   * Returns `true` if the selection consists of entire columns (including their headers). If the `layerLevel`\n   * argument is passed then only that layer will be checked. Otherwise, it checks the selection for all layers.\n   *\n   * @param {number} [layerLevel=this.getLayerLevel()] Selection layer level to check.\n   * @returns {boolean}\n   */\n  isEntireColumnSelected() {\n    let layerLevel = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.getLayerLevel();\n    const tester = range => {\n      const {\n        row\n      } = range.getOuterTopStartCorner();\n      const colHeaders = this.tableProps.countColHeaders();\n      const countRows = this.tableProps.countRows();\n      return (colHeaders > 0 && row < 0 || colHeaders === 0) && range.getHeight() === countRows;\n    };\n    if (layerLevel === -1) {\n      return Array.from(this.selectedRange).some(range => tester(range));\n    }\n    const range = this.selectedRange.peekByIndex(layerLevel);\n    return range ? tester(range) : false;\n  }\n\n  /**\n   * Returns `true` if the selection was applied by clicking on the row or column header on any layer level.\n   *\n   * @returns {boolean}\n   */\n  isSelectedByAnyHeader() {\n    return this.isSelectedByRowHeader(-1) || this.isSelectedByColumnHeader(-1) || this.isSelectedByCorner();\n  }\n\n  /**\n   * Returns `true` if the selection was applied by clicking on the left-top corner overlay.\n   *\n   * @returns {boolean}\n   */\n  isSelectedByCorner() {\n    return this.selectedByColumnHeader.has(this.getLayerLevel()) && this.selectedByRowHeader.has(this.getLayerLevel());\n  }\n\n  /**\n   * Returns `true` if coords is within selection coords. This method iterates through all selection layers to check if\n   * the coords object is within selection range.\n   *\n   * @param {CellCoords} coords The CellCoords instance with defined visual coordinates.\n   * @returns {boolean}\n   */\n  inInSelection(coords) {\n    return this.selectedRange.includes(coords);\n  }\n\n  /**\n   * Returns `true` if the cell corner should be visible.\n   *\n   * @private\n   * @returns {boolean} `true` if the corner element has to be visible, `false` otherwise.\n   */\n  isCellCornerVisible() {\n    return this.settings.fillHandle && !this.tableProps.isEditorOpened() && !this.isMultiple();\n  }\n\n  /**\n   * Returns `true` if the cell coordinates are visible (renderable).\n   *\n   * @private\n   * @param {CellCoords} coords The cell coordinates to check.\n   * @returns {boolean}\n   */\n  isCellVisible(coords) {\n    const renderableCoords = this.tableProps.visualToRenderableCoords(coords);\n    return renderableCoords.row !== null && renderableCoords.col !== null;\n  }\n\n  /**\n   * Returns `true` if the area corner should be visible.\n   *\n   * @param {number} layerLevel The layer level.\n   * @returns {boolean} `true` if the corner element has to be visible, `false` otherwise.\n   */\n  isAreaCornerVisible(layerLevel) {\n    if (Number.isInteger(layerLevel) && layerLevel !== this.getLayerLevel()) {\n      return false;\n    }\n    return this.settings.fillHandle && !this.tableProps.isEditorOpened() && this.isMultiple();\n  }\n\n  /**\n   * Clear the selection by resetting the collected ranges and highlights.\n   */\n  clear() {\n    // TODO: collections selectedByColumnHeader and selectedByRowHeader should be clear too.\n    this.selectedRange.clear();\n    this.highlight.clear();\n  }\n\n  /**\n   * Deselects all selected cells.\n   */\n  deselect() {\n    if (!this.isSelected()) {\n      return;\n    }\n    this.inProgress = false;\n    this.clear();\n    this.runLocalHooks('afterDeselect');\n  }\n\n  /**\n   * Selects all cells and headers.\n   *\n   * @param {boolean} [includeRowHeaders=false] `true` If the selection should include the row headers,\n   * `false` otherwise.\n   * @param {boolean} [includeColumnHeaders=false] `true` If the selection should include the column\n   * headers, `false` otherwise.\n   * @param {object} [options] Additional object with options.\n   * @param {{row: number, col: number} | boolean} [options.focusPosition] The argument allows changing the cell/header\n   * focus position. The value takes an object with a `row` and `col` properties from -N to N, where\n   * negative values point to the headers and positive values point to the cell range. If `false`, the focus\n   * position won't be changed.\n   * @param {boolean} [options.disableHeadersHighlight] If `true`, disables highlighting the headers even when\n   * the logical coordinates points on them.\n   */\n  selectAll() {\n    var _this$getSelectedRang;\n    let includeRowHeaders = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n    let includeColumnHeaders = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n    let options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {\n      focusPosition: false,\n      disableHeadersHighlight: false\n    };\n    const nrOfRows = this.tableProps.countRows();\n    const nrOfColumns = this.tableProps.countCols();\n    const countRowHeaders = this.tableProps.countRowHeaders();\n    const countColHeaders = this.tableProps.countColHeaders();\n    const rowFrom = includeColumnHeaders ? -countColHeaders : 0;\n    const columnFrom = includeRowHeaders ? -countRowHeaders : 0;\n\n    // We can't select cells when there is no data.\n    if (rowFrom === 0 && columnFrom === 0 && (nrOfRows === 0 || nrOfColumns === 0)) {\n      return;\n    }\n    let highlight = (_this$getSelectedRang = this.getSelectedRange().current()) === null || _this$getSelectedRang === void 0 ? void 0 : _this$getSelectedRang.highlight;\n    const {\n      focusPosition,\n      disableHeadersHighlight\n    } = options;\n    _classPrivateFieldSet(_disableHeadersHighlight, this, disableHeadersHighlight);\n    if (focusPosition && Number.isInteger(focusPosition === null || focusPosition === void 0 ? void 0 : focusPosition.row) && Number.isInteger(focusPosition === null || focusPosition === void 0 ? void 0 : focusPosition.col)) {\n      highlight = this.tableProps.createCellCoords(clamp(focusPosition.row, rowFrom, nrOfRows - 1), clamp(focusPosition.col, columnFrom, nrOfColumns - 1));\n    }\n    const startCoords = this.tableProps.createCellCoords(rowFrom, columnFrom);\n    const endCoords = this.tableProps.createCellCoords(nrOfRows - 1, nrOfColumns - 1);\n    this.clear();\n    this.setRangeStartOnly(startCoords, undefined, highlight);\n    if (columnFrom < 0) {\n      this.selectedByRowHeader.add(this.getLayerLevel());\n    }\n    if (rowFrom < 0) {\n      this.selectedByColumnHeader.add(this.getLayerLevel());\n    }\n    this.setRangeEnd(endCoords);\n    this.finish();\n    _classPrivateFieldSet(_disableHeadersHighlight, this, false);\n  }\n\n  /**\n   * Make multiple, non-contiguous selection specified by `row` and `column` values or a range of cells\n   * finishing at `endRow`, `endColumn`. The method supports two input formats, first as an array of arrays such\n   * as `[[rowStart, columnStart, rowEnd, columnEnd]]` and second format as an array of CellRange objects.\n   * If the passed ranges have another format the exception will be thrown.\n   *\n   * @param {Array[]|CellRange[]} selectionRanges The coordinates which define what the cells should be selected.\n   * @returns {boolean} Returns `true` if selection was successful, `false` otherwise.\n   */\n  selectCells(selectionRanges) {\n    var _this2 = this;\n    const selectionType = detectSelectionType(selectionRanges);\n    if (selectionType === SELECTION_TYPE_EMPTY) {\n      return false;\n    } else if (selectionType === SELECTION_TYPE_UNRECOGNIZED) {\n      throw new Error(toSingleLine`Unsupported format of the selection ranges was passed. To select cells pass\\x20\n        the coordinates as an array of arrays ([[rowStart, columnStart/columnPropStart, rowEnd,\\x20\n        columnEnd/columnPropEnd]]) or as an array of CellRange objects.`);\n    }\n    const selectionSchemaNormalizer = normalizeSelectionFactory(selectionType, {\n      createCellCoords: function () {\n        return _this2.tableProps.createCellCoords(...arguments);\n      },\n      createCellRange: function () {\n        return _this2.tableProps.createCellRange(...arguments);\n      },\n      propToCol: prop => this.tableProps.propToCol(prop),\n      keepDirection: true\n    });\n    const navigableHeaders = this.settings.navigableHeaders;\n    const tableParams = {\n      countRows: this.tableProps.countRows(),\n      countCols: this.tableProps.countCols(),\n      countRowHeaders: navigableHeaders ? this.tableProps.countRowHeaders() : 0,\n      countColHeaders: navigableHeaders ? this.tableProps.countColHeaders() : 0\n    };\n\n    // Check if every layer of the coordinates are valid.\n    const isValid = !selectionRanges.some(selection => {\n      const cellRange = selectionSchemaNormalizer(selection);\n      const rangeValidity = cellRange.isValid(tableParams);\n      return !(rangeValidity && !cellRange.containsHeaders() || rangeValidity && cellRange.containsHeaders() && cellRange.isSingleHeader());\n    });\n    if (isValid) {\n      this.clear();\n      this.setExpectedLayers(selectionRanges.length);\n      arrayEach(selectionRanges, selection => {\n        const {\n          from,\n          to\n        } = selectionSchemaNormalizer(selection);\n        this.setRangeStartOnly(from.clone(), false);\n        this.setRangeEnd(to.clone());\n      });\n      this.finish();\n    }\n    return isValid;\n  }\n\n  /**\n   * Select column specified by `startColumn` visual index or column property or a range of columns finishing at\n   * `endColumn`.\n   *\n   * @param {number|string} startColumn Visual column index or column property from which the selection starts.\n   * @param {number|string} [endColumn] Visual column index or column property from to the selection finishes.\n   * @param {number | { row: number, col: number }} [focusPosition=0] The argument allows changing the cell/header focus\n   * position. The value can take visual row index from -N to N, where negative values point to the headers and positive\n   * values point to the cell range. An object with `row` and `col` properties also can be passed to change the focus\n   * position horizontally.\n   * @returns {boolean} Returns `true` if selection was successful, `false` otherwise.\n   */\n  selectColumns(startColumn) {\n    let endColumn = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : startColumn;\n    let focusPosition = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n    const start = typeof startColumn === 'string' ? this.tableProps.propToCol(startColumn) : startColumn;\n    const end = typeof endColumn === 'string' ? this.tableProps.propToCol(endColumn) : endColumn;\n    const countRows = this.tableProps.countRows();\n    const countCols = this.tableProps.countCols();\n    const countColHeaders = this.tableProps.countColHeaders();\n    const columnHeaderLastIndex = countColHeaders === 0 ? 0 : -countColHeaders;\n    const fromCoords = this.tableProps.createCellCoords(columnHeaderLastIndex, start);\n    const toCoords = this.tableProps.createCellCoords(countRows - 1, end);\n    const isValid = this.tableProps.createCellRange(fromCoords, fromCoords, toCoords).isValid({\n      countRows,\n      countCols,\n      countRowHeaders: 0,\n      countColHeaders\n    });\n    if (isValid) {\n      let highlightRow = 0;\n      let highlightColumn = 0;\n      if (Number.isInteger(focusPosition === null || focusPosition === void 0 ? void 0 : focusPosition.row) && Number.isInteger(focusPosition === null || focusPosition === void 0 ? void 0 : focusPosition.col)) {\n        highlightRow = clamp(focusPosition.row, columnHeaderLastIndex, countRows - 1);\n        highlightColumn = clamp(focusPosition.col, Math.min(start, end), Math.max(start, end));\n      } else {\n        highlightRow = clamp(focusPosition, columnHeaderLastIndex, countRows - 1);\n        highlightColumn = start;\n      }\n      const highlight = this.tableProps.createCellCoords(highlightRow, highlightColumn);\n      const fromRow = countColHeaders === 0 ? 0 : clamp(highlight.row, columnHeaderLastIndex, -1);\n      const toRow = countRows - 1;\n      const from = this.tableProps.createCellCoords(fromRow, start);\n      const to = this.tableProps.createCellCoords(toRow, end);\n      this.runLocalHooks('beforeSelectColumns', from, to, highlight);\n\n      // disallow modifying row axis for that hooks\n      from.row = fromRow;\n      to.row = toRow;\n      this.setRangeStartOnly(from, undefined, highlight);\n      this.selectedByColumnHeader.add(this.getLayerLevel());\n      this.setRangeEnd(to);\n      this.runLocalHooks('afterSelectColumns', from, to, highlight);\n      this.finish();\n    }\n    return isValid;\n  }\n\n  /**\n   * Select row specified by `startRow` visual index or a range of rows finishing at `endRow`.\n   *\n   * @param {number} startRow Visual row index from which the selection starts.\n   * @param {number} [endRow] Visual row index from to the selection finishes.\n   * @param {number | { row: number, col: number }} [focusPosition=0] The argument allows changing the cell/header focus\n   * position. The value can take visual row index from -N to N, where negative values point to the headers and positive\n   * values point to the cell range. An object with `row` and `col` properties also can be passed to change the focus\n   * position horizontally.\n   * @returns {boolean} Returns `true` if selection was successful, `false` otherwise.\n   */\n  selectRows(startRow) {\n    let endRow = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : startRow;\n    let focusPosition = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n    const countRows = this.tableProps.countRows();\n    const countCols = this.tableProps.countCols();\n    const countRowHeaders = this.tableProps.countRowHeaders();\n    const rowHeaderLastIndex = countRowHeaders === 0 ? 0 : -countRowHeaders;\n    const fromCoords = this.tableProps.createCellCoords(startRow, rowHeaderLastIndex);\n    const toCoords = this.tableProps.createCellCoords(endRow, countCols - 1);\n    const isValid = this.tableProps.createCellRange(fromCoords, fromCoords, toCoords).isValid({\n      countRows,\n      countCols,\n      countRowHeaders,\n      countColHeaders: 0\n    });\n    if (isValid) {\n      let highlightRow = 0;\n      let highlightColumn = 0;\n      if (Number.isInteger(focusPosition === null || focusPosition === void 0 ? void 0 : focusPosition.row) && Number.isInteger(focusPosition === null || focusPosition === void 0 ? void 0 : focusPosition.col)) {\n        highlightRow = clamp(focusPosition.row, Math.min(startRow, endRow), Math.max(startRow, endRow));\n        highlightColumn = clamp(focusPosition.col, rowHeaderLastIndex, countCols - 1);\n      } else {\n        highlightRow = startRow;\n        highlightColumn = clamp(focusPosition, rowHeaderLastIndex, countCols - 1);\n      }\n      const highlight = this.tableProps.createCellCoords(highlightRow, highlightColumn);\n      const fromColumn = countRowHeaders === 0 ? 0 : clamp(highlight.col, rowHeaderLastIndex, -1);\n      const toColumn = countCols - 1;\n      const from = this.tableProps.createCellCoords(startRow, fromColumn);\n      const to = this.tableProps.createCellCoords(endRow, toColumn);\n      this.runLocalHooks('beforeSelectRows', from, to, highlight);\n\n      // disallow modifying column axis for that hooks\n      from.col = fromColumn;\n      to.col = toColumn;\n      this.setRangeStartOnly(from, undefined, highlight);\n      this.selectedByRowHeader.add(this.getLayerLevel());\n      this.setRangeEnd(to);\n      this.runLocalHooks('afterSelectRows', from, to, highlight);\n      this.finish();\n    }\n    return isValid;\n  }\n\n  /**\n   * Refreshes the whole selection by clearing, reapplying and committing the renderable selection (Walkontable Selection API)\n   * by using already added visual ranges.\n   */\n  refresh() {\n    if (!this.isSelected()) {\n      return;\n    }\n    const countRows = this.tableProps.countRows();\n    const countColumns = this.tableProps.countCols();\n    if (countRows === 0 || countColumns === 0) {\n      this.deselect();\n      return;\n    }\n    const range = this.selectedRange.peekByIndex(this.selectedRange.size() - 1);\n    const {\n      from,\n      to,\n      highlight\n    } = range;\n    this.clear();\n    highlight.assign({\n      row: clamp(highlight.row, -Infinity, countRows - 1),\n      col: clamp(highlight.col, -Infinity, countColumns - 1)\n    });\n    from.assign({\n      row: clamp(from.row, -Infinity, countRows - 1),\n      col: clamp(from.col, -Infinity, countColumns - 1)\n    });\n    to.assign({\n      row: clamp(to.row, 0, countRows - 1),\n      col: clamp(to.col, 0, countColumns - 1)\n    });\n    this.selectedRange.ranges.push(range);\n    this.highlight.getFocus().add(highlight).commit().syncWith(range);\n    this.applyAndCommit(range);\n  }\n\n  /**\n   * Refreshes the whole selection by recommitting (recalculating visual indexes to renderable ones) the renderable selection\n   * that was already added.\n   */\n  commit() {\n    const customSelections = this.highlight.getCustomSelections();\n    customSelections.forEach(customSelection => {\n      customSelection.commit();\n    });\n    if (!this.isSelected()) {\n      return;\n    }\n    const focusHighlight = this.highlight.getFocus();\n    const currentLayer = this.getLayerLevel();\n    focusHighlight.commit().syncWith(this.selectedRange.current());\n\n    // Rewriting rendered ranges going through all layers.\n    for (let layerLevel = 0; layerLevel < this.selectedRange.size(); layerLevel += 1) {\n      this.highlight.useLayerLevel(layerLevel);\n      const areaHighlight = this.highlight.createArea();\n      const areaLayeredHighlight = this.highlight.createLayeredArea();\n      const rowHeaderHighlight = this.highlight.createRowHeader();\n      const columnHeaderHighlight = this.highlight.createColumnHeader();\n      const activeRowHeaderHighlight = this.highlight.createActiveRowHeader();\n      const activeColumnHeaderHighlight = this.highlight.createActiveColumnHeader();\n      const activeCornerHeaderHighlight = this.highlight.createActiveCornerHeader();\n      const rowHighlight = this.highlight.createRowHighlight();\n      const columnHighlight = this.highlight.createColumnHighlight();\n      areaHighlight.commit();\n      areaLayeredHighlight.commit();\n      rowHeaderHighlight.commit();\n      columnHeaderHighlight.commit();\n      activeRowHeaderHighlight.commit();\n      activeColumnHeaderHighlight.commit();\n      activeCornerHeaderHighlight.commit();\n      rowHighlight.commit();\n      columnHighlight.commit();\n    }\n\n    // Reverting starting layer for the Highlight.\n    this.highlight.useLayerLevel(currentLayer);\n  }\n}\nmixin(Selection, localHooks);\nexport default Selection;","import \"core-js/modules/es.error.cause.js\";\nimport \"core-js/modules/es.array.push.js\";\nimport { createUniqueMap } from \"../utils/dataStructures/uniqueMap.mjs\";\nimport { normalizeKeys, getKeysList } from \"./utils.mjs\";\nimport { isUndefined, isDefined } from \"../helpers/mixed.mjs\";\nimport { isFunction } from \"../helpers/function.mjs\";\nimport { objectEach, isObject } from \"../helpers/object.mjs\";\nimport { toSingleLine } from \"../helpers/templateLiteralTag.mjs\";\nconst __kindOf = Symbol('shortcut-context');\n\n/**\n * Checks if the provided object is a context object.\n *\n * @param {*} objectToCheck An object to check.\n * @returns {boolean}\n */\nexport function isContextObject(objectToCheck) {\n  return isObject(objectToCheck) && objectToCheck.__kindOf === __kindOf;\n}\n\n/* eslint-disable jsdoc/require-description-complete-sentence */\n/**\n * The `ShortcutContext` API lets you store and manage [keyboard shortcuts](@/guides/navigation/keyboard-shortcuts/keyboard-shortcuts.md) in a given [context](@/guides/navigation/keyboard-shortcuts/keyboard-shortcuts.md#keyboard-shortcut-contexts).\n *\n * Each `ShortcutContext` object stores and manages its own set of keyboard shortcuts.\n *\n * @alias ShortcutContext\n * @class ShortcutContext\n * @param {string} name The name of the keyboard shortcut context\n * @returns {object}\n */\nexport const createContext = name => {\n  const SHORTCUTS = createUniqueMap({\n    errorIdExists: keys => `The \"${keys}\" shortcut is already registered in the \"${name}\" context.`\n  });\n\n  /**\n   * Add a keyboard shortcut to this context.\n   *\n   * @memberof ShortcutContext#\n   * @param {object} options The shortcut's options\n   * @param {Array<Array<string>>} options.keys Names of the shortcut's keys,\n   * (coming from [`KeyboardEvent.key`](https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent/key/Key_Values)),\n   * in lowercase or uppercase, unified across browsers\n   * @param {Function} options.callback The shortcut's action\n   * @param {object} options.group A group of shortcuts to which the shortcut belongs\n   * @param {object} [options.runOnlyIf] A condition on which the shortcut's action runs\n   * @param {object} [options.stopPropagation=false] If set to `true`: stops the event's propagation\n   * @param {object} [options.captureCtrl=false] If set to `true`: captures the state of the Control/Meta modifier key\n   * @param {object} [options.preventDefault=true] If set to `true`: prevents the default behavior\n   * @param {object} [options.position='after'] The order in which the shortcut's action runs:\n   * `'before'` or `'after'` the `relativeToGroup` group of actions\n   * @param {object} [options.relativeToGroup] The name of a group of actions, used to determine an action's `position`\n   * @param {object} [options.forwardToContext] The context object where the event will be forwarded to.\n   */\n  const addShortcut = function () {\n    let {\n      keys,\n      callback,\n      group,\n      runOnlyIf = () => true,\n      captureCtrl = false,\n      preventDefault = true,\n      stopPropagation = false,\n      relativeToGroup,\n      position,\n      forwardToContext\n    } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    if (isUndefined(group)) {\n      throw new Error('You need to define the shortcut\\'s group.');\n    }\n    if (isFunction(callback) === false) {\n      throw new Error('The shortcut\\'s callback needs to be a function.');\n    }\n    if (Array.isArray(keys) === false) {\n      throw new Error(toSingleLine`Pass the shortcut\\'s keys as an array of arrays,\\x20\n      using the KeyboardEvent.key properties:\\x20\n      https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent/key/Key_Values.`);\n    }\n    const newShortcut = {\n      callback,\n      group,\n      runOnlyIf,\n      captureCtrl,\n      preventDefault,\n      stopPropagation\n    };\n    if (isDefined(relativeToGroup)) {\n      newShortcut.relativeToGroup = relativeToGroup;\n      newShortcut.position = position;\n    }\n    if (isContextObject(forwardToContext)) {\n      newShortcut.forwardToContext = forwardToContext;\n    }\n    keys.forEach(keyCombination => {\n      const normalizedKeys = normalizeKeys(keyCombination);\n      const hasKeyCombination = SHORTCUTS.hasItem(normalizedKeys);\n      if (hasKeyCombination) {\n        const shortcuts = SHORTCUTS.getItem(normalizedKeys);\n        let insertionIndex = shortcuts.findIndex(shortcut => shortcut.group === relativeToGroup);\n        if (insertionIndex !== -1) {\n          if (position === 'before') {\n            insertionIndex -= 1;\n          } else {\n            insertionIndex += 1;\n          }\n        } else {\n          insertionIndex = shortcuts.length;\n        }\n        shortcuts.splice(insertionIndex, 0, newShortcut);\n      } else {\n        SHORTCUTS.addItem(normalizedKeys, [newShortcut]);\n      }\n    });\n  };\n\n  /**\n   * Add multiple keyboard shortcuts to this context.\n   *\n   * @memberof ShortcutContext#\n   * @param {Array<object>} shortcuts List of shortcuts to add to this shortcut context\n   * @param {object} [options] A shortcut's options\n   * @param {Function} [options.callback] A shortcut's action\n   * @param {object} [options.group] A group of shortcuts to which a shortcut belongs\n   * @param {object} [options.runOnlyIf] A condition on which a shortcut's action runs\n   * @param {object} [options.stopPropagation=false] If set to `true`: stops the event's propagation\n   * @param {object} [options.preventDefault=true] If set to `true`: prevents the default behavior\n   * @param {object} [options.position='after'] The order in which a shortcut's action runs:\n   * `'before'` or `'after'` a `relativeToGroup` group of actions\n   * @param {object} [options.relativeToGroup] The name of a group of actions, used to determine an action's `position`\n   * @param {object} [options.forwardToContext] The context object where the event will be forwarded to.\n   */\n  const addShortcuts = function (shortcuts) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    shortcuts.forEach(shortcut => {\n      objectEach(options, (value, key) => {\n        if (Object.prototype.hasOwnProperty.call(shortcut, key) === false) {\n          shortcut[key] = options[key];\n        }\n      });\n      addShortcut(shortcut);\n    });\n  };\n\n  /**\n   * Remove a shortcut from this context.\n   *\n   * @memberof ShortcutContext#\n   * @param {Array<string>} keys Names of the shortcut's keys,\n   * (coming from [`KeyboardEvent.key`](https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent/key/Key_Values)),\n   * in lowercase or uppercase, unified across browsers\n   */\n  const removeShortcutsByKeys = keys => {\n    const normalizedKeys = normalizeKeys(keys);\n    SHORTCUTS.removeItem(normalizedKeys);\n  };\n\n  /**\n   * Remove a group of shortcuts from this context.\n   *\n   * @memberof ShortcutContext#\n   * @param {string} group The name of the group of shortcuts\n   */\n  const removeShortcutsByGroup = group => {\n    const shortcuts = SHORTCUTS.getItems();\n    shortcuts.forEach(_ref => {\n      let [normalizedKeys, shortcutOptions] = _ref;\n      const leftOptions = shortcutOptions.filter(option => option.group !== group);\n      if (leftOptions.length === 0) {\n        removeShortcutsByKeys(getKeysList(normalizedKeys));\n      } else {\n        shortcutOptions.length = 0;\n        shortcutOptions.push(...leftOptions);\n      }\n    });\n  };\n\n  /**\n   * Get a shortcut's details.\n   *\n   * @memberof ShortcutContext#\n   * @param {Array<string>} keys Names of the shortcut's keys,\n   * (coming from [`KeyboardEvent.key`](https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent/key/Key_Values)),\n   * in lowercase or uppercase, unified across browsers\n   * @returns {Array}\n   */\n  const getShortcuts = keys => {\n    const normalizedKeys = normalizeKeys(keys);\n    const shortcuts = SHORTCUTS.getItem(normalizedKeys);\n    return isDefined(shortcuts) ? shortcuts.slice() : [];\n  };\n\n  /**\n   * Check if a shortcut exists in this context.\n   *\n   * @memberof ShortcutContext#\n   * @param {Array<string>} keys Names of the shortcut's keys,\n   * (coming from [`KeyboardEvent.key`](https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent/key/Key_Values)),\n   * in lowercase or uppercase, unified across browsers\n   * @returns {boolean}\n   */\n  const hasShortcut = keys => {\n    const normalizedKeys = normalizeKeys(keys);\n    return SHORTCUTS.hasItem(normalizedKeys);\n  };\n  return {\n    __kindOf,\n    addShortcut,\n    addShortcuts,\n    getShortcuts,\n    hasShortcut,\n    removeShortcutsByKeys,\n    removeShortcutsByGroup\n  };\n};","import \"core-js/modules/es.error.cause.js\";\nimport { createUniqueMap } from \"../utils/dataStructures/uniqueMap.mjs\";\nimport { stopImmediatePropagation } from \"../helpers/dom/event.mjs\";\nimport { createContext, isContextObject } from \"./context.mjs\";\nimport { useRecorder } from \"./recorder.mjs\";\nimport { toSingleLine } from \"../helpers/templateLiteralTag.mjs\";\n/* eslint-disable jsdoc/require-description-complete-sentence */\n/**\n * The `ShortcutManager` API lets you store and manage [keyboard shortcut contexts](@/guides/navigation/keyboard-shortcuts/keyboard-shortcuts.md#keyboard-shortcut-contexts) ([`ShortcutContext`](@/api/shortcutContext.md)).\n *\n * Each `ShortcutManager` object:\n * - Stores and manages its own set of keyboard shortcut contexts.\n * - Listens to the [`KeyboardEvent`](https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent) events and runs actions for them.\n *\n * @alias ShortcutManager\n * @class ShortcutManager\n * @param {object} options The manager's options\n * @param {EventTarget} options.ownerWindow A starting `window` element\n * @param {Function} options.handleEvent A condition on which `event` is handled.\n * @param {Function} options.beforeKeyDown A hook fired before the `keydown` event is handled. You can use it to [block a keyboard shortcut's actions](@/guides/navigation/keyboard-shortcuts/keyboard-shortcuts.md#block-a-keyboard-shortcut-s-actions).\n * @param {Function} options.afterKeyDown A hook fired after the `keydown` event is handled\n */\nexport const createShortcutManager = _ref => {\n  let {\n    ownerWindow,\n    handleEvent,\n    beforeKeyDown,\n    afterKeyDown\n  } = _ref;\n  /**\n   * A unique map that stores keyboard shortcut contexts.\n   *\n   * @type {UniqueMap}\n   */\n  const CONTEXTS = createUniqueMap({\n    errorIdExists: keys => `The \"${keys}\" context name is already registered.`\n  });\n  /**\n   * The name of the active [`ShortcutContext`](@/api/shortcutContext.md).\n   *\n   * @type {string}\n   */\n  let activeContextName = 'grid';\n\n  /**\n   * Create a new [`ShortcutContext`](@/api/shortcutContext.md) object.\n   *\n   * @memberof ShortcutManager#\n   * @param {string} contextName The name of the new shortcut context\n   * @returns {object}\n   */\n  const addContext = contextName => {\n    const context = createContext(contextName);\n    CONTEXTS.addItem(contextName, context);\n    return context;\n  };\n\n  /**\n   * Get the ID of the active [`ShortcutContext`](@/api/shortcutContext.md).\n   *\n   * @memberof ShortcutManager#\n   * @returns {string}\n   */\n  const getActiveContextName = () => {\n    return activeContextName;\n  };\n\n  /**\n   * Get a keyboard shortcut context by its name.\n   *\n   * @memberof ShortcutManager#\n   * @param {string} contextName The name of the shortcut context\n   * @returns {object|undefined} A [`ShortcutContext`](@/api/shortcutContext.md) object that stores registered shortcuts\n   */\n  const getContext = contextName => {\n    return CONTEXTS.getItem(contextName);\n  };\n\n  /**\n   * Start listening to keyboard shortcuts within a given [`ShortcutContext`](@/api/shortcutContext.md).\n   *\n   * @memberof ShortcutManager#\n   * @param {string} contextName The name of the shortcut context\n   */\n  const setActiveContextName = contextName => {\n    if (!CONTEXTS.hasItem(contextName)) {\n      throw new Error(toSingleLine`You've tried to activate the \"${contextName}\" shortcut context\\x20\n        that does not exist. Before activation, register the context using the \"addContext\" method.`);\n    }\n    activeContextName = contextName;\n  };\n\n  /**\n   * This variable relates to the `captureCtrl` shortcut option,\n   * which allows for capturing the state of the Control/Meta modifier key.\n   * Some of the default keyboard shortcuts related to cell selection need this feature for working properly.\n   *\n   * @type {boolean}\n   */\n  let isCtrlKeySilenced = false;\n\n  /**\n   * A callback function for listening events from the recorder.\n   *\n   * @param {KeyboardEvent} event The keyboard event.\n   * @param {string[]} keys Names of the shortcut's keys,\n   * (coming from [`KeyboardEvent.key`](https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent/key/Key_Values)),\n   * in lowercase or uppercase, unified across browsers.\n   * @param {object | string} context The context object or name.\n   * @returns {boolean}\n   */\n  const recorderCallback = function (event, keys) {\n    let context = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : getActiveContextName();\n    const activeContext = isContextObject(context) ? context : getContext(context);\n    let isExecutionCancelled = false;\n    if (!activeContext.hasShortcut(keys)) {\n      return isExecutionCancelled;\n    }\n\n    // Processing just actions being in stack at the moment of shortcut pressing (without respecting additions/removals performed dynamically).\n    const shortcuts = activeContext.getShortcuts(keys);\n    for (let index = 0; index < shortcuts.length; index++) {\n      const {\n        callback,\n        runOnlyIf,\n        preventDefault,\n        stopPropagation,\n        captureCtrl,\n        forwardToContext\n      } = shortcuts[index];\n      if (runOnlyIf(event) === true) {\n        isCtrlKeySilenced = captureCtrl;\n        isExecutionCancelled = callback(event, keys) === false;\n        isCtrlKeySilenced = false;\n        if (preventDefault) {\n          event.preventDefault();\n        }\n        if (stopPropagation) {\n          stopImmediatePropagation(event);\n          event.stopPropagation();\n        }\n        if (isExecutionCancelled) {\n          break;\n        }\n        if (forwardToContext) {\n          recorderCallback(event, keys, forwardToContext);\n        }\n      }\n    }\n    return isExecutionCancelled;\n  };\n\n  /**\n   * Internal key recorder.\n   *\n   * @private\n   */\n  const keyRecorder = useRecorder(ownerWindow, handleEvent, beforeKeyDown, afterKeyDown, recorderCallback);\n  keyRecorder.mount();\n  return {\n    addContext,\n    getActiveContextName,\n    getContext,\n    setActiveContextName,\n    /**\n     * Returns whether `control` or `meta` keys are pressed.\n     *\n     * @memberof ShortcutManager#\n     * @type {Function}\n     * @returns {boolean}\n     */\n    isCtrlPressed: () => !isCtrlKeySilenced && (keyRecorder.isPressed('control') || keyRecorder.isPressed('meta')),\n    /**\n     * Release every previously pressed key.\n     *\n     * @type {Function}\n     * @memberof ShortcutManager#\n     */\n    releasePressedKeys: () => keyRecorder.releasePressedKeys(),\n    /**\n     * Destroy a context manager instance.\n     *\n     * @type {Function}\n     * @memberof ShortcutManager#\n     */\n    destroy: () => keyRecorder.unmount()\n  };\n};","import moment from 'moment';\nimport { toSingleLine } from \"./templateLiteralTag.mjs\";\n/**\n * Converts any value to string.\n *\n * @param {*} value The value to stringify.\n * @returns {string}\n */\nexport function stringify(value) {\n  let result;\n  switch (typeof value) {\n    case 'string':\n    case 'number':\n      result = `${value}`;\n      break;\n    case 'object':\n      result = value === null ? '' : value.toString();\n      break;\n    case 'undefined':\n      result = '';\n      break;\n    default:\n      result = value.toString();\n      break;\n  }\n  return result;\n}\n\n/**\n * Checks if given variable is defined.\n *\n * @param {*} variable Variable to check.\n * @returns {boolean}\n */\nexport function isDefined(variable) {\n  return typeof variable !== 'undefined';\n}\n\n/**\n * Checks if given variable is undefined.\n *\n * @param {*} variable Variable to check.\n * @returns {boolean}\n */\nexport function isUndefined(variable) {\n  return typeof variable === 'undefined';\n}\n\n/**\n * Check if given variable is null, empty string or undefined.\n *\n * @param {*} variable Variable to check.\n * @returns {boolean}\n */\nexport function isEmpty(variable) {\n  return variable === null || variable === '' || isUndefined(variable);\n}\n\n/**\n * Check if given variable is a regular expression.\n *\n * @param {*} variable Variable to check.\n * @returns {boolean}\n */\nexport function isRegExp(variable) {\n  return Object.prototype.toString.call(variable) === '[object RegExp]';\n}\n\n/* eslint-disable */\nconst _m = '\\x6C\\x65\\x6E\\x67\\x74\\x68';\nconst _hd = v => parseInt(v, 16);\nconst _pi = v => parseInt(v, 10);\nconst _ss = (v, s, l) => v['\\x73\\x75\\x62\\x73\\x74\\x72'](s, l);\nconst _cp = v => v['\\x63\\x6F\\x64\\x65\\x50\\x6F\\x69\\x6E\\x74\\x41\\x74'](0) - 65;\nconst _norm = v => `${v}`.replace(/\\-/g, '');\nconst _extractTime = v => _hd(_ss(_norm(v), _hd('12'), _cp('\\x46'))) / (_hd(_ss(_norm(v), _cp('\\x42'), ~~![][_m])) || 9);\nconst _ignored = () => typeof location !== 'undefined' && /^([a-z0-9\\-]+\\.)?\\x68\\x61\\x6E\\x64\\x73\\x6F\\x6E\\x74\\x61\\x62\\x6C\\x65\\x2E\\x63\\x6F\\x6D$/i.test(location.host);\nlet _notified = false;\nconst consoleMessages = {\n  invalid: () => toSingleLine`\n    The license key for Handsontable is invalid.\\x20\n    If you need any help, contact us at support@handsontable.com.`,\n  expired: _ref => {\n    let {\n      keyValidityDate,\n      hotVersion\n    } = _ref;\n    return toSingleLine`\n    The license key for Handsontable expired on ${keyValidityDate}, and is not valid for the installed\\x20\n    version ${hotVersion}. Renew your license key at handsontable.com or downgrade to a version released prior\\x20\n    to ${keyValidityDate}. If you need any help, contact us at sales@handsontable.com.`;\n  },\n  missing: () => toSingleLine`\n    The license key for Handsontable is missing. Use your purchased key to activate the product.\\x20\n    Alternatively, you can activate Handsontable to use for non-commercial purposes by\\x20\n    passing the key: 'non-commercial-and-evaluation'. If you need any help, contact\\x20\n    us at support@handsontable.com.`,\n  non_commercial: () => ''\n};\nconst domMessages = {\n  invalid: () => toSingleLine`\n    The license key for Handsontable is invalid.\\x20\n    <a href=\"https://handsontable.com/docs/tutorial-license-key.html\" target=\"_blank\">Read more</a> on how to\\x20\n    install it properly or contact us at <a href=\"mailto:support@handsontable.com\">support@handsontable.com</a>.`,\n  expired: _ref2 => {\n    let {\n      keyValidityDate,\n      hotVersion\n    } = _ref2;\n    return toSingleLine`\n    The license key for Handsontable expired on ${keyValidityDate}, and is not valid for the installed\\x20\n    version ${hotVersion}. <a href=\"https://handsontable.com/pricing\" target=\"_blank\">Renew</a> your\\x20\n    license key or downgrade to a version released prior to ${keyValidityDate}. If you need any\\x20\n    help, contact us at <a href=\"mailto:sales@handsontable.com\">sales@handsontable.com</a>.`;\n  },\n  missing: () => toSingleLine`\n    The license key for Handsontable is missing. Use your purchased key to activate the product.\\x20\n    Alternatively, you can activate Handsontable to use for non-commercial purposes by\\x20\n    passing the key: 'non-commercial-and-evaluation'.\\x20\n    <a href=\"https://handsontable.com/docs/tutorial-license-key.html\" target=\"_blank\">Read more</a> about it in\\x20\n    the documentation or contact us at <a href=\"mailto:support@handsontable.com\">support@handsontable.com</a>.`,\n  non_commercial: () => ''\n};\nexport function _injectProductInfo(key, element) {\n  const hasValidType = !isEmpty(key);\n  const isNonCommercial = typeof key === 'string' && key.toLowerCase() === 'non-commercial-and-evaluation';\n  const hotVersion = \"14.6.0\";\n  let keyValidityDate;\n  let consoleMessageState = 'invalid';\n  let domMessageState = 'invalid';\n  key = _norm(key || '');\n  const schemaValidity = _checkKeySchema(key);\n  if (hasValidType || isNonCommercial || schemaValidity) {\n    if (schemaValidity) {\n      const releaseDate = moment(\"01/10/2024\", 'DD/MM/YYYY');\n      const releaseDays = Math.floor(releaseDate.toDate().getTime() / 8.64e7);\n      const keyValidityDays = _extractTime(key);\n      keyValidityDate = moment((keyValidityDays + 1) * 8.64e7, 'x').format('MMMM DD, YYYY');\n      if (releaseDays > keyValidityDays) {\n        consoleMessageState = 'expired';\n        domMessageState = 'expired';\n      } else {\n        consoleMessageState = 'valid';\n        domMessageState = 'valid';\n      }\n    } else if (isNonCommercial) {\n      consoleMessageState = 'non_commercial';\n      domMessageState = 'valid';\n    } else {\n      consoleMessageState = 'invalid';\n      domMessageState = 'invalid';\n    }\n  } else {\n    consoleMessageState = 'missing';\n    domMessageState = 'missing';\n  }\n  if (_ignored()) {\n    consoleMessageState = 'valid';\n    domMessageState = 'valid';\n  }\n  if (!_notified && consoleMessageState !== 'valid') {\n    const message = consoleMessages[consoleMessageState]({\n      keyValidityDate,\n      hotVersion\n    });\n    if (message) {\n      console[consoleMessageState === 'non_commercial' ? 'info' : 'warn'](consoleMessages[consoleMessageState]({\n        keyValidityDate,\n        hotVersion\n      }));\n    }\n    _notified = true;\n  }\n  if (domMessageState !== 'valid' && element.parentNode) {\n    const message = domMessages[domMessageState]({\n      keyValidityDate,\n      hotVersion\n    });\n    if (message) {\n      const messageNode = document.createElement('div');\n      messageNode.className = 'hot-display-license-info';\n      messageNode.innerHTML = domMessages[domMessageState]({\n        keyValidityDate,\n        hotVersion\n      });\n      element.parentNode.insertBefore(messageNode, element.nextSibling);\n    }\n  }\n}\nfunction _checkKeySchema(v) {\n  let z = [][_m];\n  let p = z;\n  if (v[_m] !== _cp('\\x5A')) {\n    return false;\n  }\n  for (let c = '', i = '\\x42\\x3C\\x48\\x34\\x50\\x2B'.split(''), j = _cp(i.shift()); j; j = _cp(i.shift() || 'A')) {\n    --j < ''[_m] ? p = p | (_pi(`${_pi(_hd(c) + (_hd(_ss(v, Math.abs(j), 2)) + []).padStart(2, '0'))}`) % 97 || 2) >> 1 : c = _ss(v, j, !j ? 6 : i[_m] === 1 ? 9 : 8);\n  }\n  return p === z;\n}\n/* eslint-enable */","import \"core-js/modules/es.error.cause.js\";\nimport \"core-js/modules/es.array.push.js\";\nimport \"core-js/modules/es.array.unscopables.flat-map.js\";\nfunction _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == typeof i ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != typeof t || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != typeof i) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\nimport { arrayEach } from \"./helpers/array.mjs\";\nimport { objectEach } from \"./helpers/object.mjs\";\nimport { substitute } from \"./helpers/string.mjs\";\nimport { warn } from \"./helpers/console.mjs\";\nimport { toSingleLine } from \"./helpers/templateLiteralTag.mjs\";\nimport { fastCall } from \"./helpers/function.mjs\";\n/* eslint-disable jsdoc/require-description-complete-sentence */\n/**\n * @description\n *\n * ::: only-for javascript\n * Handsontable events are the common interface that function in 2 ways: as __callbacks__ and as __hooks__.\n * :::\n *\n * ::: only-for react\n * This page lists all the **Handsontable hooks** – callbacks that let you react before or after an action occurs.\n *\n * Read more on the [Events and hooks](@/guides/getting-started/events-and-hooks/events-and-hooks.md) page.\n * :::\n *\n * @example\n *\n * ::: only-for javascript\n * ```js\n * // using events as callbacks\n * ...\n * const hot1 = new Handsontable(document.getElementById('example1'), {\n *   afterChange: function(changes, source) {\n *     $.ajax({\n *       url: \"save.php',\n *       data: change\n *     });\n *   }\n * });\n * ...\n * ```\n * :::\n *\n * ::: only-for react\n * ```jsx\n * <HotTable\n *   afterChange={(changes, source) => {\n *     fetch('save.php', {\n *       method: 'POST',\n *       headers: {\n *         'Accept': 'application/json',\n *         'Content-Type': 'application/json'\n *       },\n *       body: JSON.stringify(changes)\n *     });\n *   }}\n * />\n * :::\n *\n * ::: only-for javascript\n * ```js\n * // using events as plugin hooks\n * ...\n * const hot1 = new Handsontable(document.getElementById('example1'), {\n *   myPlugin: true\n * });\n *\n * const hot2 = new Handsontable(document.getElementById('example2'), {\n *   myPlugin: false\n * });\n *\n * // global hook\n * Handsontable.hooks.add('afterChange', function() {\n *   // Fired twice - for hot1 and hot2\n *   if (this.getSettings().myPlugin) {\n *     // function body - will only run for hot1\n *   }\n * });\n *\n * // local hook (has same effect as a callback)\n * hot2.addHook('afterChange', function() {\n *   // function body - will only run in #example2\n * });\n * ```\n * :::\n *\n * ::: only-for react\n * ```jsx\n * const hotRef1 = useRef(null);\n * const hotRef2 = useRef(null);\n *\n * // Using events as plugin hooks:\n * ...\n *\n * <HotTable\n *   ref={hotRef1}\n *   myPlugin={true}\n * });\n *\n * <HotTable\n *   ref={hotRef2}\n *   myPlugin={false}\n * });\n *\n * ...\n *\n * const hot2 = hotRef2.current.hotInstance;\n * // local hook (has same effect as a callback)\n * hot2.addHook('afterChange', function() {\n *   // function body - will only run in #example2\n * });\n *\n * // global hook\n * Handsontable.hooks.add('afterChange', function() {\n *   // Fired twice - for hot1 and hot2\n *   if (this.getSettings().myPlugin) {\n *     // function body - will only run for first instance\n *   }\n * });\n * :::\n * ...\n */\n// @TODO: Move plugin description hooks to plugin?\nconst REGISTERED_HOOKS = [/* eslint-disable jsdoc/require-description-complete-sentence */\n/**\n * Fired after resetting a cell's meta. This happens when the {@link Core#updateSettings} method is called.\n *\n * @event Hooks#afterCellMetaReset\n */\n'afterCellMetaReset',\n/**\n * Fired after one or more cells has been changed. The changes are triggered in any situation when the\n * value is entered using an editor or changed using API (e.q [`setDataAtCell`](@/api/core.md#setdataatcell) method).\n *\n * __Note:__ For performance reasons, the `changes` array is null for `\"loadData\"` source.\n *\n * @event Hooks#afterChange\n * @param {Array[]} changes 2D array containing information about each of the edited cells `[[row, prop, oldVal, newVal], ...]`. `row` is a visual row index.\n * @param {string} [source] String that identifies source of hook call ([list of all available sources](@/guides/getting-started/events-and-hooks/events-and-hooks.md#definition-for-source-argument)).\n * @example\n * ::: only-for javascript\n * ```js\n * new Handsontable(element, {\n *   afterChange: (changes) => {\n *     changes?.forEach(([row, prop, oldValue, newValue]) => {\n *       // Some logic...\n *     });\n *   }\n * })\n * ```\n * :::\n *\n * ::: only-for react\n * ```jsx\n * <HotTable\n *   afterChange={(changes, source) => {\n *     changes?.forEach(([row, prop, oldValue, newValue]) => {\n *       // Some logic...\n *     });\n *   }}\n * />\n * ```\n * :::\n */\n'afterChange',\n/**\n * Fired each time user opens {@link ContextMenu} and after setting up the Context Menu's default options. These options are a collection\n * which user can select by setting an array of keys or an array of objects in {@link Options#contextMenu} option.\n *\n * @event Hooks#afterContextMenuDefaultOptions\n * @param {Array} predefinedItems An array of objects containing information about the pre-defined Context Menu items.\n */\n'afterContextMenuDefaultOptions',\n/**\n * Fired each time user opens {@link ContextMenu} plugin before setting up the Context Menu's items but after filtering these options by\n * user ([`contextMenu`](@/api/options.md#contextmenu) option). This hook can by helpful to determine if user use specified menu item or to set up\n * one of the menu item to by always visible.\n *\n * @event Hooks#beforeContextMenuSetItems\n * @param {object[]} menuItems An array of objects containing information about to generated Context Menu items.\n */\n'beforeContextMenuSetItems',\n/**\n * Fired by {@link DropdownMenu} plugin after setting up the Dropdown Menu's default options. These options are a\n * collection which user can select by setting an array of keys or an array of objects in {@link Options#dropdownMenu}\n * option.\n *\n * @event Hooks#afterDropdownMenuDefaultOptions\n * @param {object[]} predefinedItems An array of objects containing information about the pre-defined Context Menu items.\n */\n'afterDropdownMenuDefaultOptions',\n/**\n * Fired by {@link DropdownMenu} plugin before setting up the Dropdown Menu's items but after filtering these options\n * by user ([`dropdownMenu`](@/api/options.md#dropdownmenu) option). This hook can by helpful to determine if user use specified menu item or to set\n * up one of the menu item to by always visible.\n *\n * @event Hooks#beforeDropdownMenuSetItems\n * @param {object[]} menuItems An array of objects containing information about to generated Dropdown Menu items.\n */\n'beforeDropdownMenuSetItems',\n/**\n * Fired by {@link ContextMenu} plugin after hiding the Context Menu. This hook is fired when {@link Options#contextMenu}\n * option is enabled.\n *\n * @event Hooks#afterContextMenuHide\n * @param {object} context The Context Menu plugin instance.\n */\n'afterContextMenuHide',\n/**\n * Fired by {@link ContextMenu} plugin before opening the Context Menu. This hook is fired when {@link Options#contextMenu}\n * option is enabled.\n *\n * @event Hooks#beforeContextMenuShow\n * @param {object} context The Context Menu instance.\n */\n'beforeContextMenuShow',\n/**\n * Fired by {@link ContextMenu} plugin after opening the Context Menu. This hook is fired when {@link Options#contextMenu}\n * option is enabled.\n *\n * @event Hooks#afterContextMenuShow\n * @param {object} context The Context Menu plugin instance.\n */\n'afterContextMenuShow',\n/**\n * Fired by {@link CopyPaste} plugin after reaching the copy limit while copying data. This hook is fired when\n * {@link Options#copyPaste} option is enabled.\n *\n * @event Hooks#afterCopyLimit\n * @param {number} selectedRows Count of selected copyable rows.\n * @param {number} selectedColumns Count of selected copyable columns.\n * @param {number} copyRowsLimit Current copy rows limit.\n * @param {number} copyColumnsLimit Current copy columns limit.\n */\n'afterCopyLimit',\n/**\n * Fired before created a new column.\n *\n * @event Hooks#beforeCreateCol\n * @param {number} index Represents the visual index of first newly created column in the data source array.\n * @param {number} amount Number of newly created columns in the data source array.\n * @param {string} [source] String that identifies source of hook call\n *                          ([list of all available sources](@/guides/getting-started/events-and-hooks/events-and-hooks.md#definition-for-source-argument)).\n * @returns {*} If `false` then creating columns is cancelled.\n * @example\n * ::: only-for javascript\n * ```js\n * // Return `false` to cancel column inserting.\n * new Handsontable(element, {\n *   beforeCreateCol: function(data, coords) {\n *     return false;\n *   }\n * });\n * ```\n * :::\n *\n * ::: only-for react\n * ```jsx\n * // Return `false` to cancel column inserting.\n * <HotTable\n *   beforeCreateCol={(data, coords) => {\n *     return false;\n *   }}\n * />\n * ```\n * :::\n */\n'beforeCreateCol',\n/**\n * Fired after the order of columns has changed.\n * This hook is fired by changing column indexes of any type supported by the {@link IndexMapper}.\n *\n * @event Hooks#afterColumnSequenceChange\n * @param {'init'|'remove'|'insert'|'move'|'update'} [source] A string that indicates what caused the change to the order of columns.\n */\n'afterColumnSequenceChange',\n/**\n * Fired after created a new column.\n *\n * @event Hooks#afterCreateCol\n * @param {number} index Represents the visual index of first newly created column in the data source.\n * @param {number} amount Number of newly created columns in the data source.\n * @param {string} [source] String that identifies source of hook call\n *                          ([list of all available sources](@/guides/getting-started/events-and-hooks/events-and-hooks.md#definition-for-source-argument)).\n */\n'afterCreateCol',\n/**\n * Fired before created a new row.\n *\n * @event Hooks#beforeCreateRow\n * @param {number} index Represents the visual index of first newly created row in the data source array.\n * @param {number} amount Number of newly created rows in the data source array.\n * @param {string} [source] String that identifies source of hook call\n *                          ([list of all available sources](@/guides/getting-started/events-and-hooks/events-and-hooks.md#definition-for-source-argument)).\n * @returns {*|boolean} If false is returned the action is canceled.\n */\n'beforeCreateRow',\n/**\n * Fired after created a new row.\n *\n * @event Hooks#afterCreateRow\n * @param {number} index Represents the visual index of first newly created row in the data source array.\n * @param {number} amount Number of newly created rows in the data source array.\n * @param {string} [source] String that identifies source of hook call\n *                          ([list of all available sources](@/guides/getting-started/events-and-hooks/events-and-hooks.md#definition-for-source-argument)).\n */\n'afterCreateRow',\n/**\n * Fired after all selected cells are deselected.\n *\n * @event Hooks#afterDeselect\n */\n'afterDeselect',\n/**\n * Fired after destroying the Handsontable instance.\n *\n * @event Hooks#afterDestroy\n */\n'afterDestroy',\n/**\n * Hook fired after `keydown` event is handled.\n *\n * @event Hooks#afterDocumentKeyDown\n * @param {Event} event A native `keydown` event object.\n */\n'afterDocumentKeyDown',\n/**\n * Fired inside the Walkontable's selection `draw` method. Can be used to add additional class names to cells, depending on the current selection.\n *\n * @event Hooks#afterDrawSelection\n * @param {number} currentRow Row index of the currently processed cell.\n * @param {number} currentColumn Column index of the currently cell.\n * @param {number[]} cornersOfSelection Array of the current selection in a form of `[startRow, startColumn, endRow, endColumn]`.\n * @param {number|undefined} layerLevel Number indicating which layer of selection is currently processed.\n * @since 0.38.1\n * @returns {string|undefined} Can return a `String`, which will act as an additional `className` to be added to the currently processed cell.\n */\n'afterDrawSelection',\n/**\n * Fired inside the Walkontable's `refreshSelections` method. Can be used to remove additional class names from all cells in the table.\n *\n * @event Hooks#beforeRemoveCellClassNames\n * @since 0.38.1\n * @returns {string[]|undefined} Can return an `Array` of `String`s. Each of these strings will act like class names to be removed from all the cells in the table.\n */\n'beforeRemoveCellClassNames',\n/**\n * Fired after getting the cell settings.\n *\n * @event Hooks#afterGetCellMeta\n * @param {number} row Visual row index.\n * @param {number} column Visual column index.\n * @param {object} cellProperties Object containing the cell properties.\n */\n'afterGetCellMeta',\n/**\n * Fired after retrieving information about a column header and appending it to the table header.\n *\n * @event Hooks#afterGetColHeader\n * @param {number} column Visual column index.\n * @param {HTMLTableCellElement} TH Header's TH element.\n * @param {number} [headerLevel=0] (Since 12.2.0) Header level index. Accepts positive (0 to n)\n *                                 and negative (-1 to -n) values. For positive values, 0 points to the\n *                                 topmost header. For negative values, -1 points to the bottom-most\n *                                 header (the header closest to the cells).\n */\n'afterGetColHeader',\n/**\n * Fired after retrieving information about a row header and appending it to the table header.\n *\n * @event Hooks#afterGetRowHeader\n * @param {number} row Visual row index.\n * @param {HTMLTableCellElement} TH Header's TH element.\n */\n'afterGetRowHeader',\n/**\n * Fired after the Handsontable instance is initiated.\n *\n * @event Hooks#afterInit\n */\n'afterInit',\n/**\n * Fired after Handsontable's [`data`](@/api/options.md#data)\n * gets modified by the [`loadData()`](@/api/core.md#loaddata) method\n * or the [`updateSettings()`](@/api/core.md#updatesettings) method.\n *\n * Read more:\n * - [Binding to data](@/guides/getting-started/binding-to-data/binding-to-data.md)\n * - [Saving data](@/guides/getting-started/saving-data/saving-data.md)\n *\n * @event Hooks#afterLoadData\n * @param {Array} sourceData An [array of arrays](@/guides/getting-started/binding-to-data/binding-to-data.md#array-of-arrays), or an [array of objects](@/guides/getting-started/binding-to-data/binding-to-data.md#array-of-objects), that contains Handsontable's data\n * @param {boolean} initialLoad A flag that indicates whether the data was loaded at Handsontable's initialization (`true`) or later (`false`)\n * @param {string} source The source of the call\n */\n'afterLoadData',\n/**\n * Fired after the [`updateData()`](@/api/core.md#updatedata) method\n * modifies Handsontable's [`data`](@/api/options.md#data).\n *\n * Read more:\n * - [Binding to data](@/guides/getting-started/binding-to-data/binding-to-data.md)\n * - [Saving data](@/guides/getting-started/saving-data/saving-data.md)\n *\n * @event Hooks#afterUpdateData\n * @since 11.1.0\n * @param {Array} sourceData An [array of arrays](@/guides/getting-started/binding-to-data/binding-to-data.md#array-of-arrays), or an [array of objects](@/guides/getting-started/binding-to-data/binding-to-data.md#array-of-objects), that contains Handsontable's data\n * @param {boolean} initialLoad A flag that indicates whether the data was loaded at Handsontable's initialization (`true`) or later (`false`)\n * @param {string} source The source of the call\n */\n'afterUpdateData',\n/**\n * Fired after a scroll event, which is identified as a momentum scroll (e.g. on an iPad).\n *\n * @event Hooks#afterMomentumScroll\n */\n'afterMomentumScroll',\n/**\n * Fired after a `mousedown` event is triggered on the cell corner (the drag handle).\n *\n * @event Hooks#afterOnCellCornerMouseDown\n * @param {Event} event `mousedown` event object.\n */\n'afterOnCellCornerMouseDown',\n/**\n * Fired after a `dblclick` event is triggered on the cell corner (the drag handle).\n *\n * @event Hooks#afterOnCellCornerDblClick\n * @param {Event} event `dblclick` event object.\n */\n'afterOnCellCornerDblClick',\n/**\n * Fired after clicking on a cell or row/column header. In case the row/column header was clicked, the coordinate\n * indexes are negative.\n *\n * For example clicking on the row header of cell (0, 0) results with `afterOnCellMouseDown` called\n * with coordinates `{row: 0, col: -1}`.\n *\n * @event Hooks#afterOnCellMouseDown\n * @param {Event} event `mousedown` event object.\n * @param {CellCoords} coords Coordinates object containing the visual row and visual column indexes of the clicked cell.\n * @param {HTMLTableCellElement} TD Cell's TD (or TH) element.\n */\n'afterOnCellMouseDown',\n/**\n * Fired after clicking on a cell or row/column header. In case the row/column header was clicked, the coordinate\n * indexes are negative.\n *\n * For example clicking on the row header of cell (0, 0) results with `afterOnCellMouseUp` called\n * with coordinates `{row: 0, col: -1}`.\n *\n * @event Hooks#afterOnCellMouseUp\n * @param {Event} event `mouseup` event object.\n * @param {CellCoords} coords Coordinates object containing the visual row and visual column indexes of the clicked cell.\n * @param {HTMLTableCellElement} TD Cell's TD (or TH) element.\n */\n'afterOnCellMouseUp',\n/**\n * Fired after clicking right mouse button on a cell or row/column header.\n *\n * For example clicking on the row header of cell (0, 0) results with `afterOnCellContextMenu` called\n * with coordinates `{row: 0, col: -1}`.\n *\n * @event Hooks#afterOnCellContextMenu\n * @since 4.1.0\n * @param {Event} event `contextmenu` event object.\n * @param {CellCoords} coords Coordinates object containing the visual row and visual column indexes of the clicked cell.\n * @param {HTMLTableCellElement} TD Cell's TD (or TH) element.\n */\n'afterOnCellContextMenu',\n/**\n * Fired after hovering a cell or row/column header with the mouse cursor. In case the row/column header was\n * hovered, the index is negative.\n *\n * For example, hovering over the row header of cell (0, 0) results with `afterOnCellMouseOver` called\n * with coords `{row: 0, col: -1}`.\n *\n * @event Hooks#afterOnCellMouseOver\n * @param {Event} event `mouseover` event object.\n * @param {CellCoords} coords Hovered cell's visual coordinate object.\n * @param {HTMLTableCellElement} TD Cell's TD (or TH) element.\n */\n'afterOnCellMouseOver',\n/**\n * Fired after leaving a cell or row/column header with the mouse cursor.\n *\n * @event Hooks#afterOnCellMouseOut\n * @param {Event} event `mouseout` event object.\n * @param {CellCoords} coords Leaved cell's visual coordinate object.\n * @param {HTMLTableCellElement} TD Cell's TD (or TH) element.\n */\n'afterOnCellMouseOut',\n/**\n * Fired after one or more columns are removed.\n *\n * @event Hooks#afterRemoveCol\n * @param {number} index Visual index of starter column.\n * @param {number} amount An amount of removed columns.\n * @param {number[]} physicalColumns An array of physical columns removed from the data source.\n * @param {string} [source] String that identifies source of hook call\n *                          ([list of all available sources](@/guides/getting-started/events-and-hooks/events-and-hooks.md#definition-for-source-argument)).\n */\n'afterRemoveCol',\n/**\n * Fired after one or more rows are removed.\n *\n * @event Hooks#afterRemoveRow\n * @param {number} index Visual index of starter row.\n * @param {number} amount An amount of removed rows.\n * @param {number[]} physicalRows An array of physical rows removed from the data source.\n * @param {string} [source] String that identifies source of hook call\n *                          ([list of all available sources](@/guides/getting-started/events-and-hooks/events-and-hooks.md#definition-for-source-argument)).\n */\n'afterRemoveRow',\n/**\n * Fired before starting rendering the cell.\n *\n * @event Hooks#beforeRenderer\n * @param {HTMLTableCellElement} TD Currently rendered cell's TD element.\n * @param {number} row Visual row index.\n * @param {number} column Visual column index.\n * @param {string|number} prop Column property name or a column index, if datasource is an array of arrays.\n * @param {*} value Value of the rendered cell.\n * @param {object} cellProperties Object containing the cell's properties.\n */\n'beforeRenderer',\n/**\n * Fired after finishing rendering the cell (after the renderer finishes).\n *\n * @event Hooks#afterRenderer\n * @param {HTMLTableCellElement} TD Currently rendered cell's TD element.\n * @param {number} row Visual row index.\n * @param {number} column Visual column index.\n * @param {string|number} prop Column property name or a column index, if datasource is an array of arrays.\n * @param {*} value Value of the rendered cell.\n * @param {object} cellProperties Object containing the cell's properties.\n */\n'afterRenderer',\n/**\n * Fired after the order of rows has changed.\n * This hook is fired by changing row indexes of any type supported by the {@link IndexMapper}.\n *\n * @event Hooks#afterRowSequenceChange\n * @param {'init'|'remove'|'insert'|'move'|'update'} [source] A string that indicates what caused the change to the order of rows.\n */\n'afterRowSequenceChange',\n/**\n * Fired before the vertical viewport scroll. Triggered by the [`scrollViewportTo()`](@/api/core.md#scrollviewportto)\n * method or table internals.\n *\n * @since 14.0.0\n * @event Hooks#beforeViewportScrollVertically\n * @param {number} visualRow Visual row index.\n * @returns {number | boolean} Returns modified row index (or the same as passed in the method argument) to which\n * the viewport will be scrolled. If the returned value is `false`, the scrolling will be canceled.\n */\n'beforeViewportScrollVertically',\n/**\n * Fired before the horizontal viewport scroll. Triggered by the [`scrollViewportTo()`](@/api/core.md#scrollviewportto)\n * method or table internals.\n *\n * @since 14.0.0\n * @event Hooks#beforeViewportScrollHorizontally\n * @param {number} visualColumn Visual column index.\n * @returns {number | boolean} Returns modified column index (or the same as passed in the method argument) to which\n * the viewport will be scrolled. If the returned value is `false`, the scrolling will be canceled.\n */\n'beforeViewportScrollHorizontally',\n/**\n * Fired before the vertical or horizontal viewport scroll. Triggered by the [`scrollViewportTo()`](@/api/core.md#scrollviewportto)\n * method or table internals.\n *\n * @since 14.0.0\n * @event Hooks#beforeViewportScroll\n */\n'beforeViewportScroll',\n/**\n * Fired after the horizontal scroll event.\n *\n * @event Hooks#afterScrollHorizontally\n */\n'afterScrollHorizontally',\n/**\n * Fired after the vertical scroll event.\n *\n * @event Hooks#afterScrollVertically\n */\n'afterScrollVertically',\n/**\n * Fired after the vertical or horizontal scroll event.\n *\n * @since 14.0.0\n * @event Hooks#afterScroll\n */\n'afterScroll',\n/**\n * Fired after one or more cells are selected (e.g. during mouse move).\n *\n * @event Hooks#afterSelection\n * @param {number} row Selection start visual row index.\n * @param {number} column Selection start visual column index.\n * @param {number} row2 Selection end visual row index.\n * @param {number} column2 Selection end visual column index.\n * @param {object} preventScrolling A reference to the observable object with the `value` property.\n *                                  Property `preventScrolling.value` expects a boolean value that\n *                                  Handsontable uses to control scroll behavior after selection.\n * @param {number} selectionLayerLevel The number which indicates what selection layer is currently modified.\n * @example\n * ::: only-for javascript\n * ```js\n * new Handsontable(element, {\n *   afterSelection: (row, column, row2, column2, preventScrolling, selectionLayerLevel) => {\n *     // If set to `false` (default): when cell selection is outside the viewport,\n *     // Handsontable scrolls the viewport to cell selection's end corner.\n *     // If set to `true`: when cell selection is outside the viewport,\n *     // Handsontable doesn't scroll to cell selection's end corner.\n *     preventScrolling.value = true;\n *   }\n * })\n * ```\n * :::\n *\n * ::: only-for react\n * ```jsx\n * <HotTable\n *   afterSelection={(row, column, row2, column2, preventScrolling, selectionLayerLevel) => {\n *     // If set to `false` (default): when cell selection is outside the viewport,\n *     // Handsontable scrolls the viewport to cell selection's end corner.\n *     // If set to `true`: when cell selection is outside the viewport,\n *     // Handsontable doesn't scroll to cell selection's end corner.\n *     preventScrolling.value = true;\n *   }}\n * />\n * ```\n * :::\n */\n'afterSelection',\n/**\n * Fired after one or more cells are selected.\n *\n * The `prop` and `prop2` arguments represent the source object property name instead of the column number.\n *\n * @event Hooks#afterSelectionByProp\n * @param {number} row Selection start visual row index.\n * @param {string} prop Selection start data source object property name.\n * @param {number} row2 Selection end visual row index.\n * @param {string} prop2 Selection end data source object property name.\n * @param {object} preventScrolling A reference to the observable object with the `value` property.\n *                                  Property `preventScrolling.value` expects a boolean value that\n *                                  Handsontable uses to control scroll behavior after selection.\n * @param {number} selectionLayerLevel The number which indicates what selection layer is currently modified.\n * @example\n * ```js\n * ::: only-for javascript\n * new Handsontable(element, {\n *   afterSelectionByProp: (row, column, row2, column2, preventScrolling, selectionLayerLevel) => {\n *     // setting if prevent scrolling after selection\n *     preventScrolling.value = true;\n *   }\n * })\n * ```\n * :::\n *\n * ::: only-for react\n * ```jsx\n * <HotTable\n *   afterSelectionByProp={(row, column, row2, column2, preventScrolling, selectionLayerLevel) => {\n *     // setting if prevent scrolling after selection\n *     preventScrolling.value = true;\n *   }}\n * />\n * ```\n * :::\n */\n'afterSelectionByProp',\n/**\n * Fired after one or more cells are selected (e.g. on mouse up).\n *\n * @event Hooks#afterSelectionEnd\n * @param {number} row Selection start visual row index.\n * @param {number} column Selection start visual column index.\n * @param {number} row2 Selection end visual row index.\n * @param {number} column2 Selection end visual column index.\n * @param {number} selectionLayerLevel The number which indicates what selection layer is currently modified.\n */\n'afterSelectionEnd',\n/**\n * Fired after one or more cells are selected (e.g. on mouse up).\n *\n * The `prop` and `prop2` arguments represent the source object property name instead of the column number.\n *\n * @event Hooks#afterSelectionEndByProp\n * @param {number} row Selection start visual row index.\n * @param {string} prop Selection start data source object property index.\n * @param {number} row2 Selection end visual row index.\n * @param {string} prop2 Selection end data source object property index.\n * @param {number} selectionLayerLevel The number which indicates what selection layer is currently modified.\n */\n'afterSelectionEndByProp',\n/**\n * Fired after the focus position within a selected range is changed.\n *\n * @since 14.3.0\n * @event Hooks#afterSelectionFocusSet\n * @param {number} row The focus visual row index position.\n * @param {number} column The focus visual column index position.\n * @param {object} preventScrolling A reference to the observable object with the `value` property.\n *                                  Property `preventScrolling.value` expects a boolean value that\n *                                  Handsontable uses to control scroll behavior after selection.\n * @example\n * ```js\n * ::: only-for javascript\n * new Handsontable(element, {\n *   afterSelectionFocusSet: (row, column, preventScrolling) => {\n *     // If set to `false` (default): when focused cell selection is outside the viewport,\n *     // Handsontable scrolls the viewport to that cell.\n *     // If set to `true`: when focused cell selection is outside the viewport,\n *     // Handsontable doesn't scroll the viewport.\n *     preventScrolling.value = true;\n *   }\n * })\n * ```\n * :::\n *\n * ::: only-for react\n * ```jsx\n * <HotTable\n *   afterSelectionFocusSet={(row, column, preventScrolling) => {\n *     // If set to `false` (default): when focused cell selection is outside the viewport,\n *     // Handsontable scrolls the viewport to that cell.\n *     // If set to `true`: when focused cell selection is outside the viewport,\n *     // Handsontable doesn't scroll the viewport.\n *     preventScrolling.value = true;\n *   }}\n * />\n * ```\n * :::\n */\n'afterSelectionFocusSet',\n/**\n * Fired before one or more columns are selected (e.g. During mouse header click or {@link Core#selectColumns} API call).\n *\n * @since 14.0.0\n * @event Hooks#beforeSelectColumns\n * @param {CellCoords} from Selection start coords object.\n * @param {CellCoords} to Selection end coords object.\n * @param {CellCoords} highlight Selection cell focus coords object.\n * @example\n * ::: only-for javascript\n * ```js\n * new Handsontable(element, {\n *   beforeSelectColumns: (from, to, highlight) => {\n *     // Extend the column selection by one column left and one column right.\n *     from.col = Math.max(from.col - 1, 0);\n *     to.col = Math.min(to.col + 1, this.countCols() - 1);\n *   }\n * })\n * ```\n * :::\n *\n * ::: only-for react\n * ```jsx\n * <HotTable\n *   beforeSelectColumns={(from, to, highlight) => {\n *     // Extend the column selection by one column left and one column right.\n *     from.col = Math.max(from.col - 1, 0);\n *     to.col = Math.min(to.col + 1, this.countCols() - 1);\n *   }}\n * />\n * ```\n * :::\n */\n'beforeSelectColumns',\n/**\n * Fired after one or more columns are selected (e.g. during mouse header click or {@link Core#selectColumns} API call).\n *\n * @since 14.0.0\n * @event Hooks#afterSelectColumns\n * @param {CellCoords} from Selection start coords object.\n * @param {CellCoords} to Selection end coords object.\n * @param {CellCoords} highlight Selection cell focus coords object.\n */\n'afterSelectColumns',\n/**\n * Fired before one or more rows are selected (e.g. during mouse header click or {@link Core#selectRows} API call).\n *\n * @since 14.0.0\n * @event Hooks#beforeSelectRows\n * @param {CellCoords} from Selection start coords object.\n * @param {CellCoords} to Selection end coords object.\n * @param {CellCoords} highlight Selection cell focus coords object.\n * @example\n * ::: only-for javascript\n * ```js\n * new Handsontable(element, {\n *   beforeSelectRows: (from, to, highlight) => {\n *     // Extend the row selection by one row up and one row bottom more.\n *     from.row = Math.max(from.row - 1, 0);\n *     to.row = Math.min(to.row + 1, this.countRows() - 1);\n *   }\n * })\n * ```\n * :::\n *\n * ::: only-for react\n * ```jsx\n * <HotTable\n *   beforeSelectRows={(from, to, highlight) => {\n *     // Extend the row selection by one row up and one row bottom more.\n *     from.row = Math.max(from.row - 1, 0);\n *     to.row = Math.min(to.row + 1, this.countRows() - 1);\n *   }}\n * />\n * ```\n * :::\n */\n'beforeSelectRows',\n/**\n * Fired after one or more rows are selected (e.g. during mouse header click or {@link Core#selectRows} API call).\n *\n * @since 14.0.0\n * @event Hooks#afterSelectRows\n * @param {CellCoords} from Selection start coords object.\n * @param {CellCoords} to Selection end coords object.\n * @param {CellCoords} highlight Selection cell focus coords object.\n */\n'afterSelectRows',\n/**\n * Fired after cell meta is changed.\n *\n * @event Hooks#afterSetCellMeta\n * @param {number} row Visual row index.\n * @param {number} column Visual column index.\n * @param {string} key The updated meta key.\n * @param {*} value The updated meta value.\n */\n'afterSetCellMeta',\n/**\n * Fired after cell meta is removed.\n *\n * @event Hooks#afterRemoveCellMeta\n * @param {number} row Visual row index.\n * @param {number} column Visual column index.\n * @param {string} key The removed meta key.\n * @param {*} value Value which was under removed key of cell meta.\n */\n'afterRemoveCellMeta',\n/**\n * Fired after cell data was changed.\n *\n * @event Hooks#afterSetDataAtCell\n * @param {Array} changes An array of changes in format `[[row, column, oldValue, value], ...]`.\n * @param {string} [source] String that identifies source of hook call\n *                          ([list of all available sources](@/guides/getting-started/events-and-hooks/events-and-hooks.md#definition-for-source-argument)).\n */\n'afterSetDataAtCell',\n/**\n * Fired after cell data was changed.\n * Called only when [`setDataAtRowProp`](@/api/core.md#setdataatrowprop) was executed.\n *\n * @event Hooks#afterSetDataAtRowProp\n * @param {Array} changes An array of changes in format `[[row, prop, oldValue, value], ...]`.\n * @param {string} [source] String that identifies source of hook call\n *                          ([list of all available sources](@/guides/getting-started/events-and-hooks/events-and-hooks.md#definition-for-source-argument)).\n */\n'afterSetDataAtRowProp',\n/**\n * Fired after cell source data was changed.\n *\n * @event Hooks#afterSetSourceDataAtCell\n * @since 8.0.0\n * @param {Array} changes An array of changes in format `[[row, column, oldValue, value], ...]`.\n * @param {string} [source] String that identifies source of hook call.\n */\n'afterSetSourceDataAtCell',\n/**\n * Fired after calling the [`updateSettings`](@/api/core.md#updatesettings) method.\n *\n * @event Hooks#afterUpdateSettings\n * @param {object} newSettings New settings object.\n */\n'afterUpdateSettings',\n/**\n * @description\n * A plugin hook executed after validator function, only if validator function is defined.\n * Validation result is the first parameter. This can be used to determinate if validation passed successfully or not.\n *\n * __Returning false from the callback will mark the cell as invalid__.\n *\n * @event Hooks#afterValidate\n * @param {boolean} isValid `true` if valid, `false` if not.\n * @param {*} value The value in question.\n * @param {number} row Visual row index.\n * @param {string|number} prop Property name / visual column index.\n * @param {string} [source] String that identifies source of hook call\n *                          ([list of all available sources](@/guides/getting-started/events-and-hooks/events-and-hooks.md#definition-for-source-argument)).\n * @returns {undefined | boolean} If `false` the cell will be marked as invalid, `true` otherwise.\n */\n'afterValidate',\n/**\n * Fired before successful change of language (when proper language code was set).\n *\n * @event Hooks#beforeLanguageChange\n * @since 0.35.0\n * @param {string} languageCode New language code.\n */\n'beforeLanguageChange',\n/**\n * Fired after successful change of language (when proper language code was set).\n *\n * @event Hooks#afterLanguageChange\n * @since 0.35.0\n * @param {string} languageCode New language code.\n */\n'afterLanguageChange',\n/**\n * Fired by {@link Autofill} plugin before populating the data in the autofill feature. This hook is fired when\n * {@link Options#fillHandle} option is enabled.\n *\n * @event Hooks#beforeAutofill\n * @param {Array[]} selectionData Data the autofill operation will start from.\n * @param {CellRange} sourceRange The range values will be filled from.\n * @param {CellRange} targetRange The range new values will be filled into.\n * @param {string} direction Declares the direction of the autofill. Possible values: `up`, `down`, `left`, `right`.\n *\n * @returns {boolean|Array[]} If false, the operation is cancelled. If array of arrays, the returned data\n *                              will be passed into [`populateFromArray`](@/api/core.md#populatefromarray) instead of the default autofill\n *                              algorithm's result.\n */\n'beforeAutofill',\n/**\n * Fired by {@link Autofill} plugin after populating the data in the autofill feature. This hook is fired when\n * {@link Options#fillHandle} option is enabled.\n *\n * @event Hooks#afterAutofill\n * @since 8.0.0\n * @param {Array[]} fillData The data that was used to fill the `targetRange`. If `beforeAutofill` was used\n *                            and returned `[[]]`, this will be the same object that was returned from `beforeAutofill`.\n * @param {CellRange} sourceRange The range values will be filled from.\n * @param {CellRange} targetRange The range new values will be filled into.\n * @param {string} direction Declares the direction of the autofill. Possible values: `up`, `down`, `left`, `right`.\n */\n'afterAutofill',\n/**\n * Fired before aligning the cell contents.\n *\n * @event Hooks#beforeCellAlignment\n * @param {object} stateBefore An object with class names defining the cell alignment.\n * @param {CellRange[]} range An array of `CellRange` coordinates where the alignment will be applied.\n * @param {string} type Type of the alignment - either `horizontal` or `vertical`.\n * @param {string} alignmentClass String defining the alignment class added to the cell.\n * Possible values: `htLeft` , `htCenter`, `htRight`, `htJustify`, `htTop`, `htMiddle`, `htBottom`.\n */\n'beforeCellAlignment',\n/**\n * Fired before one or more cells are changed.\n *\n * Use this hook to silently alter the user's changes before Handsontable re-renders.\n *\n * To ignore the user's changes, use a nullified array or return `false`.\n *\n * @event Hooks#beforeChange\n * @param {Array[]} changes 2D array containing information about each of the edited cells `[[row, prop, oldVal, newVal], ...]`. `row` is a visual row index.\n * @param {string} [source] String that identifies source of hook call\n *                          ([list of all available sources](@/guides/getting-started/events-and-hooks/events-and-hooks.md#definition-for-source-argument)).\n * @returns {undefined | boolean} If `false` all changes were cancelled, `true` otherwise.\n * @example\n * ::: only-for javascript\n * ```js\n * // to alter a single change, overwrite the value with `changes[i][3]`\n * new Handsontable(element, {\n *   beforeChange: (changes, source) => {\n *     // [[row, prop, oldVal, newVal], ...]\n *     changes[0][3] = 10;\n *   }\n * });\n *\n * // to ignore a single change, set `changes[i]` to `null`\n * // or remove `changes[i]` from the array, by using `changes.splice(i, 1)`\n * new Handsontable(element, {\n *   beforeChange: (changes, source) => {\n *     // [[row, prop, oldVal, newVal], ...]\n *     changes[0] = null;\n *   }\n * });\n *\n * // to ignore all changes, return `false`\n * // or set the array's length to 0, by using `changes.length = 0`\n * new Handsontable(element, {\n *   beforeChange: (changes, source) => {\n *     // [[row, prop, oldVal, newVal], ...]\n *     return false;\n *   }\n * });\n * ```\n * :::\n *\n * ::: only-for react\n * ```jsx\n * // to alter a single change, overwrite the desired value with `changes[i][3]`\n * <HotTable\n *   beforeChange={(changes, source) => {\n *     // [[row, prop, oldVal, newVal], ...]\n *     changes[0][3] = 10;\n *   }}\n * />\n *\n * // to ignore a single change, set `changes[i]` to `null`\n * // or remove `changes[i]` from the array, by using changes.splice(i, 1).\n * <HotTable\n *   beforeChange={(changes, source) => {\n *     // [[row, prop, oldVal, newVal], ...]\n *     changes[0] = null;\n *   }}\n * />\n *\n * // to ignore all changes, return `false`\n * // or set the array's length to 0 (`changes.length = 0`)\n * <HotTable\n *   beforeChange={(changes, source) => {\n *     // [[row, prop, oldVal, newVal], ...]\n *     return false;\n *   }}\n * />\n * ```\n * :::\n */\n'beforeChange',\n/**\n * Fired right before rendering the changes.\n *\n * @event Hooks#beforeChangeRender\n * @param {Array[]} changes Array in form of `[row, prop, oldValue, newValue]`.\n * @param {string} [source] String that identifies source of hook call\n *                          ([list of all available sources](@/guides/getting-started/events-and-hooks/events-and-hooks.md#definition-for-source-argument)).\n */\n'beforeChangeRender',\n/**\n * Fired before drawing the borders.\n *\n * @event Hooks#beforeDrawBorders\n * @param {Array} corners Array specifying the current selection borders.\n * @param {string} borderClassName Specifies the border class name.\n */\n'beforeDrawBorders',\n/**\n * Fired before getting cell settings.\n *\n * @event Hooks#beforeGetCellMeta\n * @param {number} row Visual row index.\n * @param {number} column Visual column index.\n * @param {object} cellProperties Object containing the cell's properties.\n */\n'beforeGetCellMeta',\n/**\n * Fired before cell meta is removed.\n *\n * @event Hooks#beforeRemoveCellMeta\n * @param {number} row Visual row index.\n * @param {number} column Visual column index.\n * @param {string} key The removed meta key.\n * @param {*} value Value which is under removed key of cell meta.\n * @returns {*|boolean} If false is returned the action is canceled.\n */\n'beforeRemoveCellMeta',\n/**\n * Fired before the Handsontable instance is initiated.\n *\n * @event Hooks#beforeInit\n */\n'beforeInit',\n/**\n * Fired before the Walkontable instance is initiated.\n *\n * @event Hooks#beforeInitWalkontable\n * @param {object} walkontableConfig Walkontable configuration object.\n */\n'beforeInitWalkontable',\n/**\n * Fired before Handsontable's [`data`](@/api/options.md#data)\n * gets modified by the [`loadData()`](@/api/core.md#loaddata) method\n * or the [`updateSettings()`](@/api/core.md#updatesettings) method.\n *\n * Read more:\n * - [Binding to data](@/guides/getting-started/binding-to-data/binding-to-data.md)\n * - [Saving data](@/guides/getting-started/saving-data/saving-data.md)\n *\n * @event Hooks#beforeLoadData\n * @since 8.0.0\n * @param {Array} sourceData An [array of arrays](@/guides/getting-started/binding-to-data/binding-to-data.md#array-of-arrays), or an [array of objects](@/guides/getting-started/binding-to-data/binding-to-data.md#array-of-objects), that contains Handsontable's data\n * @param {boolean} initialLoad A flag that indicates whether the data was loaded at Handsontable's initialization (`true`) or later (`false`)\n * @param {string} source The source of the call\n * @returns {Array} The returned array will be used as Handsontable's new dataset.\n */\n'beforeLoadData',\n/**\n * Fired before the [`updateData()`](@/api/core.md#updatedata) method\n * modifies Handsontable's [`data`](@/api/options.md#data).\n *\n * Read more:\n * - [Binding to data](@/guides/getting-started/binding-to-data/binding-to-data.md)\n * - [Saving data](@/guides/getting-started/saving-data/saving-data.md)\n *\n * @event Hooks#beforeUpdateData\n * @since 11.1.0\n * @param {Array} sourceData An [array of arrays](@/guides/getting-started/binding-to-data/binding-to-data.md#array-of-arrays), or an [array of objects](@/guides/getting-started/binding-to-data/binding-to-data.md#array-of-objects), that contains Handsontable's data\n * @param {boolean} initialLoad A flag that indicates whether the data was loaded at Handsontable's initialization (`true`) or later (`false`)\n * @param {string} source The source of the call\n * @returns {Array} The returned array will be used as Handsontable's new dataset.\n */\n'beforeUpdateData',\n/**\n * Hook fired before `keydown` event is handled. It can be used to stop default key bindings.\n *\n * __Note__: To prevent default behavior you need to call `false` in your `beforeKeyDown` handler.\n *\n * @event Hooks#beforeKeyDown\n * @param {Event} event Original DOM event.\n */\n'beforeKeyDown',\n/**\n * Fired after the user clicked a cell, but before all the calculations related with it.\n *\n * @event Hooks#beforeOnCellMouseDown\n * @param {Event} event The `mousedown` event object.\n * @param {CellCoords} coords Cell coords object containing the visual coordinates of the clicked cell.\n * @param {HTMLTableCellElement} TD TD element.\n * @param {object} controller An object with properties `row`, `column` and `cell`. Each property contains\n *                            a boolean value that allows or disallows changing the selection for that particular area.\n */\n'beforeOnCellMouseDown',\n/**\n * Fired after the user clicked a cell.\n *\n * @event Hooks#beforeOnCellMouseUp\n * @param {Event} event The `mouseup` event object.\n * @param {CellCoords} coords Cell coords object containing the visual coordinates of the clicked cell.\n * @param {HTMLTableCellElement} TD TD element.\n */\n'beforeOnCellMouseUp',\n/**\n * Fired after the user clicked a cell, but before all the calculations related with it.\n *\n * @event Hooks#beforeOnCellContextMenu\n * @since 4.1.0\n * @param {Event} event The `contextmenu` event object.\n * @param {CellCoords} coords Cell coords object containing the visual coordinates of the clicked cell.\n * @param {HTMLTableCellElement} TD TD element.\n */\n'beforeOnCellContextMenu',\n/**\n * Fired after the user moved cursor over a cell, but before all the calculations related with it.\n *\n * @event Hooks#beforeOnCellMouseOver\n * @param {Event} event The `mouseover` event object.\n * @param {CellCoords} coords CellCoords object containing the visual coordinates of the clicked cell.\n * @param {HTMLTableCellElement} TD TD element.\n * @param {object} controller An object with properties `row`, `column` and `cell`. Each property contains\n *                            a boolean value that allows or disallows changing the selection for that particular area.\n */\n'beforeOnCellMouseOver',\n/**\n * Fired after the user moved cursor out from a cell, but before all the calculations related with it.\n *\n * @event Hooks#beforeOnCellMouseOut\n * @param {Event} event The `mouseout` event object.\n * @param {CellCoords} coords CellCoords object containing the visual coordinates of the leaved cell.\n * @param {HTMLTableCellElement} TD TD element.\n */\n'beforeOnCellMouseOut',\n/**\n * Fired before one or more columns are about to be removed.\n *\n * @event Hooks#beforeRemoveCol\n * @param {number} index Visual index of starter column.\n * @param {number} amount Amount of columns to be removed.\n * @param {number[]} physicalColumns An array of physical columns removed from the data source.\n * @param {string} [source] String that identifies source of hook call\n *                          ([list of all available sources](@/guides/getting-started/events-and-hooks/events-and-hooks.md#definition-for-source-argument)).\n * @returns {*|boolean} If false is returned the action is canceled.\n */\n'beforeRemoveCol',\n/**\n * Fired when one or more rows are about to be removed.\n *\n * @event Hooks#beforeRemoveRow\n * @param {number} index Visual index of starter row.\n * @param {number} amount Amount of rows to be removed.\n * @param {number[]} physicalRows An array of physical rows removed from the data source.\n * @param {string} [source] String that identifies source of hook call\n *                          ([list of all available sources](@/guides/getting-started/events-and-hooks/events-and-hooks.md#definition-for-source-argument)).\n * @returns {*|boolean} If false is returned the action is canceled.\n */\n'beforeRemoveRow',\n/**\n * Fired before Handsontable's view-rendering engine is rendered.\n *\n * __Note:__ In Handsontable 9.x and earlier, the `beforeViewRender` hook was named `beforeRender`.\n *\n * @event Hooks#beforeViewRender\n * @since 10.0.0\n * @param {boolean} isForced If set to `true`, the rendering gets triggered by a change of settings, a change of\n *                           data, or a logic that needs a full Handsontable render cycle.\n *                           If set to `false`, the rendering gets triggered by scrolling or moving the selection.\n * @param {object} skipRender Object with `skipRender` property, if it is set to `true ` the next rendering cycle will be skipped.\n */\n'beforeViewRender',\n/**\n * Fired after Handsontable's view-rendering engine is rendered,\n * but before redrawing the selection borders and before scroll syncing.\n *\n * __Note:__ In Handsontable 9.x and earlier, the `afterViewRender` hook was named `afterRender`.\n *\n * @event Hooks#afterViewRender\n * @since 10.0.0\n * @param {boolean} isForced If set to `true`, the rendering gets triggered by a change of settings, a change of\n *                           data, or a logic that needs a full Handsontable render cycle.\n *                           If set to `false`, the rendering gets triggered by scrolling or moving the selection.\n */\n'afterViewRender',\n/**\n * Fired before Handsontable's view-rendering engine updates the view.\n *\n * The `beforeRender` event is fired right after the Handsontable\n * business logic is executed and right before the rendering engine starts calling\n * the Core logic, renderers, cell meta objects etc. to update the view.\n *\n * @event Hooks#beforeRender\n * @param {boolean} isForced If set to `true`, the rendering gets triggered by a change of settings, a change of\n *                           data, or a logic that needs a full Handsontable render cycle.\n *                           If set to `false`, the rendering gets triggered by scrolling or moving the selection.\n */\n'beforeRender',\n/**\n * Fired after Handsontable's view-rendering engine updates the view.\n *\n * @event Hooks#afterRender\n * @param {boolean} isForced If set to `true`, the rendering gets triggered by a change of settings, a change of\n *                           data, or a logic that needs a full Handsontable render cycle.\n *                           If set to `false`, the rendering gets triggered by scrolling or moving the selection.\n */\n'afterRender',\n/**\n * When the focus position is moved to the next or previous row caused by the {@link Options#autoWrapRow} option\n * the hook is triggered.\n *\n * @since 14.0.0\n * @event Hooks#beforeRowWrap\n * @param {boolean} isWrapEnabled Tells whether the row wrapping is going to happen.\n * There may be situations where the option does not work even though it is enabled.\n * This is due to the priority of other options that may block the feature.\n * For example, when the {@link Options#minSpareCols} is defined, the {@link Options#autoWrapRow} option is not checked.\n * Thus, row wrapping is off.\n * @param {CellCoords} newCoords The new focus position. It is an object with keys `row` and `col`, where a value of `-1` indicates a header.\n * @param {boolean} isFlipped `true` if the row index was flipped, `false` otherwise.\n * Flipped index means that the user reached the last row and the focus is moved to the first row or vice versa.\n */\n'beforeRowWrap',\n/**\n * When the focus position is moved to the next or previous column caused by the {@link Options#autoWrapCol} option\n * the hook is triggered.\n *\n * @since 14.0.0\n * @event Hooks#beforeColumnWrap\n * @param {boolean} isWrapEnabled Tells whether the column wrapping is going to happen.\n * There may be situations where the option does not work even though it is enabled.\n * This is due to the priority of other options that may block the feature.\n * For example, when the {@link Options#minSpareRows} is defined, the {@link Options#autoWrapCol} option is not checked.\n * Thus, column wrapping is off.\n * @param {CellCoords} newCoords The new focus position. It is an object with keys `row` and `col`, where a value of `-1` indicates a header.\n * @param {boolean} isFlipped `true` if the column index was flipped, `false` otherwise.\n * Flipped index means that the user reached the last column and the focus is moved to the first column or vice versa.\n */\n'beforeColumnWrap',\n/**\n * Fired before cell meta is changed.\n *\n * @event Hooks#beforeSetCellMeta\n * @since 8.0.0\n * @param {number} row Visual row index.\n * @param {number} column Visual column index.\n * @param {string} key The updated meta key.\n * @param {*} value The updated meta value.\n * @returns {boolean|undefined} If false is returned the action is canceled.\n */\n'beforeSetCellMeta',\n/**\n * Fired before setting focus selection.\n *\n * @since 14.3.0\n * @event Hooks#beforeSelectionFocusSet\n * @param {CellCoords} coords CellCoords instance.\n */\n'beforeSelectionFocusSet',\n/**\n * Fired before setting range is started but not finished yet.\n *\n * @event Hooks#beforeSetRangeStartOnly\n * @param {CellCoords} coords `CellCoords` instance.\n */\n'beforeSetRangeStartOnly',\n/**\n * Fired before setting range is started.\n *\n * @event Hooks#beforeSetRangeStart\n * @param {CellCoords} coords `CellCoords` instance.\n */\n'beforeSetRangeStart',\n/**\n * Fired before setting range is ended.\n *\n * @event Hooks#beforeSetRangeEnd\n * @param {CellCoords} coords `CellCoords` instance.\n */\n'beforeSetRangeEnd',\n/**\n * Fired before applying selection coordinates to the renderable coordinates for Walkontable (rendering engine).\n * It occurs even when cell coordinates remain unchanged and activates during cell selection and drag selection.\n * The behavior of Shift+Tab differs from Arrow Left when there's no further movement possible.\n *\n * @since 14.0.0\n * @event Hooks#beforeSelectionHighlightSet\n */\n'beforeSelectionHighlightSet',\n/**\n * Fired before the logic of handling a touch scroll, when user started scrolling on a touch-enabled device.\n *\n * @event Hooks#beforeTouchScroll\n */\n'beforeTouchScroll',\n/**\n * Fired before cell validation, only if validator function is defined. This can be used to manipulate the value\n * of changed cell before it is applied to the validator function.\n *\n * __Note:__ this will not affect values of changes. This will change value *ONLY* for validation.\n *\n * @event Hooks#beforeValidate\n * @param {*} value Value of the cell.\n * @param {number} row Visual row index.\n * @param {string|number} prop Property name / column index.\n * @param {string} [source] String that identifies source of hook call\n *                          ([list of all available sources](@/guides/getting-started/events-and-hooks/events-and-hooks.md#definition-for-source-argument)).\n */\n'beforeValidate',\n/**\n * Fired before cell value is rendered into the DOM (through renderer function). This can be used to manipulate the\n * value which is passed to the renderer without modifying the renderer itself.\n *\n * @event Hooks#beforeValueRender\n * @param {*} value Cell value to render.\n * @param {object} cellProperties An object containing the cell properties.\n */\n'beforeValueRender',\n/**\n * Fired after Handsontable instance is constructed (using `new` operator).\n *\n * @event Hooks#construct\n */\n'construct',\n/**\n * Fired after Handsontable instance is initiated but before table is rendered.\n *\n * @event Hooks#init\n */\n'init',\n/**\n * Fired when a column header index is about to be modified by a callback function.\n *\n * @event Hooks#modifyColHeader\n * @param {number} column Visual column header index.\n */\n'modifyColHeader',\n/**\n * Fired when a column width is about to be modified by a callback function.\n *\n * @event Hooks#modifyColWidth\n * @param {number} width Current column width.\n * @param {number} column Visual column index.\n */\n'modifyColWidth',\n/**\n * Fired when rendering the list of values in the multiple-selection component of the Filters dropdown.\n * The hook allows modifying the displayed values in that component.\n *\n * @since 14.2.0\n * @event Hooks#modifyFiltersMultiSelectValue\n * @param {object} item The item in the list of values.\n * @param {object} meta The cell properties object.\n */\n'modifyFiltersMultiSelectValue',\n/**\n * Fired when focusing a cell or a header element. Allows replacing the element to be focused by returning a\n * different HTML element.\n *\n * @since 14.0.0\n * @event Hooks#modifyFocusedElement\n * @param {number} row Row index.\n * @param {number} column Column index.\n * @param {HTMLElement|undefined} focusedElement The element to be focused. `null` for focusedElement is intended when focused cell is hidden.\n */\n'modifyFocusedElement',\n/**\n * Fired when a row header index is about to be modified by a callback function.\n *\n * @event Hooks#modifyRowHeader\n * @param {number} row Visual row header index.\n */\n'modifyRowHeader',\n/**\n * Fired when a row height is about to be modified by a callback function.\n *\n * @event Hooks#modifyRowHeight\n * @param {number} height Row height.\n * @param {number} row Visual row index.\n */\n'modifyRowHeight',\n/**\n * Fired when a row height is about to be modified by a callback function. The hook allows to change the row height\n * for the specified overlay type.\n *\n * @since 14.5.0\n * @event Hooks#modifyRowHeightByOverlayName\n * @param {number} height Row height.\n * @param {number} row Visual row index.\n * @param {'inline_start'|'top'|'top_inline_start_corner'|'bottom'|'bottom_inline_start_corner'|'master'} overlayName Overlay name.\n */\n'modifyRowHeightByOverlayName',\n/**\n * Fired when a data was retrieved or modified.\n *\n * @event Hooks#modifyData\n * @param {number} row Physical row index.\n * @param {number} column Visual column index.\n * @param {object} valueHolder Object which contains original value which can be modified by overwriting `.value` property.\n * @param {string} ioMode String which indicates for what operation hook is fired (`get` or `set`).\n */\n'modifyData',\n/**\n * Fired when a data was retrieved or modified from the source data set.\n *\n * @event Hooks#modifySourceData\n * @since 8.0.0\n * @param {number} row Physical row index.\n * @param {number} column Physical column index or property name.\n * @param {object} valueHolder Object which contains original value which can be modified by overwriting `.value` property.\n * @param {string} ioMode String which indicates for what operation hook is fired (`get` or `set`).\n */\n'modifySourceData',\n/**\n * Fired when a data was retrieved or modified.\n *\n * @event Hooks#modifyRowData\n * @param {number} row Physical row index.\n */\n'modifyRowData',\n/**\n * Used to modify the cell coordinates when using the [`getCell`](@/api/core.md#getcell) method, opening editor, getting value from the editor\n * and saving values from the closed editor.\n *\n * @event Hooks#modifyGetCellCoords\n * @since 0.36.0\n * @param {number} row Visual row index.\n * @param {number} column Visual column index.\n * @param {boolean} topmost If set to `true`, it returns the TD element from the topmost overlay. For example,\n *                          if the wanted cell is in the range of fixed rows, it will return a TD element\n *                          from the `top` overlay.\n * @returns {undefined|number[]}\n */\n'modifyGetCellCoords',\n/**\n * Used to modify the cell coordinates when the table is activated (going into the listen mode).\n *\n * @event Hooks#modifyFocusOnTabNavigation\n * @since 14.0.0\n * @param {'from_above' | 'from_below'} tabActivationDir The browsers Tab navigation direction. Depending on\n * whether the user activated the table from the element above or below, another cell can be selected.\n * @param {CellCoords} visualCoords The coords that will be used to select a cell.\n */\n'modifyFocusOnTabNavigation',\n/**\n * Allows modify the visual row index that is used to retrieve the row header element (TH) before it's\n * highlighted (proper CSS class names are added). Modifying the visual row index allows building a custom\n * implementation of the nested headers feature or other features that require highlighting other DOM\n * elements than that the rendering engine, by default, would have highlighted.\n *\n * @event Hooks#beforeHighlightingRowHeader\n * @since 8.4.0\n * @param {number} row Visual row index.\n * @param {number} headerLevel Column header level (0 = most distant to the table).\n * @param {object} highlightMeta An object that contains additional information about processed selection.\n * @returns {number|undefined}\n */\n'beforeHighlightingRowHeader',\n/**\n * Allows modify the visual column index that is used to retrieve the column header element (TH) before it's\n * highlighted (proper CSS class names are added). Modifying the visual column index allows building a custom\n * implementation of the nested headers feature or other features that require highlighting other DOM\n * elements than that the rendering engine, by default, would have highlighted.\n *\n * @event Hooks#beforeHighlightingColumnHeader\n * @since 8.4.0\n * @param {number} column Visual column index.\n * @param {number} headerLevel Row header level (0 = most distant to the table).\n * @param {object} highlightMeta An object that contains additional information about processed selection.\n * @returns {number|undefined}\n */\n'beforeHighlightingColumnHeader',\n/**\n * Fired by {@link PersistentState} plugin, after loading value, saved under given key, from browser local storage.\n *\n * The `persistentStateLoad` hook is fired even when the {@link Options#persistentState} option is disabled.\n *\n * @event Hooks#persistentStateLoad\n * @param {string} key Key.\n * @param {object} valuePlaceholder Object containing the loaded value under `valuePlaceholder.value` (if no value have been saved, `value` key will be undefined).\n */\n'persistentStateLoad',\n/**\n * Fired by {@link PersistentState} plugin after resetting data from local storage. If no key is given, all values associated with table will be cleared.\n * This hook is fired when {@link Options#persistentState} option is enabled.\n *\n * @event Hooks#persistentStateReset\n * @param {string} [key] Key.\n */\n'persistentStateReset',\n/**\n * Fired by {@link PersistentState} plugin, after saving value under given key in browser local storage.\n *\n * The `persistentStateSave` hook is fired even when the {@link Options#persistentState} option is disabled.\n *\n * @event Hooks#persistentStateSave\n * @param {string} key Key.\n * @param {Mixed} value Value to save.\n */\n'persistentStateSave',\n/**\n * Fired by {@link ColumnSorting} and {@link MultiColumnSorting} plugins before sorting the column. If you return `false` value inside callback for hook, then sorting\n * will be not applied by the Handsontable (useful for server-side sorting).\n *\n * This hook is fired when {@link Options#columnSorting} or {@link Options#multiColumnSorting} option is enabled.\n *\n * @event Hooks#beforeColumnSort\n * @param {Array} currentSortConfig Current sort configuration (for all sorted columns).\n * @param {Array} destinationSortConfigs Destination sort configuration (for all sorted columns).\n * @returns {boolean | undefined} If `false` the column will not be sorted, `true` otherwise.\n */\n'beforeColumnSort',\n/**\n * Fired by {@link ColumnSorting} and {@link MultiColumnSorting} plugins after sorting the column. This hook is fired when {@link Options#columnSorting}\n * or {@link Options#multiColumnSorting} option is enabled.\n *\n * @event Hooks#afterColumnSort\n * @param {Array} currentSortConfig Current sort configuration (for all sorted columns).\n * @param {Array} destinationSortConfigs Destination sort configuration (for all sorted columns).\n */\n'afterColumnSort',\n/**\n * Fired by {@link Autofill} plugin after setting range of autofill. This hook is fired when {@link Options#fillHandle}\n * option is enabled.\n *\n * @event Hooks#modifyAutofillRange\n * @param {Array} startArea Array of visual coordinates of the starting point for the drag-down operation (`[startRow, startColumn, endRow, endColumn]`).\n * @param {Array} entireArea Array of visual coordinates of the entire area of the drag-down operation (`[startRow, startColumn, endRow, endColumn]`).\n */\n'modifyAutofillRange',\n/**\n * Fired to allow modifying the copyable range with a callback function.\n *\n * @event Hooks#modifyCopyableRange\n * @param {Array[]} copyableRanges Array of objects defining copyable cells.\n */\n'modifyCopyableRange',\n/**\n * Fired by {@link CopyPaste} plugin before copying the values to the clipboard and before clearing values of\n * the selected cells. This hook is fired when {@link Options#copyPaste} option is enabled.\n *\n * @event Hooks#beforeCut\n * @param {Array[]} data An array of arrays which contains data to cut.\n * @param {object[]} coords An array of objects with ranges of the visual indexes (`startRow`, `startCol`, `endRow`, `endCol`)\n *                       which will be cut out.\n * @returns {*} If returns `false` then operation of the cutting out is canceled.\n * @example\n * ::: only-for javascript\n * ```js\n * // To disregard a single row, remove it from the array using data.splice(i, 1).\n * new Handsontable(element, {\n *   beforeCut: function(data, coords) {\n *     // data -> [[1, 2, 3], [4, 5, 6]]\n *     data.splice(0, 1);\n *     // data -> [[4, 5, 6]]\n *     // coords -> [{startRow: 0, startCol: 0, endRow: 1, endCol: 2}]\n *   }\n * });\n * // To cancel a cutting action, just return `false`.\n * new Handsontable(element, {\n *   beforeCut: function(data, coords) {\n *     return false;\n *   }\n * });\n * ```\n * :::\n *\n * ::: only-for react\n * ```jsx\n * // To disregard a single row, remove it from the array using data.splice(i, 1).\n * <HotTable\n *   beforeCut={(data, coords) => {\n *     // data -> [[1, 2, 3], [4, 5, 6]]\n *     data.splice(0, 1);\n *     // data -> [[4, 5, 6]]\n *     // coords -> [{startRow: 0, startCol: 0, endRow: 1, endCol: 2}]\n *   }}\n * />\n * // To cancel a cutting action, just return `false`.\n * <HotTable\n *   beforeCut={(data, coords) => {\n *     return false;\n *   }}\n * />\n * ```\n * :::\n */\n'beforeCut',\n/**\n * Fired by {@link CopyPaste} plugin after data was cut out from the table. This hook is fired when\n * {@link Options#copyPaste} option is enabled.\n *\n * @event Hooks#afterCut\n * @param {Array[]} data An array of arrays with the cut data.\n * @param {object[]} coords An array of objects with ranges of the visual indexes (`startRow`, `startCol`, `endRow`, `endCol`)\n *                       which was cut out.\n */\n'afterCut',\n/**\n * Fired before values are copied to the clipboard.\n *\n * @event Hooks#beforeCopy\n * @param {Array[]} data An array of arrays which contains data to copied.\n * @param {object[]} coords An array of objects with ranges of the visual indexes (`startRow`, `startCol`, `endRow`, `endCol`)\n *                         which will copied.\n * @param {{ columnHeadersCount: number }} copiedHeadersCount (Since 12.3.0) The number of copied column headers.\n * @returns {*} If returns `false` then copying is canceled.\n *\n * @example\n * ::: only-for javascript\n * ```js\n * // To disregard a single row, remove it from array using data.splice(i, 1).\n * ...\n * new Handsontable(document.getElementById('example'), {\n *   beforeCopy: (data, coords) => {\n *     // data -> [[1, 2, 3], [4, 5, 6]]\n *     data.splice(0, 1);\n *     // data -> [[4, 5, 6]]\n *     // coords -> [{startRow: 0, startCol: 0, endRow: 1, endCol: 2}]\n *   }\n * });\n * ...\n *\n * // To cancel copying, return false from the callback.\n * ...\n * new Handsontable(document.getElementById('example'), {\n *   beforeCopy: (data, coords) => {\n *     return false;\n *   }\n * });\n * ...\n * ```\n * :::\n *\n * ::: only-for react\n * ```jsx\n * // To disregard a single row, remove it from array using data.splice(i, 1).\n * ...\n * <HotTable\n *   beforeCopy={(data, coords) => {\n *     // data -> [[1, 2, 3], [4, 5, 6]]\n *     data.splice(0, 1);\n *     // data -> [[4, 5, 6]]\n *     // coords -> [{startRow: 0, startCol: 0, endRow: 1, endCol: 2}]\n *   }}\n * />\n * ...\n *\n * // To cancel copying, return false from the callback.\n * ...\n * <HotTable\n *   beforeCopy={(data, coords) => {\n *     return false;\n *   }}\n * />\n * ...\n * ```\n * :::\n */\n'beforeCopy',\n/**\n * Fired by {@link CopyPaste} plugin after data are pasted into table. This hook is fired when {@link Options#copyPaste}\n * option is enabled.\n *\n * @event Hooks#afterCopy\n * @param {Array[]} data An array of arrays which contains the copied data.\n * @param {object[]} coords An array of objects with ranges of the visual indexes (`startRow`, `startCol`, `endRow`, `endCol`)\n *                         which was copied.\n * @param {{ columnHeadersCount: number }} copiedHeadersCount (Since 12.3.0) The number of copied column headers.\n */\n'afterCopy',\n/**\n * Fired by {@link CopyPaste} plugin before values are pasted into table. This hook is fired when\n * {@link Options#copyPaste} option is enabled.\n *\n * @event Hooks#beforePaste\n * @param {Array[]} data An array of arrays which contains data to paste.\n * @param {object[]} coords An array of objects with ranges of the visual indexes (`startRow`, `startCol`, `endRow`, `endCol`)\n *                       that correspond to the previously selected area.\n * @returns {*} If returns `false` then pasting is canceled.\n * @example\n * ```js\n * ::: only-for javascript\n * // To disregard a single row, remove it from array using data.splice(i, 1).\n * new Handsontable(example, {\n *   beforePaste: (data, coords) => {\n *     // data -> [[1, 2, 3], [4, 5, 6]]\n *     data.splice(0, 1);\n *     // data -> [[4, 5, 6]]\n *     // coords -> [{startRow: 0, startCol: 0, endRow: 1, endCol: 2}]\n *   }\n * });\n * // To cancel pasting, return false from the callback.\n * new Handsontable(example, {\n *   beforePaste: (data, coords) => {\n *     return false;\n *   }\n * });\n * ```\n * :::\n *\n * ::: only-for react\n * ```jsx\n * // To disregard a single row, remove it from array using data.splice(i, 1).\n * <HotTable\n *   beforePaste={(data, coords) => {\n *     // data -> [[1, 2, 3], [4, 5, 6]]\n *     data.splice(0, 1);\n *     // data -> [[4, 5, 6]]\n *     // coords -> [{startRow: 0, startCol: 0, endRow: 1, endCol: 2}]\n *   }}\n * />\n * // To cancel pasting, return false from the callback.\n * <HotTable\n *   beforePaste={(data, coords) => {\n *     return false;\n *   }}\n * />\n * ```\n * :::\n */\n'beforePaste',\n/**\n * Fired by {@link CopyPaste} plugin after values are pasted into table. This hook is fired when\n * {@link Options#copyPaste} option is enabled.\n *\n * @event Hooks#afterPaste\n * @param {Array[]} data An array of arrays with the pasted data.\n * @param {object[]} coords An array of objects with ranges of the visual indexes (`startRow`, `startCol`, `endRow`, `endCol`)\n *                       that correspond to the previously selected area.\n */\n'afterPaste',\n/**\n * Fired by the {@link ManualColumnFreeze} plugin, before freezing a column.\n *\n * @event Hooks#beforeColumnFreeze\n * @since 12.1.0\n * @param {number} column The visual index of the column that is going to freeze.\n * @param {boolean} freezePerformed If `true`: the column is going to freeze. If `false`: the column is not going to freeze (which might happen if the column is already frozen).\n * @returns {boolean|undefined} If `false`: the column is not going to freeze, and the `afterColumnFreeze` hook won't fire.\n */\n'beforeColumnFreeze',\n/**\n * Fired by the {@link ManualColumnFreeze} plugin, right after freezing a column.\n *\n * @event Hooks#afterColumnFreeze\n * @since 12.1.0\n * @param {number} column The visual index of the frozen column.\n * @param {boolean} freezePerformed If `true`: the column got successfully frozen. If `false`: the column didn't get frozen.\n */\n'afterColumnFreeze',\n/**\n * Fired by {@link ManualColumnMove} plugin before change order of the visual indexes. This hook is fired when\n * {@link Options#manualColumnMove} option is enabled.\n *\n * @event Hooks#beforeColumnMove\n * @param {Array} movedColumns Array of visual column indexes to be moved.\n * @param {number} finalIndex Visual column index, being a start index for the moved columns.\n *                            Points to where the elements will be placed after the moving action.\n *                            To check visualization of final index please take a look at\n *                            [documentation](@/guides/columns/column-moving/column-moving.md).\n * @param {number|undefined} dropIndex Visual column index, being a drop index for the moved columns.\n *                                     Points to where we are going to drop the moved elements. To check\n *                                     visualization of drop index please take a look at\n *                                     [documentation](@/guides/columns/column-moving/column-moving.md).\n *                                     It's `undefined` when `dragColumns` function wasn't called.\n * @param {boolean} movePossible Indicates if it's possible to move rows to the desired position.\n * @returns {undefined | boolean} If `false` the column will not be moved, `true` otherwise.\n */\n'beforeColumnMove',\n/**\n * Fired by {@link ManualColumnMove} plugin after changing order of the visual indexes.\n * This hook is fired when {@link Options#manualColumnMove} option is enabled.\n *\n * @event Hooks#afterColumnMove\n * @param {Array} movedColumns Array of visual column indexes to be moved.\n * @param {number} finalIndex Visual column index, being a start index for the moved columns.\n *                            Points to where the elements will be placed after the moving action.\n *                            To check visualization of final index please take a look at\n *                            [documentation](@/guides/columns/column-moving/column-moving.md).\n * @param {number|undefined} dropIndex Visual column index, being a drop index for the moved columns.\n *                                     Points to where we are going to drop the moved elements.\n *                                     To check visualization of drop index please take a look at\n *                                     [documentation](@/guides/columns/column-moving/column-moving.md).\n *                                     It's `undefined` when `dragColumns` function wasn't called.\n * @param {boolean} movePossible Indicates if it was possible to move columns to the desired position.\n * @param {boolean} orderChanged Indicates if order of columns was changed by move.\n */\n'afterColumnMove',\n/**\n * Fired by the {@link ManualColumnFreeze} plugin, before unfreezing a column.\n *\n * @event Hooks#beforeColumnUnfreeze\n * @since 12.1.0\n * @param {number} column The visual index of the column that is going to unfreeze.\n * @param {boolean} unfreezePerformed If `true`: the column is going to unfreeze. If `false`: the column is not going to unfreeze (which might happen if the column is already unfrozen).\n * @returns {boolean|undefined} If `false`: the column is not going to unfreeze, and the `afterColumnUnfreeze` hook won't fire.\n */\n'beforeColumnUnfreeze',\n/**\n * Fired by the {@link ManualColumnFreeze} plugin, right after unfreezing a column.\n *\n * @event Hooks#afterColumnUnfreeze\n * @since 12.1.0\n * @param {number} column The visual index of the unfrozen column.\n * @param {boolean} unfreezePerformed If `true`: the column got successfully unfrozen. If `false`: the column didn't get unfrozen.\n */\n'afterColumnUnfreeze',\n/**\n * Fired by {@link ManualRowMove} plugin before changing the order of the visual indexes. This hook is fired when\n * {@link Options#manualRowMove} option is enabled.\n *\n * @event Hooks#beforeRowMove\n * @param {Array} movedRows Array of visual row indexes to be moved.\n * @param {number} finalIndex Visual row index, being a start index for the moved rows.\n *                            Points to where the elements will be placed after the moving action.\n *                            To check visualization of final index please take a look at\n *                            [documentation](@/guides/rows/row-moving/row-moving.md).\n * @param {number|undefined} dropIndex Visual row index, being a drop index for the moved rows.\n *                                     Points to where we are going to drop the moved elements.\n *                                     To check visualization of drop index please take a look at\n *                                     [documentation](@/guides/rows/row-moving/row-moving.md).\n *                                     It's `undefined` when `dragRows` function wasn't called.\n * @param {boolean} movePossible Indicates if it's possible to move rows to the desired position.\n * @returns {*|boolean} If false is returned the action is canceled.\n */\n'beforeRowMove',\n/**\n * Fired by {@link ManualRowMove} plugin after changing the order of the visual indexes.\n * This hook is fired when {@link Options#manualRowMove} option is enabled.\n *\n * @event Hooks#afterRowMove\n * @param {Array} movedRows Array of visual row indexes to be moved.\n * @param {number} finalIndex Visual row index, being a start index for the moved rows.\n *                            Points to where the elements will be placed after the moving action.\n *                            To check visualization of final index please take a look at\n *                            [documentation](@/guides/rows/row-moving/row-moving.md).\n * @param {number|undefined} dropIndex Visual row index, being a drop index for the moved rows.\n *                                     Points to where we are going to drop the moved elements.\n *                                     To check visualization of drop index please take a look at\n *                                     [documentation](@/guides/rows/row-moving/row-moving.md).\n *                                     It's `undefined` when `dragRows` function wasn't called.\n * @param {boolean} movePossible Indicates if it was possible to move rows to the desired position.\n * @param {boolean} orderChanged Indicates if order of rows was changed by move.\n */\n'afterRowMove',\n/**\n * Fired by {@link ManualColumnResize} plugin before rendering the table with modified column sizes. This hook is\n * fired when {@link Options#manualColumnResize} option is enabled.\n *\n * @event Hooks#beforeColumnResize\n * @param {number} newSize Calculated new column width.\n * @param {number} column Visual index of the resized column.\n * @param {boolean} isDoubleClick Flag that determines whether there was a double-click.\n * @returns {number} Returns a new column size or `undefined`, if column size should be calculated automatically.\n */\n'beforeColumnResize',\n/**\n * Fired by {@link ManualColumnResize} plugin after rendering the table with modified column sizes. This hook is\n * fired when {@link Options#manualColumnResize} option is enabled.\n *\n * @event Hooks#afterColumnResize\n * @param {number} newSize Calculated new column width.\n * @param {number} column Visual index of the resized column.\n * @param {boolean} isDoubleClick Flag that determines whether there was a double-click.\n */\n'afterColumnResize',\n/**\n * Fired by {@link ManualRowResize} plugin before rendering the table with modified row sizes. This hook is\n * fired when {@link Options#manualRowResize} option is enabled.\n *\n * @event Hooks#beforeRowResize\n * @param {number} newSize Calculated new row height.\n * @param {number} row Visual index of the resized row.\n * @param {boolean} isDoubleClick Flag that determines whether there was a double-click.\n * @returns {number|undefined} Returns the new row size or `undefined` if row size should be calculated automatically.\n */\n'beforeRowResize',\n/**\n * Fired by {@link ManualRowResize} plugin after rendering the table with modified row sizes. This hook is\n * fired when {@link Options#manualRowResize} option is enabled.\n *\n * @event Hooks#afterRowResize\n * @param {number} newSize Calculated new row height.\n * @param {number} row Visual index of the resized row.\n * @param {boolean} isDoubleClick Flag that determines whether there was a double-click.\n */\n'afterRowResize',\n/**\n * Fired after getting the column header renderers.\n *\n * @event Hooks#afterGetColumnHeaderRenderers\n * @param {Function[]} renderers An array of the column header renderers.\n */\n'afterGetColumnHeaderRenderers',\n/**\n * Fired after getting the row header renderers.\n *\n * @event Hooks#afterGetRowHeaderRenderers\n * @param {Function[]} renderers An array of the row header renderers.\n */\n'afterGetRowHeaderRenderers',\n/**\n * Fired before applying stretched column width to column.\n *\n * @event Hooks#beforeStretchingColumnWidth\n * @param {number} stretchedWidth Calculated width.\n * @param {number} column Visual column index.\n * @returns {number|undefined} Returns new width which will be applied to the column element.\n */\n'beforeStretchingColumnWidth',\n/**\n * Fired by the [`Filters`](@/api/filters.md) plugin,\n * before a [column filter](@/guides/columns/column-filter/column-filter.md) gets applied.\n *\n * [`beforeFilter`](#beforefilter) takes two arguments: `conditionsStack` and `previousConditionsStack`, both are\n * arrays of objects.\n *\n * Each object represents one of your [column filters](@/api/filters.md#addcondition),\n * and consists of the following properties:\n *\n * | Property     | Possible values                                                         | Description                                                                                                              |\n * | ------------ | ----------------------------------------------------------------------- | ------------------------------------------------------------------------------------------------------------------------ |\n * | `column`     | Number                                                                  | A visual index of the column to which the filter will be applied.                                                        |\n * | `conditions` | Array of objects                                                        | Each object represents one condition. For details, see [`addCondition()`](@/api/filters.md#addcondition).                |\n * | `operation`  | `'conjunction'` \\| `'disjunction'` \\| `'disjunctionWithExtraCondition'` | An operation to perform on your set of `conditions`. For details, see [`addCondition()`](@/api/filters.md#addcondition). |\n *\n * An example of the format of the `conditionsStack` argument:\n *\n * ```js\n * [\n *   {\n *     column: 2,\n *     conditions: [\n *       {name: 'begins_with', args: [['S']]}\n *     ],\n *     operation: 'conjunction'\n *   },\n *   {\n *     column: 4,\n *     conditions: [\n *       {name: 'not_empty', args: []}\n *     ],\n *     operation: 'conjunction'\n *   },\n * ]\n * ```\n *\n * To perform server-side filtering (i.e., to not apply filtering to Handsontable's UI),\n * set [`beforeFilter`](#beforefilter) to return `false`:\n *\n * ```js\n * new Handsontable(document.getElementById('example'), {\n *   beforeFilter: (conditionsStack) => {\n *     return false;\n *   }\n * });\n *```\n *\n * Read more:\n * - [Guides: Column filter](@/guides/columns/column-filter/column-filter.md)\n * - [Hooks: `afterFilter`](#afterfilter)\n * - [Options: `filters`](@/api/options.md#filters)\n * - [Plugins: `Filters`](@/api/filters.md)\n * – [Plugin methods: `addCondition()`](@/api/filters.md#addcondition)\n *\n * @event Hooks#beforeFilter\n * @param {object[]} conditionsStack An array of objects with your [column filters](@/api/filters.md#addcondition).\n * @param {object[]|null} previousConditionsStack An array of objects with your previous [column filters](@/api/filters.md#addcondition). It can also be `null` if there was no previous filters applied or the conditions did not change between performing the `filter` action.\n * @returns {boolean} To perform server-side filtering (i.e., to not apply filtering to Handsontable's UI), return `false`.\n */\n'beforeFilter',\n/**\n * Fired by the [`Filters`](@/api/filters.md) plugin,\n * after a [column filter](@/guides/columns/column-filter/column-filter.md) gets applied.\n *\n * [`afterFilter`](#afterfilter) takes one argument (`conditionsStack`), which is an array of objects.\n * Each object represents one of your [column filters](@/api/filters.md#addcondition),\n * and consists of the following properties:\n *\n * | Property     | Possible values                                                         | Description                                                                                                              |\n * | ------------ | ----------------------------------------------------------------------- | ------------------------------------------------------------------------------------------------------------------------ |\n * | `column`     | Number                                                                  | A visual index of the column to which the filter was applied.                                                            |\n * | `conditions` | Array of objects                                                        | Each object represents one condition. For details, see [`addCondition()`](@/api/filters.md#addcondition).                |\n * | `operation`  | `'conjunction'` \\| `'disjunction'` \\| `'disjunctionWithExtraCondition'` | An operation to perform on your set of `conditions`. For details, see [`addCondition()`](@/api/filters.md#addcondition). |\n *\n * An example of the format of the `conditionsStack` argument:\n *\n * ```js\n * [\n *   {\n *     column: 2,\n *     conditions: [\n *       {name: 'begins_with', args: [['S']]}\n *     ],\n *     operation: 'conjunction'\n *   },\n *   {\n *     column: 4,\n *     conditions: [\n *       {name: 'not_empty', args: []}\n *     ],\n *     operation: 'conjunction'\n *   },\n * ]\n * ```\n *\n * Read more:\n * - [Guides: Column filter](@/guides/columns/column-filter/column-filter.md)\n * - [Hooks: `beforeFilter`](#beforefilter)\n * - [Options: `filters`](@/api/options.md#filters)\n * - [Plugins: `Filters`](@/api/filters.md)\n * – [Plugin methods: `addCondition()`](@/api/filters.md#addcondition)\n *\n * @event Hooks#afterFilter\n * @param {object[]} conditionsStack An array of objects with your [column filters](@/api/filters.md#addcondition).\n */\n'afterFilter',\n/**\n * Fired by the {@link Formulas} plugin, when any cell value changes.\n *\n * Returns an array of objects that contains:\n * - The addresses (`sheet`, `row`, `col`) and new values (`newValue`) of the changed cells.\n * - The addresses and new values of any cells that had to be recalculated (because their formulas depend on the cells that changed).\n *\n * This hook gets also fired on Handsontable's initialization, returning the addresses and values of all cells.\n *\n * Read more:\n * - [Guides: Formula calculation](@/guides/formulas/formula-calculation/formula-calculation.md)\n * - [HyperFormula documentation: `valuesUpdated`](https://hyperformula.handsontable.com/api/interfaces/listeners.html#valuesupdated)\n *\n * @since 9.0.0\n * @event Hooks#afterFormulasValuesUpdate\n * @param {Array} changes The addresses and new values of all the changed and recalculated cells.\n */\n'afterFormulasValuesUpdate',\n/**\n * Fired when a named expression is added to the Formulas' engine instance.\n *\n * @since 9.0.0\n * @event Hooks#afterNamedExpressionAdded\n * @param {string} namedExpressionName The name of the added expression.\n * @param {Array} changes The values and location of applied changes.\n */\n'afterNamedExpressionAdded',\n/**\n * Fired when a named expression is removed from the Formulas' engine instance.\n *\n * @since 9.0.0\n * @event Hooks#afterNamedExpressionRemoved\n * @param {string} namedExpressionName The name of the removed expression.\n * @param {Array} changes The values and location of applied changes.\n */\n'afterNamedExpressionRemoved',\n/**\n * Fired when a new sheet is added to the Formulas' engine instance.\n *\n * @since 9.0.0\n * @event Hooks#afterSheetAdded\n * @param {string} addedSheetDisplayName The name of the added sheet.\n */\n'afterSheetAdded',\n/**\n * Fired when a sheet in the Formulas' engine instance is renamed.\n *\n * @since 9.0.0\n * @event Hooks#afterSheetRenamed\n * @param {string} oldDisplayName The old name of the sheet.\n * @param {string} newDisplayName The new name of the sheet.\n */\n'afterSheetRenamed',\n/**\n * Fired when a sheet is removed from the Formulas' engine instance.\n *\n * @since 9.0.0\n * @event Hooks#afterSheetRemoved\n * @param {string} removedSheetDisplayName The removed sheet name.\n * @param {Array} changes The values and location of applied changes.\n */\n'afterSheetRemoved',\n/**\n * Fired while retrieving the column header height.\n *\n * @event Hooks#modifyColumnHeaderHeight\n */\n'modifyColumnHeaderHeight',\n/**\n * Fired while retrieving a column header's value.\n *\n * @since 12.3.0\n * @event Hooks#modifyColumnHeaderValue\n * @param {string} value A column header value.\n * @param {number} visualColumnIndex A visual column index.\n * @param {number} [headerLevel=0] Header level index. Accepts positive (`0` to `n`)\n *                                 and negative (`-1` to `-n`) values. For positive values, `0` points to the\n *                                 topmost header. For negative values, `-1` points to the bottom-most\n *                                 header (the header closest to the cells).\n * @returns {string} The column header value to be updated.\n */\n'modifyColumnHeaderValue',\n/**\n * Fired by {@link UndoRedo} plugin before the undo action. Contains information about the action that is being undone.\n * This hook is fired when {@link Options#undo} option is enabled.\n *\n * @event Hooks#beforeUndo\n * @param {object} action The action object. Contains information about the action being undone. The `actionType`\n *                        property of the object specifies the type of the action in a String format. (e.g. `'remove_row'`).\n * @returns {*|boolean} If false is returned the action is canceled.\n */\n'beforeUndo',\n/**\n * Fired by {@link UndoRedo} plugin before changing undo stack.\n *\n * @event Hooks#beforeUndoStackChange\n * @since 8.4.0\n * @param {Array} doneActions Stack of actions which may be undone.\n * @param {string} [source] String that identifies source of action\n *                          ([list of all available sources](@/guides/getting-started/events-and-hooks/events-and-hooks.md#definition-for-source-argument)).\n * @returns {*|boolean} If false is returned the action of changing undo stack is canceled.\n */\n'beforeUndoStackChange',\n/**\n * Fired by {@link UndoRedo} plugin after the undo action. Contains information about the action that is being undone.\n * This hook is fired when {@link Options#undo} option is enabled.\n *\n * @event Hooks#afterUndo\n * @param {object} action The action object. Contains information about the action being undone. The `actionType`\n *                        property of the object specifies the type of the action in a String format. (e.g. `'remove_row'`).\n */\n'afterUndo',\n/**\n * Fired by {@link UndoRedo} plugin after changing undo stack.\n *\n * @event Hooks#afterUndoStackChange\n * @since 8.4.0\n * @param {Array} doneActionsBefore Stack of actions which could be undone before performing new action.\n * @param {Array} doneActionsAfter Stack of actions which can be undone after performing new action.\n */\n'afterUndoStackChange',\n/**\n * Fired by {@link UndoRedo} plugin before the redo action. Contains information about the action that is being redone.\n * This hook is fired when {@link Options#undo} option is enabled.\n *\n * @event Hooks#beforeRedo\n * @param {object} action The action object. Contains information about the action being redone. The `actionType`\n *                        property of the object specifies the type of the action in a String format (e.g. `'remove_row'`).\n * @returns {*|boolean} If false is returned the action is canceled.\n */\n'beforeRedo',\n/**\n * Fired by {@link UndoRedo} plugin before changing redo stack.\n *\n * @event Hooks#beforeRedoStackChange\n * @since 8.4.0\n * @param {Array} undoneActions Stack of actions which may be redone.\n */\n'beforeRedoStackChange',\n/**\n * Fired by {@link UndoRedo} plugin after the redo action. Contains information about the action that is being redone.\n * This hook is fired when {@link Options#undo} option is enabled.\n *\n * @event Hooks#afterRedo\n * @param {object} action The action object. Contains information about the action being redone. The `actionType`\n *                        property of the object specifies the type of the action in a String format (e.g. `'remove_row'`).\n */\n'afterRedo',\n/**\n * Fired by {@link UndoRedo} plugin after changing redo stack.\n *\n * @event Hooks#afterRedoStackChange\n * @since 8.4.0\n * @param {Array} undoneActionsBefore Stack of actions which could be redone before performing new action.\n * @param {Array} undoneActionsAfter Stack of actions which can be redone after performing new action.\n */\n'afterRedoStackChange',\n/**\n * Fired while retrieving the row header width.\n *\n * @event Hooks#modifyRowHeaderWidth\n * @param {number} rowHeaderWidth Row header width.\n */\n'modifyRowHeaderWidth',\n/**\n * Fired when the focus of the selection is being modified (e.g. Moving the focus with the enter/tab keys).\n *\n * @since 14.3.0\n * @event Hooks#modifyTransformFocus\n * @param {CellCoords} delta Cell coords object declaring the delta of the new selection relative to the previous one.\n */\n'modifyTransformFocus',\n/**\n * Fired when the start of the selection is being modified (e.g. Moving the selection with the arrow keys).\n *\n * @event Hooks#modifyTransformStart\n * @param {CellCoords} delta Cell coords object declaring the delta of the new selection relative to the previous one.\n */\n'modifyTransformStart',\n/**\n * Fired when the end of the selection is being modified (e.g. Moving the selection with the arrow keys).\n *\n * @event Hooks#modifyTransformEnd\n * @param {CellCoords} delta Cell coords object declaring the delta of the new selection relative to the previous one.\n */\n'modifyTransformEnd',\n/**\n * Fired after the focus of the selection is being modified (e.g. Moving the focus with the enter/tab keys).\n *\n * @since 14.3.0\n * @event Hooks#afterModifyTransformFocus\n * @param {CellCoords} coords Coords of the freshly focused cell.\n * @param {number} rowTransformDir `-1` if trying to focus a cell with a negative row index. `0` otherwise.\n * @param {number} colTransformDir `-1` if trying to focus a cell with a negative column index. `0` otherwise.\n */\n'afterModifyTransformFocus',\n/**\n * Fired after the start of the selection is being modified (e.g. Moving the selection with the arrow keys).\n *\n * @event Hooks#afterModifyTransformStart\n * @param {CellCoords} coords Coords of the freshly selected cell.\n * @param {number} rowTransformDir `-1` if trying to select a cell with a negative row index. `0` otherwise.\n * @param {number} colTransformDir `-1` if trying to select a cell with a negative column index. `0` otherwise.\n */\n'afterModifyTransformStart',\n/**\n * Fired after the end of the selection is being modified (e.g. Moving the selection with the arrow keys).\n *\n * @event Hooks#afterModifyTransformEnd\n * @param {CellCoords} coords Visual coords of the freshly selected cell.\n * @param {number} rowTransformDir `-1` if trying to select a cell with a negative row index. `0` otherwise.\n * @param {number} colTransformDir `-1` if trying to select a cell with a negative column index. `0` otherwise.\n */\n'afterModifyTransformEnd',\n/**\n * Fired inside the `viewportRowCalculatorOverride` method. Allows modifying the row calculator parameters.\n *\n * @event Hooks#afterViewportRowCalculatorOverride\n * @param {object} calc The row calculator.\n */\n'afterViewportRowCalculatorOverride',\n/**\n * Fired inside the `viewportColumnCalculatorOverride` method. Allows modifying the row calculator parameters.\n *\n * @event Hooks#afterViewportColumnCalculatorOverride\n * @param {object} calc The row calculator.\n */\n'afterViewportColumnCalculatorOverride',\n/**\n * Fired after initializing all the plugins.\n * This hook should be added before Handsontable is initialized.\n *\n * @event Hooks#afterPluginsInitialized\n *\n * @example\n * ```js\n * Handsontable.hooks.add('afterPluginsInitialized', myCallback);\n * ```\n */\n'afterPluginsInitialized',\n/**\n * Fired by {@link HiddenRows} plugin before marking the rows as hidden. Fired only if the {@link Options#hiddenRows} option is enabled.\n * Returning `false` in the callback will prevent the hiding action from completing.\n *\n * @event Hooks#beforeHideRows\n * @param {Array} currentHideConfig Current hide configuration - a list of hidden physical row indexes.\n * @param {Array} destinationHideConfig Destination hide configuration - a list of hidden physical row indexes.\n * @param {boolean} actionPossible `true`, if provided row indexes are valid, `false` otherwise.\n * @returns {undefined|boolean} If the callback returns `false`, the hiding action will not be completed.\n */\n'beforeHideRows',\n/**\n * Fired by {@link HiddenRows} plugin after marking the rows as hidden. Fired only if the {@link Options#hiddenRows} option is enabled.\n *\n * @event Hooks#afterHideRows\n * @param {Array} currentHideConfig Current hide configuration - a list of hidden physical row indexes.\n * @param {Array} destinationHideConfig Destination hide configuration - a list of hidden physical row indexes.\n * @param {boolean} actionPossible `true`, if provided row indexes are valid, `false` otherwise.\n * @param {boolean} stateChanged `true`, if the action affected any non-hidden rows, `false` otherwise.\n */\n'afterHideRows',\n/**\n * Fired by {@link HiddenRows} plugin before marking the rows as not hidden. Fired only if the {@link Options#hiddenRows} option is enabled.\n * Returning `false` in the callback will prevent the row revealing action from completing.\n *\n * @event Hooks#beforeUnhideRows\n * @param {Array} currentHideConfig Current hide configuration - a list of hidden physical row indexes.\n * @param {Array} destinationHideConfig Destination hide configuration - a list of hidden physical row indexes.\n * @param {boolean} actionPossible `true`, if provided row indexes are valid, `false` otherwise.\n * @returns {undefined|boolean} If the callback returns `false`, the revealing action will not be completed.\n */\n'beforeUnhideRows',\n/**\n * Fired by {@link HiddenRows} plugin after marking the rows as not hidden. Fired only if the {@link Options#hiddenRows} option is enabled.\n *\n * @event Hooks#afterUnhideRows\n * @param {Array} currentHideConfig Current hide configuration - a list of hidden physical row indexes.\n * @param {Array} destinationHideConfig Destination hide configuration - a list of hidden physical row indexes.\n * @param {boolean} actionPossible `true`, if provided row indexes are valid, `false` otherwise.\n * @param {boolean} stateChanged `true`, if the action affected any hidden rows, `false` otherwise.\n */\n'afterUnhideRows',\n/**\n * Fired by {@link HiddenColumns} plugin before marking the columns as hidden. Fired only if the {@link Options#hiddenColumns} option is enabled.\n * Returning `false` in the callback will prevent the hiding action from completing.\n *\n * @event Hooks#beforeHideColumns\n * @param {Array} currentHideConfig Current hide configuration - a list of hidden physical column indexes.\n * @param {Array} destinationHideConfig Destination hide configuration - a list of hidden physical column indexes.\n * @param {boolean} actionPossible `true`, if the provided column indexes are valid, `false` otherwise.\n * @returns {undefined|boolean} If the callback returns `false`, the hiding action will not be completed.\n */\n'beforeHideColumns',\n/**\n * Fired by {@link HiddenColumns} plugin after marking the columns as hidden. Fired only if the {@link Options#hiddenColumns} option is enabled.\n *\n * @event Hooks#afterHideColumns\n * @param {Array} currentHideConfig Current hide configuration - a list of hidden physical column indexes.\n * @param {Array} destinationHideConfig Destination hide configuration - a list of hidden physical column indexes.\n * @param {boolean} actionPossible `true`, if the provided column indexes are valid, `false` otherwise.\n * @param {boolean} stateChanged `true`, if the action affected any non-hidden columns, `false` otherwise.\n */\n'afterHideColumns',\n/**\n * Fired by {@link HiddenColumns} plugin before marking the columns as not hidden. Fired only if the {@link Options#hiddenColumns} option is enabled.\n * Returning `false` in the callback will prevent the column revealing action from completing.\n *\n * @event Hooks#beforeUnhideColumns\n * @param {Array} currentHideConfig Current hide configuration - a list of hidden physical column indexes.\n * @param {Array} destinationHideConfig Destination hide configuration - a list of hidden physical column indexes.\n * @param {boolean} actionPossible `true`, if the provided column indexes are valid, `false` otherwise.\n * @returns {undefined|boolean} If the callback returns `false`, the hiding action will not be completed.\n */\n'beforeUnhideColumns',\n/**\n * Fired by {@link HiddenColumns} plugin after marking the columns as not hidden. Fired only if the {@link Options#hiddenColumns} option is enabled.\n *\n * @event Hooks#afterUnhideColumns\n * @param {Array} currentHideConfig Current hide configuration - a list of hidden physical column indexes.\n * @param {Array} destinationHideConfig Destination hide configuration - a list of hidden physical column indexes.\n * @param {boolean} actionPossible `true`, if the provided column indexes are valid, `false` otherwise.\n * @param {boolean} stateChanged `true`, if the action affected any hidden columns, `false` otherwise.\n */\n'afterUnhideColumns',\n/**\n * Fired by {@link TrimRows} plugin before trimming rows. This hook is fired when {@link Options#trimRows} option is enabled.\n *\n * @event Hooks#beforeTrimRow\n * @param {Array} currentTrimConfig Current trim configuration - a list of trimmed physical row indexes.\n * @param {Array} destinationTrimConfig Destination trim configuration - a list of trimmed physical row indexes.\n * @param {boolean} actionPossible `true`, if all of the row indexes are withing the bounds of the table, `false` otherwise.\n * @returns {undefined|boolean} If the callback returns `false`, the trimming action will not be completed.\n */\n'beforeTrimRow',\n/**\n * Fired by {@link TrimRows} plugin after trimming rows. This hook is fired when {@link Options#trimRows} option is enabled.\n *\n * @event Hooks#afterTrimRow\n * @param {Array} currentTrimConfig Current trim configuration - a list of trimmed physical row indexes.\n * @param {Array} destinationTrimConfig Destination trim configuration - a list of trimmed physical row indexes.\n * @param {boolean} actionPossible `true`, if all of the row indexes are withing the bounds of the table, `false` otherwise.\n * @param {boolean} stateChanged `true`, if the action affected any non-trimmed rows, `false` otherwise.\n * @returns {undefined|boolean} If the callback returns `false`, the trimming action will not be completed.\n */\n'afterTrimRow',\n/**\n * Fired by {@link TrimRows} plugin before untrimming rows. This hook is fired when {@link Options#trimRows} option is enabled.\n *\n * @event Hooks#beforeUntrimRow\n * @param {Array} currentTrimConfig Current trim configuration - a list of trimmed physical row indexes.\n * @param {Array} destinationTrimConfig Destination trim configuration - a list of trimmed physical row indexes.\n * @param {boolean} actionPossible `true`, if all of the row indexes are withing the bounds of the table, `false` otherwise.\n * @returns {undefined|boolean} If the callback returns `false`, the untrimming action will not be completed.\n */\n'beforeUntrimRow',\n/**\n * Fired by {@link TrimRows} plugin after untrimming rows. This hook is fired when {@link Options#trimRows} option is enabled.\n *\n * @event Hooks#afterUntrimRow\n * @param {Array} currentTrimConfig Current trim configuration - a list of trimmed physical row indexes.\n * @param {Array} destinationTrimConfig Destination trim configuration - a list of trimmed physical row indexes.\n * @param {boolean} actionPossible `true`, if all of the row indexes are withing the bounds of the table, `false` otherwise.\n * @param {boolean} stateChanged `true`, if the action affected any trimmed rows, `false` otherwise.\n * @returns {undefined|boolean} If the callback returns `false`, the untrimming action will not be completed.\n */\n'afterUntrimRow',\n/**\n * Fired by {@link DropdownMenu} plugin before opening the dropdown menu. This hook is fired when {@link Options#dropdownMenu}\n * option is enabled.\n *\n * @event Hooks#beforeDropdownMenuShow\n * @param {DropdownMenu} dropdownMenu The `DropdownMenu` instance.\n */\n'beforeDropdownMenuShow',\n/**\n * Fired by {@link DropdownMenu} plugin after opening the Dropdown Menu. This hook is fired when {@link Options#dropdownMenu}\n * option is enabled.\n *\n * @event Hooks#afterDropdownMenuShow\n * @param {DropdownMenu} dropdownMenu The `DropdownMenu` instance.\n */\n'afterDropdownMenuShow',\n/**\n * Fired by {@link DropdownMenu} plugin after hiding the Dropdown Menu. This hook is fired when {@link Options#dropdownMenu}\n * option is enabled.\n *\n * @event Hooks#afterDropdownMenuHide\n * @param {DropdownMenu} instance The `DropdownMenu` instance.\n */\n'afterDropdownMenuHide',\n/**\n * Fired by {@link NestedRows} plugin before adding a children to the `NestedRows` structure. This hook is fired when\n * {@link Options#nestedRows} option is enabled.\n *\n * @event Hooks#beforeAddChild\n * @param {object} parent The parent object.\n * @param {object|undefined} element The element added as a child. If `undefined`, a blank child was added.\n * @param {number|undefined} index The index within the parent where the new child was added. If `undefined`, the element was added as the last child.\n */\n'beforeAddChild',\n/**\n * Fired by {@link NestedRows} plugin after adding a children to the `NestedRows` structure. This hook is fired when\n * {@link Options#nestedRows} option is enabled.\n *\n * @event Hooks#afterAddChild\n * @param {object} parent The parent object.\n * @param {object|undefined} element The element added as a child. If `undefined`, a blank child was added.\n * @param {number|undefined} index The index within the parent where the new child was added. If `undefined`, the element was added as the last child.\n */\n'afterAddChild',\n/**\n * Fired by {@link NestedRows} plugin before detaching a child from its parent. This hook is fired when\n * {@link Options#nestedRows} option is enabled.\n *\n * @event Hooks#beforeDetachChild\n * @param {object} parent An object representing the parent from which the element is to be detached.\n * @param {object} element The detached element.\n */\n'beforeDetachChild',\n/**\n * Fired by {@link NestedRows} plugin after detaching a child from its parent. This hook is fired when\n * {@link Options#nestedRows} option is enabled.\n *\n * @event Hooks#afterDetachChild\n * @param {object} parent An object representing the parent from which the element was detached.\n * @param {object} element The detached element.\n * @param {number} finalElementPosition The final row index of the detached element.\n */\n'afterDetachChild',\n/**\n * Fired before the editor is opened and rendered.\n *\n * @since 14.2.0\n * @event Hooks#beforeBeginEditing\n * @param {number} row Visual row index of the edited cell.\n * @param {number} column Visual column index of the edited cell.\n * @param {*} initialValue The initial editor value.\n * @param {MouseEvent | KeyboardEvent} event The event which was responsible for opening the editor.\n * @param {boolean} fullEditMode `true` if the editor is opened in full edit mode, `false` otherwise.\n * Editor opened in full edit mode does not close after pressing Arrow keys.\n * @returns {boolean | undefined} If the callback returns `false,` the editor won't be opened after\n * the mouse double click or after pressing the Enter key. Returning `undefined` (or other value\n * than boolean) will result in default behavior, which disallows opening an editor for non-contiguous\n * selection (while pressing Ctrl/Cmd) and for multiple selected cells (while pressing SHIFT).\n * Returning `true` removes those restrictions.\n */\n'beforeBeginEditing',\n/**\n * Fired after the editor is opened and rendered.\n *\n * @event Hooks#afterBeginEditing\n * @param {number} row Visual row index of the edited cell.\n * @param {number} column Visual column index of the edited cell.\n */\n'afterBeginEditing',\n/**\n * Fired by {@link MergeCells} plugin before cell merging. This hook is fired when {@link Options#mergeCells}\n * option is enabled.\n *\n * @event Hooks#beforeMergeCells\n * @param {CellRange} cellRange Selection cell range.\n * @param {boolean} [auto=false] `true` if called automatically by the plugin.\n */\n'beforeMergeCells',\n/**\n * Fired by {@link MergeCells} plugin after cell merging. This hook is fired when {@link Options#mergeCells}\n * option is enabled.\n *\n * @event Hooks#afterMergeCells\n * @param {CellRange} cellRange Selection cell range.\n * @param {object} mergeParent The parent collection of the provided cell range.\n * @param {boolean} [auto=false] `true` if called automatically by the plugin.\n */\n'afterMergeCells',\n/**\n * Fired by {@link MergeCells} plugin before unmerging the cells. This hook is fired when {@link Options#mergeCells}\n * option is enabled.\n *\n * @event Hooks#beforeUnmergeCells\n * @param {CellRange} cellRange Selection cell range.\n * @param {boolean} [auto=false] `true` if called automatically by the plugin.\n */\n'beforeUnmergeCells',\n/**\n * Fired by {@link MergeCells} plugin after unmerging the cells. This hook is fired when {@link Options#mergeCells}\n * option is enabled.\n *\n * @event Hooks#afterUnmergeCells\n * @param {CellRange} cellRange Selection cell range.\n * @param {boolean} [auto=false] `true` if called automatically by the plugin.\n */\n'afterUnmergeCells',\n/**\n * Fired after the table was switched into listening mode. This allows Handsontable to capture keyboard events and\n * respond in the right way.\n *\n * @event Hooks#afterListen\n */\n'afterListen',\n/**\n * Fired after the table was switched off from the listening mode. This makes the Handsontable inert for any\n * keyboard events.\n *\n * @event Hooks#afterUnlisten\n */\n'afterUnlisten',\n/**\n * Fired after the window was resized or the size of the Handsontable root element was changed.\n *\n * @event Hooks#afterRefreshDimensions\n * @param {{ width: number, height: number }} previousDimensions Previous dimensions of the container.\n * @param {{ width: number, height: number }} currentDimensions Current dimensions of the container.\n * @param {boolean} stateChanged `true`, if the container was re-render, `false` otherwise.\n */\n'afterRefreshDimensions',\n/**\n * Cancellable hook, called after resizing a window or after detecting size change of the\n * Handsontable root element, but before redrawing a table.\n *\n * @event Hooks#beforeRefreshDimensions\n * @param {{ width: number, height: number }} previousDimensions Previous dimensions of the container.\n * @param {{ width: number, height: number }} currentDimensions Current dimensions of the container.\n * @param {boolean} actionPossible `true`, if current and previous dimensions are different, `false` otherwise.\n * @returns {undefined|boolean} If the callback returns `false`, the refresh action will not be completed.\n */\n'beforeRefreshDimensions',\n/**\n * Fired by {@link CollapsibleColumns} plugin before columns collapse. This hook is fired when {@link Options#collapsibleColumns} option is enabled.\n *\n * @event Hooks#beforeColumnCollapse\n * @since 8.0.0\n * @param {Array} currentCollapsedColumns Current collapsible configuration - a list of collapsible physical column indexes.\n * @param {Array} destinationCollapsedColumns Destination collapsible configuration - a list of collapsible physical column indexes.\n * @param {boolean} collapsePossible `true`, if all of the column indexes are withing the bounds of the collapsed sections, `false` otherwise.\n * @returns {undefined|boolean} If the callback returns `false`, the collapsing action will not be completed.\n */\n'beforeColumnCollapse',\n/**\n * Fired by {@link CollapsibleColumns} plugin before columns collapse. This hook is fired when {@link Options#collapsibleColumns} option is enabled.\n *\n * @event Hooks#afterColumnCollapse\n * @since 8.0.0\n * @param {Array} currentCollapsedColumns Current collapsible configuration - a list of collapsible physical column indexes.\n * @param {Array} destinationCollapsedColumns Destination collapsible configuration - a list of collapsible physical column indexes.\n * @param {boolean} collapsePossible `true`, if all of the column indexes are withing the bounds of the collapsed sections, `false` otherwise.\n * @param {boolean} successfullyCollapsed `true`, if the action affected any non-collapsible column, `false` otherwise.\n */\n'afterColumnCollapse',\n/**\n * Fired by {@link CollapsibleColumns} plugin before columns expand. This hook is fired when {@link Options#collapsibleColumns} option is enabled.\n *\n * @event Hooks#beforeColumnExpand\n * @since 8.0.0\n * @param {Array} currentCollapsedColumns Current collapsible configuration - a list of collapsible physical column indexes.\n * @param {Array} destinationCollapsedColumns Destination collapsible configuration - a list of collapsible physical column indexes.\n * @param {boolean} expandPossible `true`, if all of the column indexes are withing the bounds of the collapsed sections, `false` otherwise.\n * @returns {undefined|boolean} If the callback returns `false`, the expanding action will not be completed.\n */\n'beforeColumnExpand',\n/**\n * Fired by {@link CollapsibleColumns} plugin before columns expand. This hook is fired when {@link Options#collapsibleColumns} option is enabled.\n *\n * @event Hooks#afterColumnExpand\n * @since 8.0.0\n * @param {Array} currentCollapsedColumns Current collapsible configuration - a list of collapsible physical column indexes.\n * @param {Array} destinationCollapsedColumns Destination collapsible configuration - a list of collapsible physical column indexes.\n * @param {boolean} expandPossible `true`, if all of the column indexes are withing the bounds of the collapsed sections, `false` otherwise.\n * @param {boolean} successfullyExpanded `true`, if the action affected any non-collapsible column, `false` otherwise.\n */\n'afterColumnExpand',\n/**\n * Fired by {@link AutoColumnSize} plugin within SampleGenerator utility.\n *\n * @event Hooks#modifyAutoColumnSizeSeed\n * @since 8.4.0\n * @param {string|undefined} seed Seed ID, unique name to categorize samples.\n * @param {object} cellProperties Object containing the cell properties.\n * @param {*} cellValue Value of the cell.\n */\n'modifyAutoColumnSizeSeed'];\n\n/**\n * Template warning message for removed hooks.\n *\n * @type {string}\n */\nconst REMOVED_MESSAGE = toSingleLine`The plugin hook \"[hookName]\" was removed in Handsontable [removedInVersion].\\x20\n  Please consult release notes https://github.com/handsontable/handsontable/releases/tag/[removedInVersion] to\\x20\n  learn about the migration path.`;\n\n/**\n * The list of the hooks which are removed from the API. The warning message is printed out in\n * the developer console when the hook is used.\n *\n * The Map key is represented by hook name and its value points to the Handsontable version\n * in which it was removed.\n *\n * @type {Map<string, string>}\n */\nconst REMOVED_HOOKS = new Map([['modifyRow', '8.0.0'], ['modifyCol', '8.0.0'], ['unmodifyRow', '8.0.0'], ['unmodifyCol', '8.0.0'], ['skipLengthCache', '8.0.0'], ['hiddenColumn', '8.0.0'], ['hiddenRow', '8.0.0']]);\n\n/* eslint-disable jsdoc/require-description-complete-sentence */\n/**\n * The list of the hooks which are deprecated. The warning message is printed out in\n * the developer console when the hook is used.\n *\n * The Map key is represented by hook name and its value keeps message which whould be\n * printed out when the hook is used.\n *\n * Usage:\n * ```js\n * ...\n * New Map([\n *   ['beforeColumnExpand', 'The plugin hook \"beforeColumnExpand\" is deprecated. Use \"beforeColumnExpand2\" instead.'],\n * ])\n * ...\n * ```\n *\n *\n * @type {Map<string, string>}\n */\n/* eslint-enable jsdoc/require-description-complete-sentence */\nconst DEPRECATED_HOOKS = new Map([[]]);\nconst callbackOrder = new WeakMap();\nclass Hooks {\n  static getSingleton() {\n    return getGlobalSingleton();\n  }\n\n  /**\n   * @type {object}\n   */\n\n  /**\n   *\n   */\n  constructor() {\n    _defineProperty(this, \"globalBucket\", void 0);\n    this.globalBucket = this.createEmptyBucket();\n  }\n\n  /**\n   * Returns a new object with empty handlers related to every registered hook name.\n   *\n   * @returns {object} The empty bucket object.\n   *\n   * @example\n   * ```js\n   * Handsontable.hooks.createEmptyBucket();\n   * // Results:\n   * {\n   * ...\n   * afterCreateCol: [],\n   * afterCreateRow: [],\n   * beforeInit: [],\n   * ...\n   * }\n   * ```\n   */\n  createEmptyBucket() {\n    const bucket = Object.create(null);\n\n    // eslint-disable-next-line no-return-assign\n    arrayEach(REGISTERED_HOOKS, hook => {\n      bucket[hook] = [];\n      this.initOrderMap(bucket, hook);\n    });\n    return bucket;\n  }\n\n  /**\n   * Get hook bucket based on the context of the object or if argument is `undefined`, get the global hook bucket.\n   *\n   * @param {object} [context=null] A Handsontable instance.\n   * @returns {object} Returns a global or Handsontable instance bucket.\n   */\n  getBucket() {\n    let context = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;\n    if (context) {\n      if (!context.pluginHookBucket) {\n        context.pluginHookBucket = this.createEmptyBucket();\n      }\n      return context.pluginHookBucket;\n    }\n    return this.globalBucket;\n  }\n\n  /**\n   * Adds a listener (globally or locally) to a specified hook name.\n   * If the `context` parameter is provided, the hook will be added only to the instance it references.\n   * Otherwise, the callback will be used everytime the hook fires on any Handsontable instance.\n   * You can provide an array of callback functions as the `callback` argument, this way they will all be fired\n   * once the hook is triggered.\n   *\n   * @see Core#addHook\n   * @param {string} key Hook name.\n   * @param {Function|Array} callback Callback function or an array of functions.\n   * @param {object} [context=null] The context for the hook callback to be added - a Handsontable instance or leave empty.\n   * @param {number} [orderIndex] Order index of the callback.\n   *                              If > 0, the callback will be added after the others, for example, with an index of 1, the callback will be added before the ones with an index of 2, 3, etc., but after the ones with an index of 0 and lower.\n   *                              If < 0, the callback will be added before the others, for example, with an index of -1, the callback will be added after the ones with an index of -2, -3, etc., but before the ones with an index of 0 and higher.\n   *                              If 0 or no order index is provided, the callback will be added between the \"negative\" and \"positive\" indexes.\n   * @returns {Hooks} Instance of Hooks.\n   *\n   * @example\n   * ```js\n   * // single callback, added locally\n   * Handsontable.hooks.add('beforeInit', myCallback, hotInstance);\n   *\n   * // single callback, added globally\n   * Handsontable.hooks.add('beforeInit', myCallback);\n   *\n   * // multiple callbacks, added locally\n   * Handsontable.hooks.add('beforeInit', [myCallback, anotherCallback], hotInstance);\n   *\n   * // multiple callbacks, added globally\n   * Handsontable.hooks.add('beforeInit', [myCallback, anotherCallback]);\n   * ```\n   */\n  add(key, callback) {\n    let context = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;\n    let orderIndex = arguments.length > 3 ? arguments[3] : undefined;\n    if (Array.isArray(callback)) {\n      arrayEach(callback, c => this.add(key, c, context));\n    } else {\n      if (REMOVED_HOOKS.has(key)) {\n        warn(substitute(REMOVED_MESSAGE, {\n          hookName: key,\n          removedInVersion: REMOVED_HOOKS.get(key)\n        }));\n      }\n      if (DEPRECATED_HOOKS.has(key)) {\n        warn(DEPRECATED_HOOKS.get(key));\n      }\n      const bucket = this.getBucket(context);\n      if (typeof bucket[key] === 'undefined') {\n        this.register(key);\n        bucket[key] = [];\n        this.initOrderMap(bucket, key);\n      }\n      callback.skip = false;\n      if (bucket[key].indexOf(callback) === -1) {\n        // only add a hook if it has not already been added (adding the same hook twice is now silently ignored)\n        let foundInitialHook = false;\n        if (callback.initialHook) {\n          arrayEach(bucket[key], (cb, i) => {\n            if (cb.initialHook) {\n              bucket[key][i] = callback;\n              foundInitialHook = true;\n              return false;\n            }\n          });\n        }\n        if (!foundInitialHook) {\n          bucket[key].push(callback);\n        }\n      }\n      this.setCallbackOrderIndex(bucket, key, callback, orderIndex);\n      this.orderBucketByOrderIndex(bucket, key);\n    }\n    return this;\n  }\n\n  /**\n   * Adds a listener to a specified hook. After the hook runs this listener will be automatically removed from the bucket.\n   *\n   * @see Core#addHookOnce\n   * @param {string} key Hook/Event name.\n   * @param {Function|Array} callback Callback function.\n   * @param {object} [context=null] A Handsontable instance.\n   * @param {number} [orderIndex] Order index of the callback.\n   *                              If > 0, the callback will be added after the others, for example, with an index of 1, the callback will be added before the ones with an index of 2, 3, etc., but after the ones with an index of 0 and lower.\n   *                              If < 0, the callback will be added before the others, for example, with an index of -1, the callback will be added after the ones with an index of -2, -3, etc., but before the ones with an index of 0 and higher.\n   *                              If 0 or no order index is provided, the callback will be added between the \"negative\" and \"positive\" indexes.\n   *\n   * @example\n   * ```js\n   * Handsontable.hooks.once('beforeInit', myCallback, hotInstance);\n   * ```\n   */\n  once(key, callback) {\n    let context = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;\n    let orderIndex = arguments.length > 3 ? arguments[3] : undefined;\n    if (Array.isArray(callback)) {\n      arrayEach(callback, c => this.once(key, c, context));\n    } else {\n      callback.runOnce = true;\n      this.add(key, callback, context, orderIndex);\n    }\n  }\n\n  /**\n   * Removes a listener from a hook with a given name. If the `context` argument is provided, it removes a listener from a local hook assigned to the given Handsontable instance.\n   *\n   * @see Core#removeHook\n   * @param {string} key Hook/Event name.\n   * @param {Function} callback Callback function (needs the be the function that was previously added to the hook).\n   * @param {object} [context=null] Handsontable instance.\n   * @returns {boolean} Returns `true` if hook was removed, `false` otherwise.\n   *\n   * @example\n   * ```js\n   * Handsontable.hooks.remove('beforeInit', myCallback);\n   * ```\n   */\n  remove(key, callback) {\n    let context = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;\n    const bucket = this.getBucket(context);\n    if (typeof bucket[key] !== 'undefined') {\n      if (bucket[key].indexOf(callback) >= 0) {\n        callback.skip = true;\n        return true;\n      }\n    }\n    return false;\n  }\n\n  /**\n   * Checks whether there are any registered listeners for the provided hook name.\n   * If the `context` parameter is provided, it only checks for listeners assigned to the given Handsontable instance.\n   *\n   * @param {string} key Hook name.\n   * @param {object} [context=null] A Handsontable instance.\n   * @returns {boolean} `true` for success, `false` otherwise.\n   */\n  has(key) {\n    let context = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n    const bucket = this.getBucket(context);\n    return !!(bucket[key] !== undefined && bucket[key].length);\n  }\n\n  /**\n   * Runs all local and global callbacks assigned to the hook identified by the `key` parameter.\n   * It returns either a return value from the last called callback or the first parameter (`p1`) passed to the `run` function.\n   *\n   * @see Core#runHooks\n   * @param {object} context Handsontable instance.\n   * @param {string} key Hook/Event name.\n   * @param {*} [p1] Parameter to be passed as an argument to the callback function.\n   * @param {*} [p2] Parameter to be passed as an argument to the callback function.\n   * @param {*} [p3] Parameter to be passed as an argument to the callback function.\n   * @param {*} [p4] Parameter to be passed as an argument to the callback function.\n   * @param {*} [p5] Parameter to be passed as an argument to the callback function.\n   * @param {*} [p6] Parameter to be passed as an argument to the callback function.\n   * @returns {*} Either a return value from the last called callback or `p1`.\n   *\n   * @example\n   * ```js\n   * Handsontable.hooks.run(hot, 'beforeInit');\n   * ```\n   */\n  run(context, key, p1, p2, p3, p4, p5, p6) {\n    {\n      const globalHandlers = this.globalBucket[key];\n      const length = globalHandlers ? globalHandlers.length : 0;\n      let index = 0;\n      if (length) {\n        // Do not optimise this loop with arrayEach or arrow function! If you do You'll decrease perf because of GC.\n        while (index < length) {\n          if (!globalHandlers[index] || globalHandlers[index].skip) {\n            index += 1;\n            /* eslint-disable no-continue */\n            continue;\n          }\n          const res = fastCall(globalHandlers[index], context, p1, p2, p3, p4, p5, p6);\n          if (res !== undefined) {\n            // eslint-disable-next-line no-param-reassign\n            p1 = res;\n          }\n          if (globalHandlers[index] && globalHandlers[index].runOnce) {\n            this.remove(key, globalHandlers[index]);\n          }\n          index += 1;\n        }\n      }\n    }\n    {\n      const localHandlers = this.getBucket(context)[key];\n      const length = localHandlers ? localHandlers.length : 0;\n      let index = 0;\n      if (length) {\n        // Do not optimise this loop with arrayEach or arrow function! If you do You'll decrease perf because of GC.\n        while (index < length) {\n          if (!localHandlers[index] || localHandlers[index].skip) {\n            index += 1;\n            /* eslint-disable no-continue */\n            continue;\n          }\n          const res = fastCall(localHandlers[index], context, p1, p2, p3, p4, p5, p6);\n          if (res !== undefined) {\n            // eslint-disable-next-line no-param-reassign\n            p1 = res;\n          }\n          if (localHandlers[index] && localHandlers[index].runOnce) {\n            this.remove(key, localHandlers[index], context);\n          }\n          index += 1;\n        }\n      }\n    }\n    return p1;\n  }\n\n  /**\n   * Destroy all listeners connected to the context. If no context is provided, the global listeners will be destroyed.\n   *\n   * @param {object} [context=null] A Handsontable instance.\n   * @example\n   * ```js\n   * // destroy the global listeners\n   * Handsontable.hooks.destroy();\n   *\n   * // destroy the local listeners\n   * Handsontable.hooks.destroy(hotInstance);\n   * ```\n   */\n  destroy() {\n    let context = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;\n    // eslint-disable-next-line no-return-assign\n    objectEach(this.getBucket(context), (value, key, bucket) => bucket[key].length = 0);\n  }\n\n  /**\n   * Registers a hook name (adds it to the list of the known hook names). Used by plugins.\n   * It is not necessary to call register, but if you use it, your plugin hook will be used returned by\n   * the `getRegistered` method. (which itself is used in the [demo](@/guides/getting-started/events-and-hooks/events-and-hooks.md)).\n   *\n   * @param {string} key The hook name.\n   *\n   * @example\n   * ```js\n   * Handsontable.hooks.register('myHook');\n   * ```\n   */\n  register(key) {\n    if (!this.isRegistered(key)) {\n      REGISTERED_HOOKS.push(key);\n    }\n  }\n\n  /**\n   * Deregisters a hook name (removes it from the list of known hook names).\n   *\n   * @param {string} key The hook name.\n   *\n   * @example\n   * ```js\n   * Handsontable.hooks.deregister('myHook');\n   * ```\n   */\n  deregister(key) {\n    if (this.isRegistered(key)) {\n      REGISTERED_HOOKS.splice(REGISTERED_HOOKS.indexOf(key), 1);\n    }\n  }\n\n  /**\n   * Returns a boolean value depending on if a hook by such name has been removed or deprecated.\n   *\n   * @param {string} hookName The hook name to check.\n   * @returns {boolean} Returns `true` if the provided hook name was marked as deprecated or\n   * removed from API, `false` otherwise.\n   * @example\n   * ```js\n   * Handsontable.hooks.isDeprecated('skipLengthCache');\n   *\n   * // Results:\n   * true\n   * ```\n   */\n  isDeprecated(hookName) {\n    return DEPRECATED_HOOKS.has(hookName) || REMOVED_HOOKS.has(hookName);\n  }\n\n  /**\n   * Returns a boolean depending on if a hook by such name has been registered.\n   *\n   * @param {string} hookName The hook name to check.\n   * @returns {boolean} `true` for success, `false` otherwise.\n   * @example\n   * ```js\n   * Handsontable.hooks.isRegistered('beforeInit');\n   *\n   * // Results:\n   * true\n   * ```\n   */\n  isRegistered(hookName) {\n    return REGISTERED_HOOKS.indexOf(hookName) >= 0;\n  }\n\n  /**\n   * Returns an array of registered hooks.\n   *\n   * @returns {Array} An array of registered hooks.\n   *\n   * @example\n   * ```js\n   * Handsontable.hooks.getRegistered();\n   *\n   * // Results:\n   * [\n   * ...\n   *   'beforeInit',\n   *   'beforeRender',\n   *   'beforeSetRangeEnd',\n   *   'beforeDrawBorders',\n   *   'beforeChange',\n   * ...\n   * ]\n   * ```\n   */\n  getRegistered() {\n    return REGISTERED_HOOKS;\n  }\n\n  /**\n   * Sets the order index of the callback in the bucket object.\n   *\n   * @private\n   * @param {object} bucket The bucket object.\n   * @param {string} key Hook name.\n   * @param {Function} callback Callback function.\n   * @param {number|undefined} orderIndex Order index of the callback.\n   */\n  setCallbackOrderIndex(bucket, key, callback, orderIndex) {\n    const normalizedOrderIndex = Number.isInteger(orderIndex) ? orderIndex : 0;\n    const orderMap = this.getCallbackOrderMap(bucket, key);\n    orderMap.set(normalizedOrderIndex, [...(orderMap.get(normalizedOrderIndex) || []), callback]);\n  }\n\n  /**\n   * Reorders the callbacks in the bucket object by their order index.\n   *\n   * @private\n   * @param {objcet} bucket The bucket object.\n   * @param {string} key Hook name.\n   */\n  orderBucketByOrderIndex(bucket, key) {\n    const orderMap = this.getCallbackOrderMap(bucket, key);\n    if (orderMap === undefined || orderMap.size === 0 || orderMap.size === 1 && orderMap.has(0)) {\n      return;\n    }\n    bucket[key] = [...orderMap].sort((a, b) => a[0] - b[0]).flatMap(_ref => {\n      let [, callbacks] = _ref;\n      return callbacks;\n    });\n  }\n\n  /**\n   * Extends the bucket object with the order property.\n   *\n   * @private\n   * @param {object} bucket The bucket object.\n   * @param {string} hook The hook name.\n   */\n  initOrderMap(bucket, hook) {\n    if (!callbackOrder.has(bucket)) {\n      callbackOrder.set(bucket, []);\n    }\n    callbackOrder.get(bucket)[hook] = new Map();\n  }\n\n  /**\n   * Returns the order map for the provided hook.\n   *\n   * @private\n   * @param {object} bucket The bucket object.\n   * @param {string} hook The hook name.\n   * @returns {Map<number, Array<Function>>} Returns the order map for the provided hook.\n   */\n  getCallbackOrderMap(bucket, hook) {\n    return callbackOrder.get(bucket)[hook];\n  }\n}\nconst globalSingleton = new Hooks();\n\n/**\n * @returns {Hooks}\n */\nfunction getGlobalSingleton() {\n  return globalSingleton;\n}\nexport default Hooks;","import \"core-js/modules/es.error.cause.js\";\nfunction _classPrivateMethodInitSpec(e, a) { _checkPrivateRedeclaration(e, a), a.add(e); }\nfunction _checkPrivateRedeclaration(e, t) { if (t.has(e)) throw new TypeError(\"Cannot initialize the same private elements twice on an object\"); }\nfunction _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == typeof i ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != typeof t || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != typeof i) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\nfunction _assertClassBrand(e, t, n) { if (\"function\" == typeof e ? e === t : e.has(t)) return arguments.length < 3 ? t : n; throw new TypeError(\"Private element is not present on this object\"); }\nimport { BasePlugin } from \"../base/index.mjs\";\nimport { objectEach } from \"../../helpers/object.mjs\";\nimport Endpoints from \"./endpoints.mjs\";\nimport { toSingleLine } from \"../../helpers/templateLiteralTag.mjs\";\nimport { isNullishOrNaN } from \"./utils.mjs\";\nexport const PLUGIN_KEY = 'columnSummary';\nexport const PLUGIN_PRIORITY = 220;\n\n/* eslint-disable jsdoc/require-description-complete-sentence */\n\n/**\n * @plugin ColumnSummary\n * @class ColumnSummary\n *\n * @description\n * The `ColumnSummary` plugin lets you [easily summarize your columns](@/guides/columns/column-summary/column-summary.md).\n *\n * You can use the [built-in summary functions](@/guides/columns/column-summary/column-summary.md#built-in-summary-functions),\n * or implement a [custom summary function](@/guides/columns/column-summary/column-summary.md#implement-a-custom-summary-function).\n *\n * For each column summary, you can set the following configuration options:\n *\n * | Option | Required | Type | Default | Description |\n * |---|---|---|---|---|\n * | `sourceColumn` | No | Number | Same as `destinationColumn` | [Selects a column to summarize](@/guides/columns/column-summary/column-summary.md#step-2-select-cells-that-you-want-to-summarize) |\n * | `ranges` | No | Array | - | [Selects ranges of rows to summarize](@/guides/columns/column-summary/column-summary.md#step-2-select-cells-that-you-want-to-summarize) |\n * | `type` | Yes | String | - | [Sets a summary function](@/guides/columns/column-summary/column-summary.md#step-3-calculate-your-summary) |\n * | `destinationRow` | Yes | Number | - | [Sets the destination cell's row coordinate](@/guides/columns/column-summary/column-summary.md#step-4-provide-the-destination-cell-s-coordinates) |\n * | `destinationColumn` | Yes | Number | - | [Sets the destination cell's column coordinate](@/guides/columns/column-summary/column-summary.md#step-4-provide-the-destination-cell-s-coordinates) |\n * | `forceNumeric` | No | Boolean | `false` | [Forces the summary to treat non-numerics as numerics](@/guides/columns/column-summary/column-summary.md#force-numeric-values) |\n * | `reversedRowCoords` | No | Boolean | `false` | [Reverses row coordinates](@/guides/columns/column-summary/column-summary.md#step-5-make-room-for-the-destination-cell) |\n * | `suppressDataTypeErrors` | No | Boolean | `true` | [Suppresses data type errors](@/guides/columns/column-summary/column-summary.md#throw-data-type-errors) |\n * | `readOnly` | No | Boolean | `true` | Makes summary cell read-only |\n * | `roundFloat` | No | Number/<br>Boolean | - | [Rounds summary result](@/guides/columns/column-summary/column-summary.md#round-a-column-summary-result) |\n * | `customFunction` | No | Function | - | [Lets you add a custom summary function](@/guides/columns/column-summary/column-summary.md#implement-a-custom-summary-function) |\n *\n * @example\n * ::: only-for javascript\n * ```js\n * const container = document.getElementById('example');\n * const hot = new Handsontable(container, {\n *   data: getData(),\n *   colHeaders: true,\n *   rowHeaders: true,\n *   columnSummary: [\n *     {\n *       type: 'min',\n *       destinationRow: 4,\n *       destinationColumn: 1,\n *     },\n *     {\n *       type: 'max',\n *       destinationRow: 0,\n *       destinationColumn: 3,\n *       reversedRowCoords: true\n *     },\n *     {\n *       type: 'sum',\n *       destinationRow: 4,\n *       destinationColumn: 5,\n *       forceNumeric: true\n *     }\n *   ]\n * });\n * ```\n * :::\n *\n * ::: only-for react\n * ```jsx\n * <HotTable\n *   data={getData()}\n *   colHeaders={true}\n *   rowHeaders={true}\n *   columnSummary={[\n *     {\n *       type: 'min',\n *       destinationRow: 4,\n *       destinationColumn: 1,\n *     },\n *     {\n *       type: 'max',\n *       destinationRow: 0,\n *       destinationColumn: 3,\n *       reversedRowCoords: true\n *     },\n *     {\n *       type: 'sum',\n *       destinationRow: 4,\n *       destinationColumn: 5,\n *       forceNumeric: true\n *     }\n *   ]}\n * />\n * ```\n * :::\n */\nvar _ColumnSummary_brand = /*#__PURE__*/new WeakSet();\nexport class ColumnSummary extends BasePlugin {\n  constructor() {\n    super(...arguments);\n    /**\n     * `afterInit` hook callback.\n     */\n    _classPrivateMethodInitSpec(this, _ColumnSummary_brand);\n    /**\n     * The Endpoints class instance. Used to make all endpoint-related operations.\n     *\n     * @private\n     * @type {null|Endpoints}\n     */\n    _defineProperty(this, \"endpoints\", null);\n  }\n  static get PLUGIN_KEY() {\n    return PLUGIN_KEY;\n  }\n  static get PLUGIN_PRIORITY() {\n    return PLUGIN_PRIORITY;\n  }\n  /**\n   * Checks if the plugin is enabled in the handsontable settings. This method is executed in {@link Hooks#beforeInit}\n   * hook and if it returns `true` then the {@link ColumnSummary#enablePlugin} method is called.\n   *\n   * @returns {boolean}\n   */\n  isEnabled() {\n    return !!this.hot.getSettings()[PLUGIN_KEY];\n  }\n\n  /**\n   * Enables the plugin functionality for this Handsontable instance.\n   */\n  enablePlugin() {\n    var _this = this;\n    if (this.enabled) {\n      return;\n    }\n    this.settings = this.hot.getSettings()[PLUGIN_KEY];\n    this.endpoints = new Endpoints(this, this.settings);\n    this.addHook('afterInit', function () {\n      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n        args[_key] = arguments[_key];\n      }\n      return _assertClassBrand(_ColumnSummary_brand, _this, _onAfterInit).call(_this, ...args);\n    });\n    this.addHook('afterChange', function () {\n      for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n        args[_key2] = arguments[_key2];\n      }\n      return _assertClassBrand(_ColumnSummary_brand, _this, _onAfterChange).call(_this, ...args);\n    });\n    this.addHook('afterUpdateSettings', function () {\n      for (var _len3 = arguments.length, args = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {\n        args[_key3] = arguments[_key3];\n      }\n      return _assertClassBrand(_ColumnSummary_brand, _this, _onAfterUpdateSettings).call(_this, ...args);\n    });\n    this.addHook('beforeCreateRow', (index, amount, source) => this.endpoints.resetSetupBeforeStructureAlteration('insert_row', index, amount, null, source)); // eslint-disable-line max-len\n    this.addHook('beforeCreateCol', (index, amount, source) => this.endpoints.resetSetupBeforeStructureAlteration('insert_col', index, amount, null, source)); // eslint-disable-line max-len\n    this.addHook('beforeRemoveRow', function () {\n      for (var _len4 = arguments.length, args = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {\n        args[_key4] = arguments[_key4];\n      }\n      return _this.endpoints.resetSetupBeforeStructureAlteration('remove_row', ...args);\n    });\n    this.addHook('beforeRemoveCol', function () {\n      for (var _len5 = arguments.length, args = new Array(_len5), _key5 = 0; _key5 < _len5; _key5++) {\n        args[_key5] = arguments[_key5];\n      }\n      return _this.endpoints.resetSetupBeforeStructureAlteration('remove_col', ...args);\n    });\n    this.addHook('afterCreateRow', (index, amount, source) => this.endpoints.resetSetupAfterStructureAlteration('insert_row', index, amount, null, source)); // eslint-disable-line max-len\n    this.addHook('afterCreateCol', (index, amount, source) => this.endpoints.resetSetupAfterStructureAlteration('insert_col', index, amount, null, source)); // eslint-disable-line max-len\n    this.addHook('afterRemoveRow', function () {\n      for (var _len6 = arguments.length, args = new Array(_len6), _key6 = 0; _key6 < _len6; _key6++) {\n        args[_key6] = arguments[_key6];\n      }\n      return _this.endpoints.resetSetupAfterStructureAlteration('remove_row', ...args);\n    });\n    this.addHook('afterRemoveCol', function () {\n      for (var _len7 = arguments.length, args = new Array(_len7), _key7 = 0; _key7 < _len7; _key7++) {\n        args[_key7] = arguments[_key7];\n      }\n      return _this.endpoints.resetSetupAfterStructureAlteration('remove_col', ...args);\n    });\n    this.addHook('afterRowMove', function () {\n      for (var _len8 = arguments.length, args = new Array(_len8), _key8 = 0; _key8 < _len8; _key8++) {\n        args[_key8] = arguments[_key8];\n      }\n      return _assertClassBrand(_ColumnSummary_brand, _this, _onAfterRowMove).call(_this, ...args);\n    });\n    super.enablePlugin();\n  }\n\n  /**\n   * Disables the plugin functionality for this Handsontable instance.\n   */\n  disablePlugin() {\n    this.endpoints = null;\n    this.settings = null;\n    this.currentEndpoint = null;\n    super.disablePlugin();\n  }\n\n  /**\n   * Updates the plugin's state.\n   *\n   * This method is executed when [`updateSettings()`](@/api/core.md#updatesettings) is invoked with any of the following configuration options:\n   *  - [`columnSummary`](@/api/options.md#columnsummary)\n   */\n  updatePlugin() {\n    this.disablePlugin();\n    this.enablePlugin();\n    this.endpoints.initEndpoints();\n    super.updatePlugin();\n  }\n\n  /**\n   * Calculates math for a single endpoint.\n   *\n   * @private\n   * @param {object} endpoint Contains information about the endpoint.\n   */\n  calculate(endpoint) {\n    switch (endpoint.type.toLowerCase()) {\n      case 'sum':\n        endpoint.result = this.calculateSum(endpoint);\n        break;\n      case 'min':\n        endpoint.result = this.calculateMinMax(endpoint, endpoint.type);\n        break;\n      case 'max':\n        endpoint.result = this.calculateMinMax(endpoint, endpoint.type);\n        break;\n      case 'count':\n        endpoint.result = this.countEntries(endpoint);\n        break;\n      case 'average':\n        endpoint.result = this.calculateAverage(endpoint);\n        break;\n      case 'custom':\n        endpoint.result = endpoint.customFunction.call(this, endpoint);\n        break;\n      default:\n        break;\n    }\n  }\n\n  /**\n   * Calculates sum of the values contained in ranges provided in the plugin config.\n   *\n   * @private\n   * @param {object} endpoint Contains the endpoint information.\n   * @returns {number} Sum for the selected range.\n   */\n  calculateSum(endpoint) {\n    let sum = 0;\n    objectEach(endpoint.ranges, range => {\n      sum += this.getPartialSum(range, endpoint.sourceColumn);\n    });\n    return sum;\n  }\n\n  /**\n   * Returns partial sum of values from a single row range.\n   *\n   * @private\n   * @param {Array} rowRange Range for the sum.\n   * @param {number} col Column index.\n   * @returns {number} The partial sum.\n   */\n  getPartialSum(rowRange, col) {\n    let sum = 0;\n    let i = rowRange[1] || rowRange[0];\n    let cellValue = null;\n    let biggestDecimalPlacesCount = 0;\n    do {\n      cellValue = this.getCellValue(i, col);\n      cellValue = isNullishOrNaN(cellValue) ? null : cellValue;\n      if (cellValue !== null) {\n        const decimalPlaces = (`${cellValue}`.split('.')[1] || []).length || 1;\n        if (decimalPlaces > biggestDecimalPlacesCount) {\n          biggestDecimalPlacesCount = decimalPlaces;\n        }\n      }\n      sum += cellValue || 0;\n      i -= 1;\n    } while (i >= rowRange[0]);\n\n    // Workaround for e.g. 802.2 + 1.1 = 803.3000000000001\n    return Math.round(sum * 10 ** biggestDecimalPlacesCount) / 10 ** biggestDecimalPlacesCount;\n  }\n\n  /**\n   * Calculates the minimal value for the selected ranges.\n   *\n   * @private\n   * @param {object} endpoint Contains the endpoint information.\n   * @param {string} type `'min'` or `'max'`.\n   * @returns {number} Min or Max value.\n   */\n  calculateMinMax(endpoint, type) {\n    let result = null;\n    objectEach(endpoint.ranges, range => {\n      const partialResult = this.getPartialMinMax(range, endpoint.sourceColumn, type);\n      if (result === null && partialResult !== null) {\n        result = partialResult;\n      }\n      if (partialResult !== null) {\n        switch (type) {\n          case 'min':\n            result = Math.min(result, partialResult);\n            break;\n          case 'max':\n            result = Math.max(result, partialResult);\n            break;\n          default:\n            break;\n        }\n      }\n    });\n    return result === null ? 'Not enough data' : result;\n  }\n\n  /**\n   * Returns a local minimum of the provided sub-range.\n   *\n   * @private\n   * @param {Array} rowRange Range for the calculation.\n   * @param {number} col Column index.\n   * @param {string} type `'min'` or `'max'`.\n   * @returns {number|null} Min or max value.\n   */\n  getPartialMinMax(rowRange, col, type) {\n    let result = null;\n    let i = rowRange[1] || rowRange[0];\n    let cellValue;\n    do {\n      cellValue = this.getCellValue(i, col);\n      cellValue = isNullishOrNaN(cellValue) ? null : cellValue;\n      if (result === null) {\n        result = cellValue;\n      } else if (cellValue !== null) {\n        switch (type) {\n          case 'min':\n            result = Math.min(result, cellValue);\n            break;\n          case 'max':\n            result = Math.max(result, cellValue);\n            break;\n          default:\n            break;\n        }\n      }\n      i -= 1;\n    } while (i >= rowRange[0]);\n    return result;\n  }\n\n  /**\n   * Counts empty cells in the provided row range.\n   *\n   * @private\n   * @param {Array} rowRange Row range for the calculation.\n   * @param {number} col Column index.\n   * @returns {number} Empty cells count.\n   */\n  countEmpty(rowRange, col) {\n    let cellValue;\n    let counter = 0;\n    let i = rowRange[1] || rowRange[0];\n    do {\n      cellValue = this.getCellValue(i, col);\n      cellValue = isNullishOrNaN(cellValue) ? null : cellValue;\n      if (cellValue === null) {\n        counter += 1;\n      }\n      i -= 1;\n    } while (i >= rowRange[0]);\n    return counter;\n  }\n\n  /**\n   * Counts non-empty cells in the provided row range.\n   *\n   * @private\n   * @param {object} endpoint Contains the endpoint information.\n   * @returns {number} Entry count.\n   */\n  countEntries(endpoint) {\n    let result = 0;\n    const ranges = endpoint.ranges;\n    objectEach(ranges, range => {\n      const partial = range[1] === undefined ? 1 : range[1] - range[0] + 1;\n      const emptyCount = this.countEmpty(range, endpoint.sourceColumn);\n      result += partial;\n      result -= emptyCount;\n    });\n    return result;\n  }\n\n  /**\n   * Calculates the average value from the cells in the range.\n   *\n   * @private\n   * @param {object} endpoint Contains the endpoint information.\n   * @returns {number} Avarage value.\n   */\n  calculateAverage(endpoint) {\n    const sum = this.calculateSum(endpoint);\n    const entriesCount = this.countEntries(endpoint);\n    return sum / entriesCount;\n  }\n\n  /**\n   * Returns a cell value, taking into consideration a basic validation.\n   *\n   * @private\n   * @param {number} row Row index.\n   * @param {number} col Column index.\n   * @returns {string} The cell value.\n   */\n  getCellValue(row, col) {\n    const visualRowIndex = this.hot.toVisualRow(row);\n    const visualColumnIndex = this.hot.toVisualColumn(col);\n    let cellValue = this.hot.getSourceDataAtCell(row, col);\n    let cellClassName = '';\n    if (visualRowIndex !== null && visualColumnIndex !== null) {\n      cellClassName = this.hot.getCellMeta(visualRowIndex, visualColumnIndex).className || '';\n    }\n    if (cellClassName.indexOf('columnSummaryResult') > -1) {\n      return null;\n    }\n    if (this.endpoints.currentEndpoint.forceNumeric) {\n      if (typeof cellValue === 'string') {\n        cellValue = cellValue.replace(/,/, '.');\n      }\n      cellValue = parseFloat(cellValue);\n    }\n    if (isNaN(cellValue)) {\n      if (!this.endpoints.currentEndpoint.suppressDataTypeErrors) {\n        throw new Error(toSingleLine`ColumnSummary plugin: cell at (${row}, ${col}) is not in a\\x20\n          numeric format. Cannot do the calculation.`);\n      }\n    }\n    return cellValue;\n  }\n}\nfunction _onAfterInit() {\n  this.endpoints.initEndpoints();\n}\n/**\n * Called after the settings were updated. There is a need to refresh cell metas after the settings update with\n * the `columns` property as the Core resets the cell metas to their initial state.\n *\n * @param {object} settings The settings object.\n */\nfunction _onAfterUpdateSettings(settings) {\n  if (settings.columns !== undefined) {\n    this.endpoints.refreshCellMetas();\n  }\n}\n/**\n * `afterChange` hook callback.\n *\n * @param {Array} changes 2D array containing information about each of the edited cells.\n * @param {string} source The string that identifies source of changes.\n */\nfunction _onAfterChange(changes, source) {\n  if (changes && source !== 'ColumnSummary.reset' && source !== 'ColumnSummary.set' && source !== 'loadData') {\n    this.endpoints.refreshChangedEndpoints(changes);\n  }\n}\n/**\n * `beforeRowMove` hook callback.\n *\n * @param {Array} rows Array of visual row indexes to be moved.\n * @param {number} finalIndex Visual row index, being a start index for the moved rows. Points to where the elements will be placed after the moving action.\n * To check the visualization of the final index, please take a look at [documentation](@/guides/rows/row-moving/row-moving.md).\n */\nfunction _onAfterRowMove(rows, finalIndex) {\n  this.endpoints.resetSetupBeforeStructureAlteration('move_row', rows[0], rows.length, rows, this.pluginName);\n  this.endpoints.resetSetupAfterStructureAlteration('move_row', finalIndex, rows.length, rows, this.pluginName);\n}","import \"core-js/modules/es.error.cause.js\";\nimport \"core-js/modules/es.array.push.js\";\nfunction _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == typeof i ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != typeof t || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != typeof i) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\nimport { arrayEach, arrayMap, arrayReduce } from \"../../helpers/array.mjs\";\nimport { mixin } from \"../../helpers/object.mjs\";\nimport { toSingleLine } from \"../../helpers/templateLiteralTag.mjs\";\nimport localHooks from \"../../mixins/localHooks.mjs\";\nimport { getCondition } from \"./conditionRegisterer.mjs\";\nimport { OPERATION_ID as OPERATION_AND } from \"./logicalOperations/conjunction.mjs\";\nimport { operations, getOperationFunc } from \"./logicalOperationRegisterer.mjs\";\nimport { isUndefined } from \"../../helpers/mixed.mjs\";\nimport { LinkedPhysicalIndexToValueMap as IndexToValueMap } from \"../../translations/index.mjs\";\nconst MAP_NAME = 'ConditionCollection.filteringStates';\n\n/**\n * @private\n * @class ConditionCollection\n */\nclass ConditionCollection {\n  constructor(hot) {\n    let isMapRegistrable = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n    /**\n     * Handsontable instance.\n     *\n     * @type {Core}\n     */\n    _defineProperty(this, \"hot\", void 0);\n    /**\n     * Indicates whether the internal IndexMap should be registered or not. Generally,\n     * registered Maps responds to the index changes. Within that collection, sometimes\n     * this is not necessary.\n     *\n     * @type {boolean}\n     */\n    _defineProperty(this, \"isMapRegistrable\", void 0);\n    /**\n     * Index map storing filtering states for every column. ConditionCollection write and read to/from element.\n     *\n     * @type {LinkedPhysicalIndexToValueMap}\n     */\n    _defineProperty(this, \"filteringStates\", new IndexToValueMap());\n    /**\n     * Stores the previous state of the condition stack before the latest filter operation.\n     * This is used in the `beforeFilter` plugin to allow performing the undo operation.\n     *\n     * @type {null|Array}\n     */\n    _defineProperty(this, \"previousConditionStack\", null);\n    this.hot = hot;\n    this.isMapRegistrable = isMapRegistrable;\n    if (this.isMapRegistrable === true) {\n      this.hot.columnIndexMapper.registerMap(MAP_NAME, this.filteringStates);\n    } else {\n      this.filteringStates.init(this.hot.columnIndexMapper.getNumberOfIndexes());\n    }\n  }\n\n  /**\n   * Check if condition collection is empty (so no needed to filter data).\n   *\n   * @returns {boolean}\n   */\n  isEmpty() {\n    return this.getFilteredColumns().length === 0;\n  }\n\n  /**\n   * Check if value is matched to the criteria of conditions chain.\n   *\n   * @param {object} value Object with `value` and `meta` keys.\n   * @param {number} column The physical column index.\n   * @returns {boolean}\n   */\n  isMatch(value, column) {\n    var _stateForColumn$condi;\n    const stateForColumn = this.filteringStates.getValueAtIndex(column);\n    const conditions = (_stateForColumn$condi = stateForColumn === null || stateForColumn === void 0 ? void 0 : stateForColumn.conditions) !== null && _stateForColumn$condi !== void 0 ? _stateForColumn$condi : [];\n    const operation = stateForColumn === null || stateForColumn === void 0 ? void 0 : stateForColumn.operation;\n    return this.isMatchInConditions(conditions, value, operation);\n  }\n\n  /**\n   * Check if the value is matches the conditions.\n   *\n   * @param {Array} conditions List of conditions.\n   * @param {object} value Object with `value` and `meta` keys.\n   * @param {string} [operationType='conjunction'] Type of conditions operation.\n   * @returns {boolean}\n   */\n  isMatchInConditions(conditions, value) {\n    let operationType = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : OPERATION_AND;\n    if (conditions.length) {\n      return getOperationFunc(operationType)(conditions, value);\n    }\n    return true;\n  }\n\n  /**\n   * Add condition to the collection.\n   *\n   * @param {number} column The physical column index.\n   * @param {object} conditionDefinition Object with keys:\n   *  * `command` Object, Command object with condition name as `key` property.\n   *  * `args` Array, Condition arguments.\n   * @param {string} [operation='conjunction'] Type of conditions operation.\n   * @param {number} [position] Position to which condition will be added. When argument is undefined\n   * the condition will be processed as the last condition.\n   * @fires ConditionCollection#beforeAdd\n   * @fires ConditionCollection#afterAdd\n   */\n  addCondition(column, conditionDefinition) {\n    let operation = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : OPERATION_AND;\n    let position = arguments.length > 3 ? arguments[3] : undefined;\n    const localeForColumn = this.hot.getCellMeta(0, column).locale;\n    const args = arrayMap(conditionDefinition.args, v => typeof v === 'string' ? v.toLocaleLowerCase(localeForColumn) : v);\n    const name = conditionDefinition.name || conditionDefinition.command.key;\n\n    // If there's no previous condition stack defined (which means the condition stack was not cleared after the\n    // previous filter operation or that there was no filter operation performed yet), store the current conditions as\n    // the previous condition stack.\n    if (this.previousConditionStack === null) {\n      this.setPreviousConditionStack(this.exportAllConditions());\n    }\n    this.runLocalHooks('beforeAdd', column);\n    const columnType = this.getOperation(column);\n    if (columnType) {\n      if (columnType !== operation) {\n        throw Error(toSingleLine`The column of index ${column} has been already applied with a \\`${columnType}\\`\\x20\n        filter operation. Use \\`removeConditions\\` to clear the current conditions and then add new ones.\\x20\n        Mind that you cannot mix different types of operations (for instance, if you use \\`conjunction\\`,\\x20\n        use it consequently for a particular column).`);\n      }\n    } else if (isUndefined(operations[operation])) {\n      throw new Error(toSingleLine`Unexpected operation named \\`${operation}\\`. Possible ones are\\x20\n        \\`disjunction\\` and \\`conjunction\\`.`);\n    }\n    const conditionsForColumn = this.getConditions(column);\n    if (conditionsForColumn.length === 0) {\n      // Create first condition for particular column.\n      this.filteringStates.setValueAtIndex(column, {\n        operation,\n        conditions: [{\n          name,\n          args,\n          func: getCondition(name, args)\n        }]\n      }, position);\n    } else {\n      // Add next condition for particular column (by reference).\n      conditionsForColumn.push({\n        name,\n        args,\n        func: getCondition(name, args)\n      });\n    }\n    this.runLocalHooks('afterAdd', column);\n  }\n\n  /**\n   * Get all added conditions from the collection at specified column index.\n   *\n   * @param {number} column The physical column index.\n   * @returns {Array} Returns conditions collection as an array.\n   */\n  getConditions(column) {\n    var _this$filteringStates, _this$filteringStates2;\n    return (_this$filteringStates = (_this$filteringStates2 = this.filteringStates.getValueAtIndex(column)) === null || _this$filteringStates2 === void 0 ? void 0 : _this$filteringStates2.conditions) !== null && _this$filteringStates !== void 0 ? _this$filteringStates : [];\n  }\n\n  /**\n   * Get operation for particular column.\n   *\n   * @param {number} column The physical column index.\n   * @returns {string|undefined}\n   */\n  getOperation(column) {\n    var _this$filteringStates3;\n    return (_this$filteringStates3 = this.filteringStates.getValueAtIndex(column)) === null || _this$filteringStates3 === void 0 ? void 0 : _this$filteringStates3.operation;\n  }\n\n  /**\n   * Get all filtered physical columns in the order in which actions are performed.\n   *\n   * @returns {Array}\n   */\n  getFilteredColumns() {\n    return this.filteringStates.getEntries().map(_ref => {\n      let [physicalColumn] = _ref;\n      return physicalColumn;\n    });\n  }\n\n  /**\n   * Gets position in the filtering states stack for the specific column.\n   *\n   * @param {number} column The physical column index.\n   * @returns {number} Returns -1 when the column doesn't exist in the stack.\n   */\n  getColumnStackPosition(column) {\n    return this.getFilteredColumns().indexOf(column);\n  }\n\n  /**\n   * Export all previously added conditions.\n   *\n   * @returns {Array}\n   */\n  exportAllConditions() {\n    return arrayReduce(this.filteringStates.getEntries(), (allConditions, _ref2) => {\n      let [column, {\n        operation,\n        conditions\n      }] = _ref2;\n      allConditions.push({\n        column,\n        operation,\n        conditions: arrayMap(conditions, _ref3 => {\n          let {\n            name,\n            args\n          } = _ref3;\n          return {\n            name,\n            args\n          };\n        })\n      });\n      return allConditions;\n    }, []);\n  }\n\n  /**\n   * Import conditions to the collection.\n   *\n   * @param {Array} conditions The collection of the conditions.\n   */\n  importAllConditions(conditions) {\n    this.clean();\n    arrayEach(conditions, stack => {\n      arrayEach(stack.conditions, condition => this.addCondition(stack.column, condition));\n    });\n  }\n\n  /**\n   * Remove conditions at given column index.\n   *\n   * @param {number} column The physical column index.\n   * @fires ConditionCollection#beforeRemove\n   * @fires ConditionCollection#afterRemove\n   */\n  removeConditions(column) {\n    // Store the current conditions as the previous condition stack before it's cleared.\n    this.setPreviousConditionStack(this.exportAllConditions());\n    this.runLocalHooks('beforeRemove', column);\n    this.filteringStates.clearValue(column);\n    this.runLocalHooks('afterRemove', column);\n  }\n\n  /**\n   * Clean all conditions collection and reset order stack.\n   *\n   * @fires ConditionCollection#beforeClean\n   * @fires ConditionCollection#afterClean\n   */\n  clean() {\n    this.runLocalHooks('beforeClean');\n    this.filteringStates.clear();\n    this.runLocalHooks('afterClean');\n  }\n\n  /**\n   * Check if at least one condition was added at specified column index. And if second parameter is passed then additionally\n   * check if condition exists under its name.\n   *\n   * @param {number} column The physical column index.\n   * @param {string} [name] Condition name.\n   * @returns {boolean}\n   */\n  hasConditions(column, name) {\n    const conditions = this.getConditions(column);\n    if (name) {\n      return conditions.some(condition => condition.name === name);\n    }\n    return conditions.length > 0;\n  }\n\n  /**\n   * Updates the `previousConditionStack` property with the provided stack.\n   * It is used to store the current conditions before they are modified, allowing for undo operations.\n   *\n   * @param {Array|null} previousConditionStack The stack of previous conditions.\n   */\n  setPreviousConditionStack(previousConditionStack) {\n    this.previousConditionStack = previousConditionStack;\n  }\n\n  /**\n   * Destroy object.\n   */\n  destroy() {\n    if (this.isMapRegistrable) {\n      this.hot.columnIndexMapper.unregisterMap(MAP_NAME);\n    }\n    this.filteringStates = null;\n    this.clearLocalHooks();\n  }\n}\nmixin(ConditionCollection, localHooks);\nexport default ConditionCollection;","import \"core-js/modules/es.error.cause.js\";\nimport \"core-js/modules/es.array.push.js\";\nimport \"core-js/modules/es.array.unscopables.flat.js\";\nfunction _classPrivateMethodInitSpec(e, a) { _checkPrivateRedeclaration(e, a), a.add(e); }\nfunction _classPrivateFieldInitSpec(e, t, a) { _checkPrivateRedeclaration(e, t), t.set(e, a); }\nfunction _checkPrivateRedeclaration(e, t) { if (t.has(e)) throw new TypeError(\"Cannot initialize the same private elements twice on an object\"); }\nfunction _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == typeof i ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != typeof t || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != typeof i) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\nfunction _classPrivateFieldSet(s, a, r) { return s.set(_assertClassBrand(s, a), r), r; }\nfunction _classPrivateFieldGet(s, a) { return s.get(_assertClassBrand(s, a)); }\nfunction _assertClassBrand(e, t, n) { if (\"function\" == typeof e ? e === t : e.has(t)) return arguments.length < 3 ? t : n; throw new TypeError(\"Private element is not present on this object\"); }\nimport { BasePlugin } from \"../base/index.mjs\";\nimport { arrayEach, arrayMap } from \"../../helpers/array.mjs\";\nimport { toSingleLine } from \"../../helpers/templateLiteralTag.mjs\";\nimport { warn } from \"../../helpers/console.mjs\";\nimport { rangeEach } from \"../../helpers/number.mjs\";\nimport { addClass, removeClass } from \"../../helpers/dom/element.mjs\";\nimport { isKey } from \"../../helpers/unicode.mjs\";\nimport { SEPARATOR } from \"../contextMenu/predefinedItems/index.mjs\";\nimport * as constants from \"../../i18n/constants.mjs\";\nimport { ConditionComponent } from \"./component/condition.mjs\";\nimport { OperatorsComponent } from \"./component/operators.mjs\";\nimport { ValueComponent } from \"./component/value.mjs\";\nimport { ActionBarComponent } from \"./component/actionBar.mjs\";\nimport ConditionCollection from \"./conditionCollection.mjs\";\nimport DataFilter from \"./dataFilter.mjs\";\nimport ConditionUpdateObserver from \"./conditionUpdateObserver.mjs\";\nimport { createArrayAssertion, toEmptyString, unifyColumnValues } from \"./utils.mjs\";\nimport { createMenuFocusController } from \"./menu/focusController.mjs\";\nimport { CONDITION_NONE, CONDITION_BY_VALUE, OPERATION_AND, OPERATION_OR, OPERATION_OR_THEN_VARIABLE } from \"./constants.mjs\";\nimport { TrimmingMap } from \"../../translations/index.mjs\";\nexport const PLUGIN_KEY = 'filters';\nexport const PLUGIN_PRIORITY = 250;\nconst SHORTCUTS_GROUP = PLUGIN_KEY;\n\n/**\n * @plugin Filters\n * @class Filters\n *\n * @description\n * The plugin allows filtering the table data either by the built-in component or with the API.\n *\n * See [the filtering demo](@/guides/columns/column-filter/column-filter.md) for examples.\n *\n * @example\n * ::: only-for javascript\n * ```js\n * const container = document.getElementById('example');\n * const hot = new Handsontable(container, {\n *   data: getData(),\n *   colHeaders: true,\n *   rowHeaders: true,\n *   dropdownMenu: true,\n *   filters: true\n * });\n * ```\n * :::\n *\n * ::: only-for react\n * ```jsx\n * <HotTable\n *   data={getData()}\n *   colHeaders={true}\n *   rowHeaders={true}\n *   dropdownMenu={true}\n *   filters={true}\n * />\n * ```\n * :::\n */\nvar _menuFocusNavigator = /*#__PURE__*/new WeakMap();\nvar _Filters_brand = /*#__PURE__*/new WeakSet();\nexport class Filters extends BasePlugin {\n  static get PLUGIN_KEY() {\n    return PLUGIN_KEY;\n  }\n  static get PLUGIN_PRIORITY() {\n    return PLUGIN_PRIORITY;\n  }\n  static get PLUGIN_DEPS() {\n    return ['plugin:DropdownMenu', 'plugin:HiddenRows', 'cell-type:checkbox'];\n  }\n\n  /**\n   * Instance of {@link DropdownMenu}.\n   *\n   * @private\n   * @type {DropdownMenu}\n   */\n\n  constructor(hotInstance) {\n    super(hotInstance);\n    // One listener for the enable/disable functionality\n    /**\n     * `afterChange` listener.\n     *\n     * @param {Array} changes Array of changes.\n     */\n    _classPrivateMethodInitSpec(this, _Filters_brand);\n    _defineProperty(this, \"dropdownMenuPlugin\", null);\n    /**\n     * Instance of {@link ConditionCollection}.\n     *\n     * @private\n     * @type {ConditionCollection}\n     */\n    _defineProperty(this, \"conditionCollection\", null);\n    /**\n     * Instance of {@link ConditionUpdateObserver}.\n     *\n     * @private\n     * @type {ConditionUpdateObserver}\n     */\n    _defineProperty(this, \"conditionUpdateObserver\", null);\n    /**\n     * Map, where key is component identifier and value represent `BaseComponent` element or it derivatives.\n     *\n     * @private\n     * @type {Map}\n     */\n    _defineProperty(this, \"components\", new Map([['filter_by_condition', null], ['filter_operators', null], ['filter_by_condition2', null], ['filter_by_value', null], ['filter_action_bar', null]]));\n    /**\n     * Map of skipped rows by plugin.\n     *\n     * @private\n     * @type {null|TrimmingMap}\n     */\n    _defineProperty(this, \"filtersRowsMap\", null);\n    /**\n     * Menu focus navigator allows switching the focus position through Tab and Shift Tab keys.\n     *\n     * @type {MenuFocusNavigator|undefined}\n     */\n    _classPrivateFieldInitSpec(this, _menuFocusNavigator, void 0);\n    this.hot.addHook('afterGetColHeader', (col, TH) => _assertClassBrand(_Filters_brand, this, _onAfterGetColHeader).call(this, col, TH));\n  }\n\n  /**\n   * Checks if the plugin is enabled in the handsontable settings. This method is executed in {@link Hooks#beforeInit}\n   * hook and if it returns `true` then the {@link Filters#enablePlugin} method is called.\n   *\n   * @returns {boolean}\n   */\n  isEnabled() {\n    /* eslint-disable no-unneeded-ternary */\n    return this.hot.getSettings()[PLUGIN_KEY] ? true : false;\n  }\n\n  /**\n   * Enables the plugin functionality for this Handsontable instance.\n   */\n  enablePlugin() {\n    if (this.enabled) {\n      return;\n    }\n    this.filtersRowsMap = this.hot.rowIndexMapper.registerMap(this.pluginName, new TrimmingMap());\n    this.dropdownMenuPlugin = this.hot.getPlugin('dropdownMenu');\n    const dropdownSettings = this.hot.getSettings().dropdownMenu;\n    const menuContainer = dropdownSettings && dropdownSettings.uiContainer || this.hot.rootDocument.body;\n    const addConfirmationHooks = component => {\n      component.addLocalHook('accept', () => _assertClassBrand(_Filters_brand, this, _onActionBarSubmit).call(this, 'accept'));\n      component.addLocalHook('cancel', () => _assertClassBrand(_Filters_brand, this, _onActionBarSubmit).call(this, 'cancel'));\n      component.addLocalHook('change', command => _assertClassBrand(_Filters_brand, this, _onComponentChange).call(this, component, command));\n      return component;\n    };\n    const filterByConditionLabel = () => `${this.hot.getTranslatedPhrase(constants.FILTERS_DIVS_FILTER_BY_CONDITION)}:`;\n    const filterValueLabel = () => `${this.hot.getTranslatedPhrase(constants.FILTERS_DIVS_FILTER_BY_VALUE)}:`;\n    if (!this.components.get('filter_by_condition')) {\n      const conditionComponent = new ConditionComponent(this.hot, {\n        id: 'filter_by_condition',\n        name: filterByConditionLabel,\n        addSeparator: false,\n        menuContainer\n      });\n      conditionComponent.addLocalHook('afterClose', () => _assertClassBrand(_Filters_brand, this, _onSelectUIClosed).call(this));\n      this.components.set('filter_by_condition', addConfirmationHooks(conditionComponent));\n    }\n    if (!this.components.get('filter_operators')) {\n      this.components.set('filter_operators', new OperatorsComponent(this.hot, {\n        id: 'filter_operators',\n        name: 'Operators'\n      }));\n    }\n    if (!this.components.get('filter_by_condition2')) {\n      const conditionComponent = new ConditionComponent(this.hot, {\n        id: 'filter_by_condition2',\n        name: '',\n        addSeparator: true,\n        menuContainer\n      });\n      conditionComponent.addLocalHook('afterClose', () => _assertClassBrand(_Filters_brand, this, _onSelectUIClosed).call(this));\n      this.components.set('filter_by_condition2', addConfirmationHooks(conditionComponent));\n    }\n    if (!this.components.get('filter_by_value')) {\n      this.components.set('filter_by_value', addConfirmationHooks(new ValueComponent(this.hot, {\n        id: 'filter_by_value',\n        name: filterValueLabel\n      })));\n    }\n    if (!this.components.get('filter_action_bar')) {\n      this.components.set('filter_action_bar', addConfirmationHooks(new ActionBarComponent(this.hot, {\n        id: 'filter_action_bar',\n        name: 'Action bar'\n      })));\n    }\n    if (!this.conditionCollection) {\n      this.conditionCollection = new ConditionCollection(this.hot);\n    }\n    if (!this.conditionUpdateObserver) {\n      this.conditionUpdateObserver = new ConditionUpdateObserver(this.hot, this.conditionCollection, physicalColumn => this.getDataMapAtColumn(physicalColumn));\n      this.conditionUpdateObserver.addLocalHook('update', conditionState => _assertClassBrand(_Filters_brand, this, _updateComponents).call(this, conditionState));\n    }\n    this.components.forEach(component => component.show());\n    this.addHook('afterDropdownMenuDefaultOptions', defaultOptions => _assertClassBrand(_Filters_brand, this, _onAfterDropdownMenuDefaultOptions).call(this, defaultOptions));\n    this.addHook('afterDropdownMenuShow', () => _assertClassBrand(_Filters_brand, this, _onAfterDropdownMenuShow).call(this));\n    this.addHook('afterDropdownMenuHide', () => _assertClassBrand(_Filters_brand, this, _onAfterDropdownMenuHide).call(this));\n    this.addHook('afterChange', changes => _assertClassBrand(_Filters_brand, this, _onAfterChange).call(this, changes));\n\n    // Temp. solution (extending menu items bug in contextMenu/dropdownMenu)\n    if (this.hot.getSettings().dropdownMenu && this.dropdownMenuPlugin) {\n      this.dropdownMenuPlugin.disablePlugin();\n      this.dropdownMenuPlugin.enablePlugin();\n    }\n    if (!_classPrivateFieldGet(_menuFocusNavigator, this) && this.dropdownMenuPlugin.enabled) {\n      const mainMenu = this.dropdownMenuPlugin.menu;\n      const focusableItems = [\n      // A fake menu item that once focused allows escaping from the focus navigation (using Tab keys)\n      // to the menu navigation using arrow keys.\n      {\n        focus: () => {\n          const menuNavigator = mainMenu.getNavigator();\n          const lastSelectedMenuItem = _classPrivateFieldGet(_menuFocusNavigator, this).getLastMenuPage();\n          mainMenu.focus();\n          if (lastSelectedMenuItem > 0) {\n            menuNavigator.setCurrentPage(lastSelectedMenuItem);\n          } else {\n            menuNavigator.toFirstItem();\n          }\n        }\n      }, ...Array.from(this.components).map(_ref => {\n        let [, component] = _ref;\n        return component.getElements();\n      }).flat()];\n      _classPrivateFieldSet(_menuFocusNavigator, this, createMenuFocusController(mainMenu, focusableItems));\n      const forwardToFocusNavigation = event => {\n        _classPrivateFieldGet(_menuFocusNavigator, this).listen();\n        event.preventDefault();\n        if (isKey(event.keyCode, 'TAB')) {\n          if (event.shiftKey) {\n            _classPrivateFieldGet(_menuFocusNavigator, this).toPreviousItem();\n          } else {\n            _classPrivateFieldGet(_menuFocusNavigator, this).toNextItem();\n          }\n        }\n      };\n      this.components.get('filter_by_value').addLocalHook('listTabKeydown', forwardToFocusNavigation);\n      this.components.get('filter_by_condition').addLocalHook('selectTabKeydown', forwardToFocusNavigation);\n    }\n    this.registerShortcuts();\n    super.enablePlugin();\n  }\n\n  /**\n   * Disables the plugin functionality for this Handsontable instance.\n   */\n  disablePlugin() {\n    if (this.enabled) {\n      var _this$dropdownMenuPlu;\n      if ((_this$dropdownMenuPlu = this.dropdownMenuPlugin) !== null && _this$dropdownMenuPlu !== void 0 && _this$dropdownMenuPlu.enabled) {\n        this.dropdownMenuPlugin.menu.clearLocalHooks();\n      }\n      this.components.forEach((component, key) => {\n        component.destroy();\n        this.components.set(key, null);\n      });\n      this.conditionCollection.destroy();\n      this.conditionCollection = null;\n      this.hot.rowIndexMapper.unregisterMap(this.pluginName);\n    }\n    this.unregisterShortcuts();\n    super.disablePlugin();\n  }\n\n  /**\n   * Register shortcuts responsible for clearing the filters.\n   *\n   * @private\n   */\n  registerShortcuts() {\n    this.hot.getShortcutManager().getContext('grid').addShortcut({\n      keys: [['Alt', 'A']],\n      stopPropagation: true,\n      callback: () => {\n        const selection = this.hot.getSelected();\n        this.clearConditions();\n        this.filter();\n        if (selection) {\n          this.hot.selectCells(selection);\n        }\n      },\n      group: SHORTCUTS_GROUP\n    });\n  }\n\n  /**\n   * Unregister shortcuts responsible for clearing the filters.\n   *\n   * @private\n   */\n  unregisterShortcuts() {\n    this.hot.getShortcutManager().getContext('grid').removeShortcutsByGroup(SHORTCUTS_GROUP);\n  }\n\n  /* eslint-disable jsdoc/require-description-complete-sentence */\n  /**\n   * @memberof Filters#\n   * @function addCondition\n   * @description\n   * Adds condition to the conditions collection at specified column index.\n   *\n   * Possible predefined conditions:\n   *  * `begins_with` - Begins with\n   *  * `between` - Between\n   *  * `by_value` - By value\n   *  * `contains` - Contains\n   *  * `date_after` - After a date\n   *  * `date_before` - Before a date\n   *  * `date_today` - Today\n   *  * `date_tomorrow` - Tomorrow\n   *  * `date_yesterday` - Yesterday\n   *  * `empty` - Empty\n   *  * `ends_with` - Ends with\n   *  * `eq` - Equal\n   *  * `gt` - Greater than\n   *  * `gte` - Greater than or equal\n   *  * `lt` - Less than\n   *  * `lte` - Less than or equal\n   *  * `none` - None (no filter)\n   *  * `not_between` - Not between\n   *  * `not_contains` - Not contains\n   *  * `not_empty` - Not empty\n   *  * `neq` - Not equal.\n   *\n   * Possible operations on collection of conditions:\n   *  * `conjunction` - [**Conjunction**](https://en.wikipedia.org/wiki/Logical_conjunction) on conditions collection (by default), i.e. for such operation: <br/> c1 AND c2 AND c3 AND c4 ... AND cn === TRUE, where c1 ... cn are conditions.\n   *  * `disjunction` - [**Disjunction**](https://en.wikipedia.org/wiki/Logical_disjunction) on conditions collection, i.e. for such operation: <br/> c1 OR c2 OR c3 OR c4 ... OR cn === TRUE, where c1, c2, c3, c4 ... cn are conditions.\n   *  * `disjunctionWithExtraCondition` - **Disjunction** on first `n - 1`\\* conditions from collection with an extra requirement computed from the last condition, i.e. for such operation: <br/> c1 OR c2 OR c3 OR c4 ... OR cn-1 AND cn === TRUE, where c1, c2, c3, c4 ... cn are conditions.\n   *\n   * \\* when `n` is collection size; it's used i.e. for one operation introduced from UI (when choosing from filter's drop-down menu two conditions with OR operator between them, mixed with choosing values from the multiple choice select)\n   *\n   * **Note**: Mind that you cannot mix different types of operations (for instance, if you use `conjunction`, use it consequently for a particular column).\n   *\n   * @example\n   * ::: only-for javascript\n   * ```js\n   * const container = document.getElementById('example');\n   * const hot = new Handsontable(container, {\n   *   data: getData(),\n   *   filters: true\n   * });\n   *\n   * // access to filters plugin instance\n   * const filtersPlugin = hot.getPlugin('filters');\n   *\n   * // add filter \"Greater than\" 95 to column at index 1\n   * filtersPlugin.addCondition(1, 'gt', [95]);\n   * filtersPlugin.filter();\n   *\n   * // add filter \"By value\" to column at index 1\n   * // in this case all value's that don't match will be filtered.\n   * filtersPlugin.addCondition(1, 'by_value', [['ing', 'ed', 'as', 'on']]);\n   * filtersPlugin.filter();\n   *\n   * // add filter \"Begins with\" with value \"de\" AND \"Not contains\" with value \"ing\"\n   * filtersPlugin.addCondition(1, 'begins_with', ['de'], 'conjunction');\n   * filtersPlugin.addCondition(1, 'not_contains', ['ing'], 'conjunction');\n   * filtersPlugin.filter();\n   *\n   * // add filter \"Begins with\" with value \"de\" OR \"Not contains\" with value \"ing\"\n   * filtersPlugin.addCondition(1, 'begins_with', ['de'], 'disjunction');\n   * filtersPlugin.addCondition(1, 'not_contains', ['ing'], 'disjunction');\n   * filtersPlugin.filter();\n   * ```\n   * :::\n   *\n   * ::: only-for react\n   * ```jsx\n   * const hotRef = useRef(null);\n   *\n   * ...\n   *\n   * <HotTable\n   *   ref={hotRef}\n   *   data={getData()}\n   *   filters={true}\n   * />\n   *\n   * // access to filters plugin instance\n   * const hot = hotRef.current.hotInstance;\n   * const filtersPlugin = hot.getPlugin('filters');\n   *\n   * // add filter \"Greater than\" 95 to column at index 1\n   * filtersPlugin.addCondition(1, 'gt', [95]);\n   * filtersPlugin.filter();\n   *\n   * // add filter \"By value\" to column at index 1\n   * // in this case all value's that don't match will be filtered.\n   * filtersPlugin.addCondition(1, 'by_value', [['ing', 'ed', 'as', 'on']]);\n   * filtersPlugin.filter();\n   *\n   * // add filter \"Begins with\" with value \"de\" AND \"Not contains\" with value \"ing\"\n   * filtersPlugin.addCondition(1, 'begins_with', ['de'], 'conjunction');\n   * filtersPlugin.addCondition(1, 'not_contains', ['ing'], 'conjunction');\n   * filtersPlugin.filter();\n   *\n   * // add filter \"Begins with\" with value \"de\" OR \"Not contains\" with value \"ing\"\n   * filtersPlugin.addCondition(1, 'begins_with', ['de'], 'disjunction');\n   * filtersPlugin.addCondition(1, 'not_contains', ['ing'], 'disjunction');\n   * filtersPlugin.filter();\n   * ```\n   * :::\n   *\n   * @param {number} column Visual column index.\n   * @param {string} name Condition short name.\n   * @param {Array} args Condition arguments.\n   * @param {string} [operationId=conjunction] `id` of operation which is performed on the column.\n   */\n  /* eslint-enable jsdoc/require-description-complete-sentence */\n  addCondition(column, name, args) {\n    let operationId = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : OPERATION_AND;\n    const physicalColumn = this.hot.toPhysicalColumn(column);\n    this.conditionCollection.addCondition(physicalColumn, {\n      command: {\n        key: name\n      },\n      args\n    }, operationId);\n  }\n\n  /**\n   * Removes conditions at specified column index.\n   *\n   * @param {number} column Visual column index.\n   */\n  removeConditions(column) {\n    const physicalColumn = this.hot.toPhysicalColumn(column);\n    this.conditionCollection.removeConditions(physicalColumn);\n  }\n\n  /**\n   * Clears all conditions previously added to the collection for the specified column index or, if the column index\n   * was not passed, clear the conditions for all columns.\n   *\n   * @param {number} [column] Visual column index.\n   */\n  clearConditions(column) {\n    if (column === undefined) {\n      this.conditionCollection.clean();\n    } else {\n      const physicalColumn = this.hot.toPhysicalColumn(column);\n      this.conditionCollection.removeConditions(physicalColumn);\n    }\n  }\n\n  /**\n   * Filters data based on added filter conditions.\n   *\n   * @fires Hooks#beforeFilter\n   * @fires Hooks#afterFilter\n   */\n  filter() {\n    const {\n      navigableHeaders\n    } = this.hot.getSettings();\n    const dataFilter = this._createDataFilter();\n    const needToFilter = !this.conditionCollection.isEmpty();\n    let visibleVisualRows = [];\n    const conditions = this.conditionCollection.exportAllConditions();\n    const allowFiltering = this.hot.runHooks('beforeFilter', conditions, this.conditionCollection.previousConditionStack);\n    if (allowFiltering !== false) {\n      if (needToFilter) {\n        const trimmedRows = [];\n        this.hot.batchExecution(() => {\n          this.filtersRowsMap.clear();\n          visibleVisualRows = arrayMap(dataFilter.filter(), rowData => rowData.meta.visualRow);\n          const visibleVisualRowsAssertion = createArrayAssertion(visibleVisualRows);\n          rangeEach(this.hot.countSourceRows() - 1, row => {\n            if (!visibleVisualRowsAssertion(row)) {\n              trimmedRows.push(row);\n            }\n          });\n          arrayEach(trimmedRows, physicalRow => {\n            this.filtersRowsMap.setValueAtIndex(physicalRow, true);\n          });\n        }, true);\n        if (!navigableHeaders && !visibleVisualRows.length) {\n          this.hot.deselectCell();\n        }\n      } else {\n        this.filtersRowsMap.clear();\n      }\n    }\n    this.hot.runHooks('afterFilter', conditions);\n    this.conditionCollection.setPreviousConditionStack(null);\n    this.hot.view.adjustElementsSize();\n    this.hot.render();\n    if (this.hot.selection.isSelected()) {\n      this.hot.selectCell(navigableHeaders ? -1 : 0, this.hot.getSelectedRangeLast().highlight.col);\n    }\n  }\n\n  /**\n   * Gets last selected column index.\n   *\n   * @returns {{visualIndex: number, physicalIndex: number} | null} Returns `null` when a column is\n   * not selected. Otherwise, returns an object with `visualIndex` and `physicalIndex` properties containing\n   * the index of the column.\n   */\n  getSelectedColumn() {\n    var _this$hot$getSelected;\n    const highlight = (_this$hot$getSelected = this.hot.getSelectedRangeLast()) === null || _this$hot$getSelected === void 0 ? void 0 : _this$hot$getSelected.highlight;\n    if (!highlight) {\n      return null;\n    }\n    return {\n      visualIndex: highlight.col,\n      physicalIndex: this.hot.toPhysicalColumn(highlight.col)\n    };\n  }\n\n  /**\n   * Returns handsontable source data with cell meta based on current selection.\n   *\n   * @param {number} [column] The physical column index. By default column index accept the value of the selected column.\n   * @returns {Array} Returns array of objects where keys as row index.\n   */\n  getDataMapAtColumn(column) {\n    const visualColumn = this.hot.toVisualColumn(column);\n    const data = [];\n    arrayEach(this.hot.getSourceDataAtCol(visualColumn), (value, rowIndex) => {\n      var _this$hot$getDataAtCe;\n      const {\n        row,\n        col,\n        visualCol,\n        visualRow,\n        type,\n        instance,\n        dateFormat,\n        locale\n      } = this.hot.getCellMeta(rowIndex, visualColumn);\n      const dataValue = (_this$hot$getDataAtCe = this.hot.getDataAtCell(this.hot.toVisualRow(rowIndex), visualColumn)) !== null && _this$hot$getDataAtCe !== void 0 ? _this$hot$getDataAtCe : value;\n      data.push({\n        meta: {\n          row,\n          col,\n          visualCol,\n          visualRow,\n          type,\n          instance,\n          dateFormat,\n          locale\n        },\n        value: toEmptyString(dataValue)\n      });\n    });\n    return data;\n  }\n  /**\n   * Update the condition of ValueComponent, based on the handled changes.\n   *\n   * @private\n   * @param {number} columnIndex Column index of handled ValueComponent condition.\n   */\n  updateValueComponentCondition(columnIndex) {\n    const dataAtCol = this.hot.getDataAtCol(columnIndex);\n    const selectedValues = unifyColumnValues(dataAtCol);\n    this.conditionUpdateObserver.updateStatesAtColumn(columnIndex, selectedValues);\n  }\n\n  /**\n   * Restores components to its saved state.\n   *\n   * @private\n   * @param {Array} components List of components.\n   */\n  restoreComponents(components) {\n    var _this$getSelectedColu;\n    const physicalIndex = (_this$getSelectedColu = this.getSelectedColumn()) === null || _this$getSelectedColu === void 0 ? void 0 : _this$getSelectedColu.physicalIndex;\n    components.forEach(component => {\n      if (component.isHidden()) {\n        return;\n      }\n      component.restoreState(physicalIndex);\n    });\n    this.updateDependentComponentsVisibility();\n  }\n\n  /**\n   * After dropdown menu show listener.\n   */\n\n  /**\n   * Get an operation, based on the number and types of arguments (where arguments are states of components).\n   *\n   * @param {string} suggestedOperation Operation which was chosen by user from UI.\n   * @param {object} byConditionState1 State of first condition component.\n   * @param {object} byConditionState2 State of second condition component.\n   * @param {object} byValueState State of value component.\n   * @private\n   * @returns {string}\n   */\n  getOperationBasedOnArguments(suggestedOperation, byConditionState1, byConditionState2, byValueState) {\n    let operation = suggestedOperation;\n    if (operation === OPERATION_OR && byConditionState1.command.key !== CONDITION_NONE && byConditionState2.command.key !== CONDITION_NONE && byValueState.command.key !== CONDITION_NONE) {\n      operation = OPERATION_OR_THEN_VARIABLE;\n    } else if (byValueState.command.key !== CONDITION_NONE) {\n      if (byConditionState1.command.key === CONDITION_NONE || byConditionState2.command.key === CONDITION_NONE) {\n        operation = OPERATION_AND;\n      }\n    }\n    return operation;\n  }\n\n  /**\n   * On action bar submit listener.\n   *\n   * @private\n   * @param {string} submitType The submit type.\n   */\n\n  /**\n   * Listen to the keyboard input on document body and forward events to instance of Handsontable\n   * created by DropdownMenu plugin.\n   *\n   * @private\n   */\n  setListeningDropdownMenu() {\n    if (this.dropdownMenuPlugin) {\n      this.dropdownMenuPlugin.setListening();\n    }\n  }\n\n  /**\n   * Updates visibility of some of the components, based on the state of the parent component.\n   *\n   * @private\n   */\n  updateDependentComponentsVisibility() {\n    const component = this.components.get('filter_by_condition');\n    const {\n      command\n    } = component.getState();\n    const componentsToShow = [this.components.get('filter_by_condition2'), this.components.get('filter_operators')];\n    if (command.showOperators) {\n      this.showComponents(...componentsToShow);\n    } else {\n      this.hideComponents(...componentsToShow);\n    }\n  }\n\n  /**\n   * On after get column header listener.\n   *\n   * @param {number} col Visual column index.\n   * @param {HTMLTableCellElement} TH Header's TH element.\n   */\n\n  /**\n   * Creates DataFilter instance based on condition collection.\n   *\n   * @private\n   * @param {ConditionCollection} conditionCollection Condition collection object.\n   * @returns {DataFilter}\n   */\n  _createDataFilter() {\n    let conditionCollection = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.conditionCollection;\n    return new DataFilter(conditionCollection, physicalColumn => this.getDataMapAtColumn(physicalColumn));\n  }\n\n  /**\n   * It updates the components state. The state is triggered by ConditionUpdateObserver, which\n   * reacts to any condition added to the condition collection. It may be added through the UI\n   * components or by API call.\n   *\n   * @param {object} conditionsState An object with the state generated by UI components.\n   */\n\n  /**\n   * Returns indexes of passed components inside list of `dropdownMenu` items.\n   *\n   * @private\n   * @param {...BaseComponent} components List of components.\n   * @returns {Array}\n   */\n  getIndexesOfComponents() {\n    const indexes = [];\n    if (!this.dropdownMenuPlugin) {\n      return indexes;\n    }\n    const menu = this.dropdownMenuPlugin.menu;\n    for (var _len = arguments.length, components = new Array(_len), _key = 0; _key < _len; _key++) {\n      components[_key] = arguments[_key];\n    }\n    arrayEach(components, component => {\n      arrayEach(menu.menuItems, (item, index) => {\n        if (item.key === component.getMenuItemDescriptor().key) {\n          indexes.push(index);\n        }\n      });\n    });\n    return indexes;\n  }\n\n  /**\n   * Changes visibility of component.\n   *\n   * @private\n   * @param {boolean} visible Determine if components should be visible.\n   * @param {...BaseComponent} components List of components.\n   */\n  changeComponentsVisibility() {\n    let visible = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;\n    if (!this.dropdownMenuPlugin) {\n      return;\n    }\n    const menu = this.dropdownMenuPlugin.menu;\n    const hotMenu = menu.hotMenu;\n    const hiddenRows = hotMenu.getPlugin('hiddenRows');\n    for (var _len2 = arguments.length, components = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {\n      components[_key2 - 1] = arguments[_key2];\n    }\n    const indexes = this.getIndexesOfComponents(...components);\n    if (visible) {\n      hiddenRows.showRows(indexes);\n    } else {\n      hiddenRows.hideRows(indexes);\n    }\n    hotMenu.render();\n  }\n\n  /**\n   * Hides components of filters `dropdownMenu`.\n   *\n   * @private\n   * @param {...BaseComponent} components List of components.\n   */\n  hideComponents() {\n    for (var _len3 = arguments.length, components = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {\n      components[_key3] = arguments[_key3];\n    }\n    this.changeComponentsVisibility(false, ...components);\n  }\n\n  /**\n   * Shows components of filters `dropdownMenu`.\n   *\n   * @private\n   * @param {...BaseComponent} components List of components.\n   */\n  showComponents() {\n    for (var _len4 = arguments.length, components = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {\n      components[_key4] = arguments[_key4];\n    }\n    this.changeComponentsVisibility(true, ...components);\n  }\n\n  /**\n   * Destroys the plugin instance.\n   */\n  destroy() {\n    if (this.enabled) {\n      this.components.forEach((component, key) => {\n        if (component !== null) {\n          component.destroy();\n          this.components.set(key, null);\n        }\n      });\n      this.conditionCollection.destroy();\n      this.conditionUpdateObserver.destroy();\n      this.hot.rowIndexMapper.unregisterMap(this.pluginName);\n    }\n    super.destroy();\n  }\n}\nfunction _onAfterChange(changes) {\n  if (changes) {\n    arrayEach(changes, change => {\n      const [, prop] = change;\n      const columnIndex = this.hot.propToCol(prop);\n      if (this.conditionCollection.hasConditions(columnIndex)) {\n        this.updateValueComponentCondition(columnIndex);\n      }\n    });\n  }\n}\nfunction _onAfterDropdownMenuShow() {\n  const menu = this.dropdownMenuPlugin.menu;\n  this.restoreComponents(Array.from(this.components.values()));\n  menu.updateMenuDimensions();\n}\n/**\n * After dropdown menu hide listener.\n */\nfunction _onAfterDropdownMenuHide() {\n  this.components.get('filter_by_condition').getSelectElement().closeOptions();\n  this.components.get('filter_by_condition2').getSelectElement().closeOptions();\n}\n/**\n * After dropdown menu default options listener.\n *\n * @param {object} defaultOptions ContextMenu default item options.\n */\nfunction _onAfterDropdownMenuDefaultOptions(defaultOptions) {\n  defaultOptions.items.push({\n    name: SEPARATOR\n  });\n  this.components.forEach(component => {\n    defaultOptions.items.push(component.getMenuItemDescriptor());\n  });\n}\nfunction _onActionBarSubmit(submitType) {\n  var _this$dropdownMenuPlu3;\n  if (submitType === 'accept') {\n    const selectedColumn = this.getSelectedColumn();\n    if (selectedColumn === null) {\n      var _this$dropdownMenuPlu2;\n      (_this$dropdownMenuPlu2 = this.dropdownMenuPlugin) === null || _this$dropdownMenuPlu2 === void 0 || _this$dropdownMenuPlu2.close();\n      return;\n    }\n    const {\n      physicalIndex\n    } = selectedColumn;\n    const byConditionState1 = this.components.get('filter_by_condition').getState();\n    const byConditionState2 = this.components.get('filter_by_condition2').getState();\n    const byValueState = this.components.get('filter_by_value').getState();\n    const operation = this.getOperationBasedOnArguments(this.components.get('filter_operators').getActiveOperationId(), byConditionState1, byConditionState2, byValueState);\n    this.conditionUpdateObserver.groupChanges();\n    let columnStackPosition = this.conditionCollection.getColumnStackPosition(physicalIndex);\n    if (columnStackPosition === -1) {\n      columnStackPosition = undefined;\n    }\n    this.conditionCollection.removeConditions(physicalIndex);\n    if (byConditionState1.command.key !== CONDITION_NONE) {\n      this.conditionCollection.addCondition(physicalIndex, byConditionState1, operation, columnStackPosition);\n      if (byConditionState2.command.key !== CONDITION_NONE) {\n        this.conditionCollection.addCondition(physicalIndex, byConditionState2, operation, columnStackPosition);\n      }\n    }\n    if (byValueState.command.key !== CONDITION_NONE) {\n      this.conditionCollection.addCondition(physicalIndex, byValueState, operation, columnStackPosition);\n    }\n    this.conditionUpdateObserver.flush();\n    this.components.forEach(component => component.saveState(physicalIndex));\n    this.filtersRowsMap.clear();\n    this.filter();\n  }\n  (_this$dropdownMenuPlu3 = this.dropdownMenuPlugin) === null || _this$dropdownMenuPlu3 === void 0 || _this$dropdownMenuPlu3.close();\n}\n/**\n * On component change listener.\n *\n * @param {BaseComponent} component Component inheriting BaseComponent.\n * @param {object} command Menu item object (command).\n */\nfunction _onComponentChange(component, command) {\n  this.updateDependentComponentsVisibility();\n  if (component.constructor === ConditionComponent && !command.inputsCount) {\n    this.setListeningDropdownMenu();\n  }\n}\n/**\n * On component SelectUI closed listener.\n */\nfunction _onSelectUIClosed() {\n  this.setListeningDropdownMenu();\n}\nfunction _onAfterGetColHeader(col, TH) {\n  const physicalColumn = this.hot.toPhysicalColumn(col);\n  if (this.enabled && this.conditionCollection.hasConditions(physicalColumn)) {\n    addClass(TH, 'htFiltersActive');\n  } else {\n    removeClass(TH, 'htFiltersActive');\n  }\n}\nfunction _updateComponents(conditionsState) {\n  var _this$dropdownMenuPlu4;\n  if (!((_this$dropdownMenuPlu4 = this.dropdownMenuPlugin) !== null && _this$dropdownMenuPlu4 !== void 0 && _this$dropdownMenuPlu4.enabled)) {\n    return;\n  }\n  const {\n    editedConditionStack: {\n      conditions,\n      column\n    }\n  } = conditionsState;\n  const conditionsByValue = conditions.filter(condition => condition.name === CONDITION_BY_VALUE);\n  const conditionsWithoutByValue = conditions.filter(condition => condition.name !== CONDITION_BY_VALUE);\n  if (conditionsByValue.length >= 2 || conditionsWithoutByValue.length >= 3) {\n    warn(toSingleLine`The filter conditions have been applied properly, but couldn’t be displayed visually.\\x20\n        The overall amount of conditions exceed the capability of the dropdown menu.\\x20\n        For more details see the documentation.`);\n  } else {\n    const operationType = this.conditionCollection.getOperation(column);\n    this.components.get('filter_by_condition').updateState(conditionsWithoutByValue[0], column);\n    this.components.get('filter_by_condition2').updateState(conditionsWithoutByValue[1], column);\n    this.components.get('filter_operators').updateState(operationType, column);\n    this.components.get('filter_by_value').updateState(conditionsState);\n  }\n}","import \"core-js/modules/es.array.push.js\";\nimport staticRegister from \"../../../utils/staticRegister.mjs\";\nimport { isUndefined } from \"../../../helpers/mixed.mjs\";\nimport { toSingleLine } from \"../../../helpers/templateLiteralTag.mjs\";\nimport { warn } from \"../../../helpers/console.mjs\";\nimport { isObjectEqual } from \"../../../helpers/object.mjs\";\nimport { PLUGIN_KEY } from \"../formulas.mjs\";\nimport { DEFAULT_LICENSE_KEY, DEFAULT_SETTINGS, getEngineSettingsWithDefaultsAndOverrides } from \"./settings.mjs\";\n/**\n * Prepares and returns the collection for the engine relationship with the HoT instances.\n *\n * @returns {Map}\n */\nfunction getEngineRelationshipRegistry() {\n  const registryKey = 'engine_relationship';\n  const pluginStaticRegistry = staticRegister(PLUGIN_KEY);\n  if (!pluginStaticRegistry.hasItem(registryKey)) {\n    pluginStaticRegistry.register(registryKey, new Map());\n  }\n  return pluginStaticRegistry.getItem(registryKey);\n}\n\n/**\n * Prepares and returns the collection for the engine shared usage.\n *\n * @returns {Map}\n */\nfunction getSharedEngineUsageRegistry() {\n  const registryKey = 'shared_engine_usage';\n  const pluginStaticRegistry = staticRegister(PLUGIN_KEY);\n  if (!pluginStaticRegistry.hasItem(registryKey)) {\n    pluginStaticRegistry.register(registryKey, new Map());\n  }\n  return pluginStaticRegistry.getItem(registryKey);\n}\n\n/**\n * Setups the engine instance. It either creates a new (possibly shared) engine instance, or attaches\n * the plugin to an already-existing instance.\n *\n * @param {Handsontable} hotInstance Handsontable instance.\n * @returns {null|object} Returns the engine instance if everything worked right and `null` otherwise.\n */\nexport function setupEngine(hotInstance) {\n  const hotSettings = hotInstance.getSettings();\n  const pluginSettings = hotSettings[PLUGIN_KEY];\n  const engineConfigItem = pluginSettings === null || pluginSettings === void 0 ? void 0 : pluginSettings.engine;\n  if (pluginSettings === true) {\n    return null;\n  }\n  if (isUndefined(engineConfigItem)) {\n    return null;\n  }\n\n  // `engine.hyperformula` or `engine` is the engine class\n  if (typeof engineConfigItem.hyperformula === 'function' || typeof engineConfigItem === 'function') {\n    var _engineConfigItem$hyp;\n    return registerEngine((_engineConfigItem$hyp = engineConfigItem.hyperformula) !== null && _engineConfigItem$hyp !== void 0 ? _engineConfigItem$hyp : engineConfigItem, hotSettings, hotInstance);\n\n    // `engine` is the engine instance\n  } else if (typeof engineConfigItem === 'object' && isUndefined(engineConfigItem.hyperformula)) {\n    const engineRelationship = getEngineRelationshipRegistry();\n    const sharedEngineUsage = getSharedEngineUsageRegistry().get(engineConfigItem);\n    if (!engineRelationship.has(engineConfigItem)) {\n      engineRelationship.set(engineConfigItem, []);\n    }\n    engineRelationship.get(engineConfigItem).push(hotInstance);\n    if (sharedEngineUsage) {\n      sharedEngineUsage.push(hotInstance.guid);\n    }\n    if (!engineConfigItem.getConfig().licenseKey) {\n      engineConfigItem.updateConfig({\n        licenseKey: DEFAULT_LICENSE_KEY\n      });\n    }\n    if (engineConfigItem.getConfig().leapYear1900 !== DEFAULT_SETTINGS.leapYear1900 || isObjectEqual(engineConfigItem.getConfig().nullDate, DEFAULT_SETTINGS.nullDate) === false) {\n      warn(toSingleLine`If you use HyperFormula with Handsontable, keep the default \\`leapYear1900\\` and \\`nullDate\\` \n      settings. Otherwise, HyperFormula's dates may not sync correctly with Handsontable's dates.`);\n    }\n    return engineConfigItem;\n  }\n  return null;\n}\n\n/**\n * Registers the engine in the global register and attaches the needed event listeners.\n *\n * @param {Function} engineClass The engine class.\n * @param {object} hotSettings The Handsontable settings.\n * @param {Handsontable} hotInstance Handsontable instance.\n * @returns {object} Returns the engine instance.\n */\nexport function registerEngine(engineClass, hotSettings, hotInstance) {\n  const pluginSettings = hotSettings[PLUGIN_KEY];\n  const engineSettings = getEngineSettingsWithDefaultsAndOverrides(hotSettings);\n  const engineRegistry = getEngineRelationshipRegistry();\n  const sharedEngineRegistry = getSharedEngineUsageRegistry();\n  registerCustomFunctions(engineClass, pluginSettings.functions);\n  registerLanguage(engineClass, pluginSettings.language);\n\n  // Create instance\n  const engineInstance = engineClass.buildEmpty(engineSettings);\n\n  // Add it to global registry\n  engineRegistry.set(engineInstance, [hotInstance]);\n  sharedEngineRegistry.set(engineInstance, [hotInstance.guid]);\n  registerNamedExpressions(engineInstance, pluginSettings.namedExpressions);\n\n  // Add hooks needed for cross-referencing sheets\n  engineInstance.on('sheetAdded', () => {\n    engineInstance.rebuildAndRecalculate();\n  });\n  engineInstance.on('sheetRemoved', () => {\n    engineInstance.rebuildAndRecalculate();\n  });\n  return engineInstance;\n}\n\n/**\n * Returns the list of the Handsontable instances linked to the specific engine instance.\n *\n * @param {object} engine The engine instance.\n * @returns {Map<number, Handsontable>} Returns Map with Handsontable instances.\n */\nexport function getRegisteredHotInstances(engine) {\n  var _engineRegistry$get;\n  const engineRegistry = getEngineRelationshipRegistry();\n  const hotInstances = engineRegistry.size === 0 ? [] : Array.from((_engineRegistry$get = engineRegistry.get(engine)) !== null && _engineRegistry$get !== void 0 ? _engineRegistry$get : []);\n  return new Map(hotInstances.map(hot => [hot.getPlugin('formulas').sheetId, hot]));\n}\n\n/**\n * Removes the HOT instance from the global register's engine usage array, and if there are no HOT instances left,\n * unregisters the engine itself.\n *\n * @param {object} engine The engine instance.\n * @param {string} hotInstance The Handsontable instance.\n */\nexport function unregisterEngine(engine, hotInstance) {\n  if (engine) {\n    const engineRegistry = getEngineRelationshipRegistry();\n    const engineHotRelationship = engineRegistry.get(engine);\n    const sharedEngineRegistry = getSharedEngineUsageRegistry();\n    const sharedEngineUsage = sharedEngineRegistry.get(engine);\n    if (engineHotRelationship && engineHotRelationship.includes(hotInstance)) {\n      engineHotRelationship.splice(engineHotRelationship.indexOf(hotInstance), 1);\n      if (engineHotRelationship.length === 0) {\n        engineRegistry.delete(engine);\n      }\n    }\n    if (sharedEngineUsage && sharedEngineUsage.includes(hotInstance.guid)) {\n      sharedEngineUsage.splice(sharedEngineUsage.indexOf(hotInstance.guid), 1);\n      if (sharedEngineUsage.length === 0) {\n        sharedEngineRegistry.delete(engine);\n        engine.destroy();\n      }\n    }\n  }\n}\n\n/**\n * Registers the custom functions for the engine.\n *\n * @param {Function} engineClass The engine class.\n * @param {Array} customFunctions The custom functions array.\n */\nexport function registerCustomFunctions(engineClass, customFunctions) {\n  if (customFunctions) {\n    customFunctions.forEach(func => {\n      const {\n        name,\n        plugin,\n        translations\n      } = func;\n      try {\n        engineClass.registerFunction(name, plugin, translations);\n      } catch (e) {\n        warn(e.message);\n      }\n    });\n  }\n}\n\n/**\n * Registers the provided language for the engine.\n *\n * @param {Function} engineClass The engine class.\n * @param {object} languageSetting The engine's language object.\n */\nexport function registerLanguage(engineClass, languageSetting) {\n  if (languageSetting) {\n    const {\n      langCode\n    } = languageSetting;\n    try {\n      engineClass.registerLanguage(langCode, languageSetting);\n    } catch (e) {\n      warn(e.message);\n    }\n  }\n}\n\n/**\n * Registers the provided named expressions in the engine instance.\n *\n * @param {object} engineInstance The engine instance.\n * @param {Array} namedExpressions Array of the named expressions to be registered.\n */\nexport function registerNamedExpressions(engineInstance, namedExpressions) {\n  if (namedExpressions) {\n    engineInstance.suspendEvaluation();\n    namedExpressions.forEach(namedExp => {\n      const {\n        name,\n        expression,\n        scope,\n        options\n      } = namedExp;\n      try {\n        engineInstance.addNamedExpression(name, expression, scope, options);\n      } catch (e) {\n        warn(e.message);\n      }\n    });\n    engineInstance.resumeEvaluation();\n  }\n}\n\n/**\n * Sets up a new sheet.\n *\n * @param {object} engineInstance The engine instance.\n * @param {string} sheetName The new sheet name.\n * @returns {*}\n */\nexport function setupSheet(engineInstance, sheetName) {\n  if (isUndefined(sheetName) || !engineInstance.doesSheetExist(sheetName)) {\n    sheetName = engineInstance.addSheet(sheetName);\n  }\n  return sheetName;\n}","import \"core-js/modules/es.error.cause.js\";\nfunction _classPrivateFieldInitSpec(e, t, a) { _checkPrivateRedeclaration(e, t), t.set(e, a); }\nfunction _checkPrivateRedeclaration(e, t) { if (t.has(e)) throw new TypeError(\"Cannot initialize the same private elements twice on an object\"); }\nfunction _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == typeof i ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != typeof t || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != typeof i) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\nfunction _classPrivateFieldGet(s, a) { return s.get(_assertClassBrand(s, a)); }\nfunction _classPrivateFieldSet(s, a, r) { return s.set(_assertClassBrand(s, a), r), r; }\nfunction _assertClassBrand(e, t, n) { if (\"function\" == typeof e ? e === t : e.has(t)) return arguments.length < 3 ? t : n; throw new TypeError(\"Private element is not present on this object\"); }\nimport { toSingleLine } from \"../../helpers/templateLiteralTag.mjs\";\n/**\n * The `MergedCellCoords` class represents a single merged cell.\n *\n * @private\n * @class MergedCellCoords\n */\nvar _cellRange = /*#__PURE__*/new WeakMap();\nclass MergedCellCoords {\n  constructor(row, column, rowspan, colspan, cellCoordsFactory, cellRangeFactory) {\n    /**\n     * The index of the topmost merged cell row.\n     *\n     * @type {number}\n     */\n    _defineProperty(this, \"row\", void 0);\n    /**\n     * The index of the leftmost column.\n     *\n     * @type {number}\n     */\n    _defineProperty(this, \"col\", void 0);\n    /**\n     * The `rowspan` value of the merged cell.\n     *\n     * @type {number}\n     */\n    _defineProperty(this, \"rowspan\", void 0);\n    /**\n     * The `colspan` value of the merged cell.\n     *\n     * @type {number}\n     */\n    _defineProperty(this, \"colspan\", void 0);\n    /**\n     * `true` only if the merged cell is bound to be removed.\n     *\n     * @type {boolean}\n     */\n    _defineProperty(this, \"removed\", false);\n    /**\n     * The CellCoords function factory.\n     *\n     * @type {Function}\n     */\n    _defineProperty(this, \"cellCoordsFactory\", void 0);\n    /**\n     * The CellRange function factory.\n     *\n     * @type {Function}\n     */\n    _defineProperty(this, \"cellRangeFactory\", void 0);\n    /**\n     * The cached range coordinates of the merged cell.\n     *\n     * @type {CellRange}\n     */\n    _classPrivateFieldInitSpec(this, _cellRange, null);\n    this.row = row;\n    this.col = column;\n    this.rowspan = rowspan;\n    this.colspan = colspan;\n    this.cellCoordsFactory = cellCoordsFactory;\n    this.cellRangeFactory = cellRangeFactory;\n  }\n\n  /**\n   * Get a warning message for when the declared merged cell data contains negative values.\n   *\n   * @param {{ row: number, col: number, rowspan: number, colspan: number }} mergedCell Object containing information\n   * about the merged cells that was about to be added.\n   * @returns {string}\n   */\n  static NEGATIVE_VALUES_WARNING(_ref) {\n    let {\n      row,\n      col,\n      rowspan,\n      colspan\n    } = _ref;\n    return toSingleLine`The merged cell declared with {row: ${row}, col: ${col},\\x20\n      rowspan: ${rowspan}, colspan: ${colspan}} contains negative values, which is\\x20\n      not supported. It will not be added to the collection.`;\n  }\n\n  /**\n   * Get a warning message for when the declared merged cell data contains values exceeding the table limits.\n   *\n   * @param {{ row: number, col: number, rowspan: number, colspan: number }} mergedCell Object containing information\n   * about the merged cells that was about to be added.\n   * @returns {string}\n   */\n  static IS_OUT_OF_BOUNDS_WARNING(_ref2) {\n    let {\n      row,\n      col\n    } = _ref2;\n    return toSingleLine`The merged cell declared at [${row}, ${col}] is positioned\\x20\n      (or positioned partially) outside of the table range. It was not added to the table, please fix your setup.`;\n  }\n\n  /**\n   * Get a warning message for when the declared merged cell data represents a single cell.\n   *\n   * @param {{ row: number, col: number, rowspan: number, colspan: number }} mergedCell Object containing information\n   * about the merged cells that was about to be added.\n   * @returns {string}\n   */\n  static IS_SINGLE_CELL(_ref3) {\n    let {\n      row,\n      col\n    } = _ref3;\n    return toSingleLine`The merged cell declared at [${row}, ${col}] has both \"rowspan\"\\x20\n      and \"colspan\" declared as \"1\", which makes it a single cell. It cannot be added to the collection.`;\n  }\n\n  /**\n   * Get a warning message for when the declared merged cell data contains \"colspan\" or \"rowspan\", that equals 0.\n   *\n   * @param {{ row: number, col: number, rowspan: number, colspan: number }} mergedCell Object containing information\n   * about the merged cells that was about to be added.\n   * @returns {string}\n   */\n  static ZERO_SPAN_WARNING(_ref4) {\n    let {\n      row,\n      col\n    } = _ref4;\n    return toSingleLine`The merged cell declared at [${row}, ${col}] has \"rowspan\"\\x20\n      or \"colspan\" declared as \"0\", which is not supported. It cannot be added to the collection.`;\n  }\n\n  /**\n   * Check whether the values provided for a merged cell contain any negative values.\n   *\n   * @param {{ row: number, col: number, rowspan: number, colspan: number }} mergedCell Object containing information\n   * about the merged cells that was about to be added.\n   * @returns {boolean}\n   */\n  static containsNegativeValues(_ref5) {\n    let {\n      row,\n      col,\n      rowspan,\n      colspan\n    } = _ref5;\n    return row < 0 || col < 0 || rowspan < 0 || colspan < 0;\n  }\n\n  /**\n   * Check whether the provided merged cell information object represents a single cell.\n   *\n   * @private\n   * @param {{ row: number, col: number, rowspan: number, colspan: number }} mergedCell Object containing information\n   * about the merged cells that was about to be added.\n   * @returns {boolean}\n   */\n  static isSingleCell(_ref6) {\n    let {\n      rowspan,\n      colspan\n    } = _ref6;\n    return colspan === 1 && rowspan === 1;\n  }\n\n  /**\n   * Check whether the provided merged cell information object contains a rowspan or colspan of 0.\n   *\n   * @private\n   * @param {{ row: number, col: number, rowspan: number, colspan: number }} mergedCell Object containing information\n   * about the merged cells that was about to be added.\n   * @returns {boolean}\n   */\n  static containsZeroSpan(_ref7) {\n    let {\n      rowspan,\n      colspan\n    } = _ref7;\n    return colspan === 0 || rowspan === 0;\n  }\n\n  /**\n   * Check whether the provided merged cell object is to be declared out of bounds of the table.\n   *\n   * @param {object} mergeCell Object containing the `row`, `col`, `rowspan` and `colspan` properties.\n   * @param {number} rowCount Number of rows in the table.\n   * @param {number} columnCount Number of rows in the table.\n   * @returns {boolean}\n   */\n  static isOutOfBounds(mergeCell, rowCount, columnCount) {\n    return mergeCell.row < 0 || mergeCell.col < 0 || mergeCell.row >= rowCount || mergeCell.row + mergeCell.rowspan - 1 >= rowCount || mergeCell.col >= columnCount || mergeCell.col + mergeCell.colspan - 1 >= columnCount;\n  }\n\n  /**\n   * Sanitize (prevent from going outside the boundaries) the merged cell.\n   *\n   * @param {Core} hotInstance The Handsontable instance.\n   */\n  normalize(hotInstance) {\n    const totalRows = hotInstance.countRows();\n    const totalColumns = hotInstance.countCols();\n    if (this.row < 0) {\n      this.row = 0;\n    } else if (this.row > totalRows - 1) {\n      this.row = totalRows - 1;\n    }\n    if (this.col < 0) {\n      this.col = 0;\n    } else if (this.col > totalColumns - 1) {\n      this.col = totalColumns - 1;\n    }\n    if (this.row + this.rowspan > totalRows - 1) {\n      this.rowspan = totalRows - this.row;\n    }\n    if (this.col + this.colspan > totalColumns - 1) {\n      this.colspan = totalColumns - this.col;\n    }\n    _classPrivateFieldSet(_cellRange, this, null);\n  }\n\n  /**\n   * Returns `true` if the provided coordinates are inside the merged cell.\n   *\n   * @param {number} row The row index.\n   * @param {number} column The column index.\n   * @returns {boolean}\n   */\n  includes(row, column) {\n    return this.row <= row && this.col <= column && this.row + this.rowspan - 1 >= row && this.col + this.colspan - 1 >= column;\n  }\n\n  /**\n   * Returns `true` if the provided `column` property is within the column span of the merged cell.\n   *\n   * @param {number} column The column index.\n   * @returns {boolean}\n   */\n  includesHorizontally(column) {\n    return this.col <= column && this.col + this.colspan - 1 >= column;\n  }\n\n  /**\n   * Returns `true` if the provided `row` property is within the row span of the merged cell.\n   *\n   * @param {number} row Row index.\n   * @returns {boolean}\n   */\n  includesVertically(row) {\n    return this.row <= row && this.row + this.rowspan - 1 >= row;\n  }\n\n  /**\n   * Shift (and possibly resize, if needed) the merged cell.\n   *\n   * @param {Array} shiftVector 2-element array containing the information on the shifting in the `x` and `y` axis.\n   * @param {number} indexOfChange Index of the preceding change.\n   * @returns {boolean} Returns `false` if the whole merged cell was removed.\n   */\n  shift(shiftVector, indexOfChange) {\n    const shiftValue = shiftVector[0] || shiftVector[1];\n    const shiftedIndex = indexOfChange + Math.abs(shiftVector[0] || shiftVector[1]) - 1;\n    const span = shiftVector[0] ? 'colspan' : 'rowspan';\n    const index = shiftVector[0] ? 'col' : 'row';\n    const changeStart = Math.min(indexOfChange, shiftedIndex);\n    const changeEnd = Math.max(indexOfChange, shiftedIndex);\n    const mergeStart = this[index];\n    const mergeEnd = this[index] + this[span] - 1;\n    if (mergeStart >= indexOfChange) {\n      this[index] += shiftValue;\n    }\n\n    // adding rows/columns\n    if (shiftValue > 0) {\n      if (indexOfChange <= mergeEnd && indexOfChange > mergeStart) {\n        this[span] += shiftValue;\n      }\n\n      // removing rows/columns\n    } else if (shiftValue < 0) {\n      // removing the whole merge\n      if (changeStart <= mergeStart && changeEnd >= mergeEnd) {\n        this.removed = true;\n        _classPrivateFieldSet(_cellRange, this, null);\n        return false;\n\n        // removing the merge partially, including the beginning\n      } else if (mergeStart >= changeStart && mergeStart <= changeEnd) {\n        const removedOffset = changeEnd - mergeStart + 1;\n        const preRemovedOffset = Math.abs(shiftValue) - removedOffset;\n        this[index] -= preRemovedOffset + shiftValue;\n        this[span] -= removedOffset;\n\n        // removing the middle part of the merge\n      } else if (mergeStart <= changeStart && mergeEnd >= changeEnd) {\n        this[span] += shiftValue;\n\n        // removing the end part of the merge\n      } else if (mergeStart <= changeStart && mergeEnd >= changeStart && mergeEnd < changeEnd) {\n        const removedPart = mergeEnd - changeStart + 1;\n        this[span] -= removedPart;\n      }\n    }\n    _classPrivateFieldSet(_cellRange, this, null);\n    return true;\n  }\n\n  /**\n   * Check if the second provided merged cell is \"farther\" in the provided direction.\n   *\n   * @param {MergedCellCoords} mergedCell The merged cell to check.\n   * @param {string} direction Drag direction.\n   * @returns {boolean|null} `true` if the second provided merged cell is \"farther\".\n   */\n  isFarther(mergedCell, direction) {\n    if (!mergedCell) {\n      return true;\n    }\n    if (direction === 'down') {\n      return mergedCell.row + mergedCell.rowspan - 1 < this.row + this.rowspan - 1;\n    } else if (direction === 'up') {\n      return mergedCell.row > this.row;\n    } else if (direction === 'right') {\n      return mergedCell.col + mergedCell.colspan - 1 < this.col + this.colspan - 1;\n    } else if (direction === 'left') {\n      return mergedCell.col > this.col;\n    }\n    return null;\n  }\n\n  /**\n   * Get the bottom row index of the merged cell.\n   *\n   * @returns {number}\n   */\n  getLastRow() {\n    return this.row + this.rowspan - 1;\n  }\n\n  /**\n   * Get the rightmost column index of the merged cell.\n   *\n   * @returns {number}\n   */\n  getLastColumn() {\n    return this.col + this.colspan - 1;\n  }\n\n  /**\n   * Get the range coordinates of the merged cell.\n   *\n   * @returns {CellRange}\n   */\n  getRange() {\n    if (!_classPrivateFieldGet(_cellRange, this)) {\n      _classPrivateFieldSet(_cellRange, this, this.cellRangeFactory(this.cellCoordsFactory(this.row, this.col), this.cellCoordsFactory(this.row, this.col), this.cellCoordsFactory(this.getLastRow(), this.getLastColumn())));\n    }\n    return _classPrivateFieldGet(_cellRange, this);\n  }\n}\nexport default MergedCellCoords;","import \"core-js/modules/es.error.cause.js\";\nimport \"core-js/modules/es.array.push.js\";\nimport \"core-js/modules/es.array.unscopables.flat-map.js\";\nimport \"core-js/modules/es.set.difference.v2.js\";\nimport \"core-js/modules/es.set.intersection.v2.js\";\nimport \"core-js/modules/es.set.is-disjoint-from.v2.js\";\nimport \"core-js/modules/es.set.is-subset-of.v2.js\";\nimport \"core-js/modules/es.set.is-superset-of.v2.js\";\nimport \"core-js/modules/es.set.symmetric-difference.v2.js\";\nimport \"core-js/modules/es.set.union.v2.js\";\nfunction _classPrivateMethodInitSpec(e, a) { _checkPrivateRedeclaration(e, a), a.add(e); }\nfunction _checkPrivateRedeclaration(e, t) { if (t.has(e)) throw new TypeError(\"Cannot initialize the same private elements twice on an object\"); }\nfunction _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == typeof i ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != typeof t || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != typeof i) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\nfunction _assertClassBrand(e, t, n) { if (\"function\" == typeof e ? e === t : e.has(t)) return arguments.length < 3 ? t : n; throw new TypeError(\"Private element is not present on this object\"); }\nimport MergedCellCoords from \"./cellCoords.mjs\";\nimport { rangeEach } from \"../../helpers/number.mjs\";\nimport { warn } from \"../../helpers/console.mjs\";\nimport { arrayEach } from \"../../helpers/array.mjs\";\nimport { toSingleLine } from \"../../helpers/templateLiteralTag.mjs\";\n/**\n * Defines a container object for the merged cells.\n *\n * @private\n * @class MergedCellsCollection\n */\nvar _MergedCellsCollection_brand = /*#__PURE__*/new WeakSet();\nclass MergedCellsCollection {\n  constructor(mergeCellsPlugin) {\n    /**\n     * Gets the list of the indexes that do not intersect with other merged cells within the provided range.\n     *\n     * @param {CellRange} range The range to search within.\n     * @param {'row' | 'col'} axis The axis to search within.\n     * @param {number} scanDirection  The direction to scan the range. `1` for forward, `-1` for backward.\n     * @returns {number[]}\n     */\n    _classPrivateMethodInitSpec(this, _MergedCellsCollection_brand);\n    /**\n     * Reference to the Merge Cells plugin.\n     *\n     * @type {MergeCells}\n     */\n    _defineProperty(this, \"plugin\", void 0);\n    /**\n     * Array of merged cells.\n     *\n     * @type {MergedCellCoords[]}\n     */\n    _defineProperty(this, \"mergedCells\", []);\n    /**\n     * Matrix of cells (row, col) that points to the instances of the MergedCellCoords objects.\n     *\n     * @type {Array}\n     */\n    _defineProperty(this, \"mergedCellsMatrix\", new Map());\n    /**\n     * The Handsontable instance.\n     *\n     * @type {Handsontable}\n     */\n    _defineProperty(this, \"hot\", void 0);\n    this.plugin = mergeCellsPlugin;\n    this.hot = mergeCellsPlugin.hot;\n  }\n\n  /**\n   * Get a warning message for when the declared merged cell data overlaps already existing merged cells.\n   *\n   * @param {{ row: number, col: number, rowspan: number, colspan: number }} mergedCell Object containing information\n   * about the merged cells that was about to be added.\n   * @returns {string}\n   */\n  static IS_OVERLAPPING_WARNING(_ref) {\n    let {\n      row,\n      col\n    } = _ref;\n    return toSingleLine`The merged cell declared at [${row}, ${col}], overlaps\\x20\n      with the other declared merged cell. The overlapping merged cell was not added to the table, please\\x20\n      fix your setup.`;\n  }\n\n  /**\n   * Get a merged cell from the container, based on the provided arguments. You can provide either the \"starting coordinates\"\n   * of a merged cell, or any coordinates from the body of the merged cell.\n   *\n   * @param {number} row Row index.\n   * @param {number} column Column index.\n   * @returns {MergedCellCoords|boolean} Returns a wanted merged cell on success and `false` on failure.\n   */\n  get(row, column) {\n    var _this$mergedCellsMatr;\n    if (!this.mergedCellsMatrix.has(row)) {\n      return false;\n    }\n    return (_this$mergedCellsMatr = this.mergedCellsMatrix.get(row).get(column)) !== null && _this$mergedCellsMatr !== void 0 ? _this$mergedCellsMatr : false;\n  }\n\n  /**\n   * Get the first-found merged cell containing the provided range.\n   *\n   * @param {CellRange|object} range The range to search merged cells for.\n   * @returns {MergedCellCoords|boolean}\n   */\n  getByRange(range) {\n    let result = false;\n    arrayEach(this.mergedCells, mergedCell => {\n      if (mergedCell.row <= range.from.row && mergedCell.row + mergedCell.rowspan - 1 >= range.to.row && mergedCell.col <= range.from.col && mergedCell.col + mergedCell.colspan - 1 >= range.to.col) {\n        result = mergedCell;\n        return result;\n      }\n      return true;\n    });\n    return result;\n  }\n\n  /**\n   * Filters merge cells objects provided by users from overlapping cells.\n   *\n   * @param {{ row: number, col: number, rowspan: number, colspan: number }} mergedCellsInfo The merged cell information object.\n   * Has to contain `row`, `col`, `colspan` and `rowspan` properties.\n   * @returns {Array<{ row: number, col: number, rowspan: number, colspan: number }>}\n   */\n  filterOverlappingMergeCells(mergedCellsInfo) {\n    const occupiedCells = new Set();\n    this.mergedCells.forEach(mergedCell => {\n      const {\n        row,\n        col,\n        colspan,\n        rowspan\n      } = mergedCell;\n      for (let r = row; r < row + rowspan; r++) {\n        for (let c = col; c < col + colspan; c++) {\n          occupiedCells.add(`r${r},c${c}`);\n        }\n      }\n    });\n    const filteredMergeCells = mergedCellsInfo.filter(mergedCell => {\n      const {\n        row,\n        col,\n        colspan,\n        rowspan\n      } = mergedCell;\n      const localOccupiedCells = new Set();\n      let isOverlapping = false;\n      for (let r = row; r < row + rowspan; r++) {\n        for (let c = col; c < col + colspan; c++) {\n          const cellId = `r${r},c${c}`;\n          if (occupiedCells.has(cellId)) {\n            warn(MergedCellsCollection.IS_OVERLAPPING_WARNING(mergedCell));\n            isOverlapping = true;\n            break;\n          }\n          localOccupiedCells.add(cellId);\n        }\n        if (isOverlapping) {\n          break;\n        }\n      }\n      if (!isOverlapping) {\n        occupiedCells.add(...localOccupiedCells);\n      }\n      return !isOverlapping;\n    });\n    return filteredMergeCells;\n  }\n\n  /**\n   * Get a merged cell contained in the provided range.\n   *\n   * @param {CellRange} range The range to search merged cells in.\n   * @param {boolean} [countPartials=false] If set to `true`, all the merged cells overlapping the range will be taken into calculation.\n   * @returns {MergedCellCoords[]} Array of found merged cells.\n   */\n  getWithinRange(range) {\n    let countPartials = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n    const {\n      row: rowStart,\n      col: columnStart\n    } = range.getTopStartCorner();\n    const {\n      row: rowEnd,\n      col: columnEnd\n    } = range.getBottomEndCorner();\n    const result = [];\n    for (let row = rowStart; row <= rowEnd; row++) {\n      for (let column = columnStart; column <= columnEnd; column++) {\n        const mergedCell = this.get(row, column);\n        if (mergedCell && (countPartials || !countPartials && mergedCell.row === row && mergedCell.col === column)) {\n          result.push(mergedCell);\n        }\n      }\n    }\n    return result;\n  }\n\n  /**\n   * Add a merged cell to the container.\n   *\n   * @param {object} mergedCellInfo The merged cell information object. Has to contain `row`, `col`, `colspan` and `rowspan` properties.\n   * @param {boolean} [auto=false] `true` if called internally by the plugin (usually in batch).\n   * @returns {MergedCellCoords|boolean} Returns the new merged cell on success and `false` on failure.\n   */\n  add(mergedCellInfo) {\n    let auto = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n    const row = mergedCellInfo.row;\n    const column = mergedCellInfo.col;\n    const rowspan = mergedCellInfo.rowspan;\n    const colspan = mergedCellInfo.colspan;\n    const newMergedCell = new MergedCellCoords(row, column, rowspan, colspan, this.hot._createCellCoords, this.hot._createCellRange);\n    const alreadyExists = this.get(row, column);\n    const isOverlapping = auto ? false : this.isOverlapping(newMergedCell);\n    if (!alreadyExists && !isOverlapping) {\n      if (this.hot) {\n        newMergedCell.normalize(this.hot);\n      }\n      this.mergedCells.push(newMergedCell);\n      _assertClassBrand(_MergedCellsCollection_brand, this, _addMergedCellToMatrix).call(this, newMergedCell);\n      return newMergedCell;\n    }\n    warn(MergedCellsCollection.IS_OVERLAPPING_WARNING(newMergedCell));\n    return false;\n  }\n\n  /**\n   * Remove a merged cell from the container. You can provide either the \"starting coordinates\"\n   * of a merged cell, or any coordinates from the body of the merged cell.\n   *\n   * @param {number} row Row index.\n   * @param {number} column Column index.\n   * @returns {MergedCellCoords|boolean} Returns the removed merged cell on success and `false` on failure.\n   */\n  remove(row, column) {\n    const mergedCell = this.get(row, column);\n    const mergedCellIndex = mergedCell ? this.mergedCells.indexOf(mergedCell) : -1;\n    if (mergedCell && mergedCellIndex !== -1) {\n      this.mergedCells.splice(mergedCellIndex, 1);\n      _assertClassBrand(_MergedCellsCollection_brand, this, _removeMergedCellFromMatrix).call(this, mergedCell);\n      return mergedCell;\n    }\n    return false;\n  }\n\n  /**\n   * Clear all the merged cells.\n   */\n  clear() {\n    arrayEach(this.mergedCells, _ref2 => {\n      let {\n        row,\n        col,\n        rowspan,\n        colspan\n      } = _ref2;\n      rangeEach(row, row + rowspan, r => {\n        rangeEach(col, col + colspan, c => {\n          const TD = this.hot.getCell(r, c);\n          if (TD) {\n            TD.removeAttribute('rowspan');\n            TD.removeAttribute('colspan');\n            TD.style.display = '';\n          }\n        });\n      });\n    });\n    this.mergedCells.length = 0;\n    this.mergedCellsMatrix = new Map();\n  }\n\n  /**\n   * Check if the provided merged cell overlaps with the others already added.\n   *\n   * @param {MergedCellCoords} mergedCell The merged cell to check against all others in the container.\n   * @returns {boolean} `true` if the provided merged cell overlaps with the others, `false` otherwise.\n   */\n  isOverlapping(mergedCell) {\n    const mergedCellRange = mergedCell.getRange();\n    for (let i = 0; i < this.mergedCells.length; i++) {\n      const otherMergedCell = this.mergedCells[i];\n      const otherMergedCellRange = otherMergedCell.getRange();\n      if (otherMergedCellRange.overlaps(mergedCellRange)) {\n        return true;\n      }\n    }\n    return false;\n  }\n\n  /**\n   * Check whether the provided row/col coordinates direct to a first not hidden cell within merge area.\n   *\n   * @param {number} row Visual row index.\n   * @param {number} column Visual column index.\n   * @returns {boolean}\n   */\n  isFirstRenderableMergedCell(row, column) {\n    const mergeParent = this.get(row, column);\n\n    // Return if row and column indexes are within merge area and if they are first rendered indexes within the area.\n    return mergeParent && this.hot.rowIndexMapper.getNearestNotHiddenIndex(mergeParent.row, 1) === row && this.hot.columnIndexMapper.getNearestNotHiddenIndex(mergeParent.col, 1) === column;\n  }\n\n  /**\n   * Get the first renderable coords of the merged cell at the provided coordinates.\n   *\n   * @param {number} row Visual row index.\n   * @param {number} column Visual column index.\n   * @returns {CellCoords} A `CellCoords` object with the coordinates to the first renderable cell within the\n   *                        merged cell.\n   */\n  getFirstRenderableCoords(row, column) {\n    const mergeParent = this.get(row, column);\n    if (!mergeParent || this.isFirstRenderableMergedCell(row, column)) {\n      return this.hot._createCellCoords(row, column);\n    }\n    const firstRenderableRow = this.hot.rowIndexMapper.getNearestNotHiddenIndex(mergeParent.row, 1);\n    const firstRenderableColumn = this.hot.columnIndexMapper.getNearestNotHiddenIndex(mergeParent.col, 1);\n    return this.hot._createCellCoords(firstRenderableRow, firstRenderableColumn);\n  }\n\n  /**\n   * Gets the start-most visual column index that do not intersect with other merged cells within the provided range.\n   *\n   * @param {CellRange} range The range to search within.\n   * @param {number} visualColumnIndex The visual column index to start the search from.\n   * @returns {number}\n   */\n  getStartMostColumnIndex(range, visualColumnIndex) {\n    const indexes = _assertClassBrand(_MergedCellsCollection_brand, this, _getNonIntersectingIndexes).call(this, range, 'col', -1);\n    let startMostIndex = visualColumnIndex;\n    for (let i = 0; i < indexes.length; i++) {\n      if (indexes[i] <= visualColumnIndex) {\n        startMostIndex = indexes[i];\n        break;\n      }\n    }\n    return startMostIndex;\n  }\n\n  /**\n   * Gets the end-most visual column index that do not intersect with other merged cells within the provided range.\n   *\n   * @param {CellRange} range The range to search within.\n   * @param {number} visualColumnIndex The visual column index to start the search from.\n   * @returns {number}\n   */\n  getEndMostColumnIndex(range, visualColumnIndex) {\n    const indexes = _assertClassBrand(_MergedCellsCollection_brand, this, _getNonIntersectingIndexes).call(this, range, 'col', 1);\n    let endMostIndex = visualColumnIndex;\n    for (let i = 0; i < indexes.length; i++) {\n      if (indexes[i] >= visualColumnIndex) {\n        endMostIndex = indexes[i];\n        break;\n      }\n    }\n    return endMostIndex;\n  }\n\n  /**\n   * Gets the top-most visual row index that do not intersect with other merged cells within the provided range.\n   *\n   * @param {CellRange} range The range to search within.\n   * @param {number} visualRowIndex The visual row index to start the search from.\n   * @returns {number}\n   */\n  getTopMostRowIndex(range, visualRowIndex) {\n    const indexes = _assertClassBrand(_MergedCellsCollection_brand, this, _getNonIntersectingIndexes).call(this, range, 'row', -1);\n    let topMostIndex = visualRowIndex;\n    for (let i = 0; i < indexes.length; i++) {\n      if (indexes[i] <= visualRowIndex) {\n        topMostIndex = indexes[i];\n        break;\n      }\n    }\n    return topMostIndex;\n  }\n\n  /**\n   * Gets the bottom-most visual row index that do not intersect with other merged cells within the provided range.\n   *\n   * @param {CellRange} range The range to search within.\n   * @param {number} visualRowIndex The visual row index to start the search from.\n   * @returns {number}\n   */\n  getBottomMostRowIndex(range, visualRowIndex) {\n    const indexes = _assertClassBrand(_MergedCellsCollection_brand, this, _getNonIntersectingIndexes).call(this, range, 'row', 1);\n    let bottomMostIndex = visualRowIndex;\n    for (let i = 0; i < indexes.length; i++) {\n      if (indexes[i] >= visualRowIndex) {\n        bottomMostIndex = indexes[i];\n        break;\n      }\n    }\n    return bottomMostIndex;\n  }\n  /**\n   * Shift the merged cell in the direction and by an offset defined in the arguments.\n   *\n   * @param {string} direction `right`, `left`, `up` or `down`.\n   * @param {number} index Index where the change, which caused the shifting took place.\n   * @param {number} count Number of rows/columns added/removed in the preceding action.\n   */\n  shiftCollections(direction, index, count) {\n    const shiftVector = [0, 0];\n    switch (direction) {\n      case 'right':\n        shiftVector[0] += count;\n        break;\n      case 'left':\n        shiftVector[0] -= count;\n        break;\n      case 'down':\n        shiftVector[1] += count;\n        break;\n      case 'up':\n        shiftVector[1] -= count;\n        break;\n      default:\n    }\n    const removedMergedCells = [];\n    this.mergedCells.forEach(currentMerge => {\n      currentMerge.shift(shiftVector, index);\n      if (currentMerge.removed) {\n        removedMergedCells.push(currentMerge);\n      }\n    });\n    removedMergedCells.forEach(removedMerge => {\n      this.mergedCells.splice(this.mergedCells.indexOf(removedMerge), 1);\n    });\n    this.mergedCellsMatrix.clear();\n    this.mergedCells.forEach(currentMerge => {\n      _assertClassBrand(_MergedCellsCollection_brand, this, _addMergedCellToMatrix).call(this, currentMerge);\n    });\n  }\n\n  /**\n   * Adds a merged cell to the matrix.\n   *\n   * @param {MergedCellCoords} mergedCell The merged cell to add.\n   */\n}\nfunction _getNonIntersectingIndexes(range, axis) {\n  let scanDirection = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;\n  const indexes = new Map();\n  const from = scanDirection === 1 ? range.getTopStartCorner() : range.getBottomEndCorner();\n  const to = scanDirection === 1 ? range.getBottomEndCorner() : range.getTopStartCorner();\n  for (let row = from.row; scanDirection === 1 ? row <= to.row : row >= to.row; row += scanDirection) {\n    for (let column = from.col; scanDirection === 1 ? column <= to.col : column >= to.col; column += scanDirection) {\n      const index = axis === 'row' ? row : column;\n      const mergedCell = this.get(row, column);\n      let lastIndex = index;\n      if (mergedCell) {\n        lastIndex = scanDirection === 1 ? mergedCell[axis] + mergedCell[`${axis}span`] - 1 : mergedCell[axis];\n      }\n      if (!indexes.has(index)) {\n        indexes.set(index, new Set());\n      }\n      indexes.get(index).add(lastIndex);\n    }\n  }\n  return Array.from(new Set(Array.from(indexes.entries()).filter(_ref3 => {\n    let [, set] = _ref3;\n    return set.size === 1;\n  }).flatMap(_ref4 => {\n    let [, set] = _ref4;\n    return Array.from(set);\n  })));\n}\nfunction _addMergedCellToMatrix(mergedCell) {\n  for (let row = mergedCell.row; row < mergedCell.row + mergedCell.rowspan; row++) {\n    for (let col = mergedCell.col; col < mergedCell.col + mergedCell.colspan; col++) {\n      if (!this.mergedCellsMatrix.has(row)) {\n        this.mergedCellsMatrix.set(row, new Map());\n      }\n      this.mergedCellsMatrix.get(row).set(col, mergedCell);\n    }\n  }\n}\n/**\n * Removes a merged cell from the matrix.\n *\n * @param {MergedCellCoords} mergedCell The merged cell to remove.\n */\nfunction _removeMergedCellFromMatrix(mergedCell) {\n  for (let row = mergedCell.row; row < mergedCell.row + mergedCell.rowspan; row++) {\n    for (let col = mergedCell.col; col < mergedCell.col + mergedCell.colspan; col++) {\n      this.mergedCellsMatrix.get(row).delete(col);\n    }\n  }\n}\nexport default MergedCellsCollection;","import { warn } from \"../../helpers/console.mjs\";\nimport { toSingleLine } from \"../../helpers/templateLiteralTag.mjs\";\n/**\n * Warn users about problems when using `columnSorting` and `multiColumnSorting` plugins simultaneously.\n */\nexport function warnAboutPluginsConflict() {\n  warn(toSingleLine`Plugins \\`columnSorting\\` and \\`multiColumnSorting\\` should not be enabled simultaneously. \n    Only \\`multiColumnSorting\\` will work. The \\`columnSorting\\` plugin will be disabled.`);\n}","import \"core-js/modules/es.error.cause.js\";\nimport \"core-js/modules/es.array.push.js\";\nimport { toSingleLine } from \"../../../../helpers/templateLiteralTag.mjs\";\n/**\n * @param {TreeNode} nodeToProcess A tree node to process.\n * @param {number} gridColumnIndex The visual column index that triggers the node modification.\n *                                 The index can be between the root node column index and\n *                                 column index plus node colspan length.\n */\nexport function hideColumn(nodeToProcess, gridColumnIndex) {\n  if (!Number.isInteger(gridColumnIndex)) {\n    throw new Error('The passed gridColumnIndex argument has invalid type.');\n  }\n  if (nodeToProcess.childs.length > 0) {\n    throw new Error(toSingleLine`The passed node is not the last node on the tree. Only for\\x20\nthe last node, the hide column modification can be applied.`);\n  }\n  const {\n    crossHiddenColumns\n  } = nodeToProcess.data;\n  if (crossHiddenColumns.includes(gridColumnIndex)) {\n    return;\n  }\n  let isCollapsibleNode = false;\n  nodeToProcess.walkUp(node => {\n    const {\n      data: {\n        collapsible\n      }\n    } = node;\n    if (collapsible) {\n      isCollapsibleNode = true;\n      return false; // Cancel tree traversing\n    }\n  });\n\n  // TODO: When the node is collapsible do not hide the column. Currently collapsible headers\n  // does not work with hidden columns (hidden index map types).\n  if (isCollapsibleNode) {\n    return;\n  }\n  nodeToProcess.walkUp(node => {\n    const {\n      data\n    } = node;\n    data.crossHiddenColumns.push(gridColumnIndex);\n    if (data.colspan > 1) {\n      data.colspan -= 1;\n    } else {\n      data.isHidden = true;\n    }\n  });\n}","import \"core-js/modules/es.error.cause.js\";\nimport { toSingleLine } from \"../../../../helpers/templateLiteralTag.mjs\";\n/**\n * @param {TreeNode} nodeToProcess A tree node to process.\n * @param {number} gridColumnIndex The visual column index that triggers the node modification.\n *                                 The index can be between the root node column index and\n *                                 column index plus node colspan length.\n */\nexport function showColumn(nodeToProcess, gridColumnIndex) {\n  if (!Number.isInteger(gridColumnIndex)) {\n    throw new Error('The passed gridColumnIndex argument has invalid type.');\n  }\n  if (nodeToProcess.childs.length > 0) {\n    throw new Error(toSingleLine`The passed node is not the last node on the tree. Only for\\x20\nthe last node, the show column modification can be applied.`);\n  }\n  const {\n    crossHiddenColumns\n  } = nodeToProcess.data;\n  if (!crossHiddenColumns.includes(gridColumnIndex)) {\n    return;\n  }\n  let isCollapsibleNode = false;\n  nodeToProcess.walkUp(node => {\n    const {\n      data: {\n        collapsible\n      }\n    } = node;\n    if (collapsible) {\n      isCollapsibleNode = true;\n      return false; // Cancel tree traversing\n    }\n  });\n\n  // TODO: When the node is collapsible do not show the column. Currently collapsible headers\n  // does not work with hidden columns (hidden index map types).\n  if (isCollapsibleNode) {\n    return;\n  }\n  nodeToProcess.walkUp(node => {\n    const {\n      data\n    } = node;\n    data.crossHiddenColumns.splice(data.crossHiddenColumns.indexOf(gridColumnIndex), 1);\n    if (!data.isHidden && data.colspan < data.origColspan) {\n      data.colspan += 1;\n    }\n    data.isHidden = false;\n  });\n}","import \"core-js/modules/es.error.cause.js\";\nimport \"core-js/modules/es.array.push.js\";\nfunction _classPrivateMethodInitSpec(e, a) { _checkPrivateRedeclaration(e, a), a.add(e); }\nfunction _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == typeof i ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != typeof t || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != typeof i) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\nfunction _classPrivateFieldInitSpec(e, t, a) { _checkPrivateRedeclaration(e, t), t.set(e, a); }\nfunction _checkPrivateRedeclaration(e, t) { if (t.has(e)) throw new TypeError(\"Cannot initialize the same private elements twice on an object\"); }\nfunction _classPrivateFieldSet(s, a, r) { return s.set(_assertClassBrand(s, a), r), r; }\nfunction _classPrivateFieldGet(s, a) { return s.get(_assertClassBrand(s, a)); }\nfunction _assertClassBrand(e, t, n) { if (\"function\" == typeof e ? e === t : e.has(t)) return arguments.length < 3 ? t : n; throw new TypeError(\"Private element is not present on this object\"); }\nimport { addClass, removeClass } from \"../../helpers/dom/element.mjs\";\nimport { isNumeric, clamp } from \"../../helpers/number.mjs\";\nimport { toSingleLine } from \"../../helpers/templateLiteralTag.mjs\";\nimport { isLeftClick, isRightClick, isTouchEvent } from \"../../helpers/dom/event.mjs\";\nimport { warn } from \"../../helpers/console.mjs\";\nimport { ACTIVE_HEADER_TYPE, HEADER_TYPE } from \"../../selection/index.mjs\";\nimport { BasePlugin } from \"../base/index.mjs\";\nimport StateManager from \"./stateManager/index.mjs\";\nimport GhostTable from \"./utils/ghostTable.mjs\";\nexport const PLUGIN_KEY = 'nestedHeaders';\nexport const PLUGIN_PRIORITY = 280;\n\n/* eslint-disable jsdoc/require-description-complete-sentence */\n\n/**\n * @plugin NestedHeaders\n * @class NestedHeaders\n *\n * @description\n * The plugin allows to create a nested header structure, using the HTML's colspan attribute.\n *\n * To make any header wider (covering multiple table columns), it's corresponding configuration array element should be\n * provided as an object with `label` and `colspan` properties. The `label` property defines the header's label,\n * while the `colspan` property defines a number of columns that the header should cover.\n * You can also set custom class names to any of the headers by providing the `headerClassName` property.\n *\n * __Note__ that the plugin supports a *nested* structure, which means, any header cannot be wider than it's \"parent\". In\n * other words, headers cannot overlap each other.\n * @example\n *\n * ::: only-for javascript\n * ```js\n * const container = document.getElementById('example');\n * const hot = new Handsontable(container, {\n *   data: getData(),\n *   nestedHeaders: [\n *     ['A', {label: 'B', colspan: 8, headerClassName: 'htRight'}, 'C'],\n *     ['D', {label: 'E', colspan: 4}, {label: 'F', colspan: 4}, 'G'],\n *     ['H', {label: 'I', colspan: 2}, {label: 'J', colspan: 2}, {label: 'K', colspan: 2}, {label: 'L', colspan: 2}, 'M'],\n *     ['N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W']\n *  ],\n * ```\n * :::\n *\n * ::: only-for react\n * ```jsx\n * <HotTable\n *   data={getData()}\n *   nestedHeaders={[\n *     ['A', {label: 'B', colspan: 8, headerClassName: 'htRight'}, 'C'],\n *     ['D', {label: 'E', colspan: 4}, {label: 'F', colspan: 4}, 'G'],\n *     ['H', {label: 'I', colspan: 2}, {label: 'J', colspan: 2}, {label: 'K', colspan: 2}, {label: 'L', colspan: 2}, 'M'],\n *     ['N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W']\n *  ]}\n * />\n * ```\n * :::\n */\nvar _stateManager = /*#__PURE__*/new WeakMap();\nvar _hidingIndexMapObserver = /*#__PURE__*/new WeakMap();\nvar _focusInitialCoords = /*#__PURE__*/new WeakMap();\nvar _isColumnsSelectionInProgress = /*#__PURE__*/new WeakMap();\nvar _NestedHeaders_brand = /*#__PURE__*/new WeakSet();\nexport class NestedHeaders extends BasePlugin {\n  constructor() {\n    super(...arguments);\n    /**\n     * Updates the selection focus highlight position to point to the nested header root element (TH)\n     * even when the logical coordinates point in-between the header.\n     */\n    _classPrivateMethodInitSpec(this, _NestedHeaders_brand);\n    /**\n     * The state manager for the nested headers.\n     *\n     * @type {StateManager}\n     */\n    _classPrivateFieldInitSpec(this, _stateManager, new StateManager());\n    /**\n     * The instance of the ChangesObservable class that allows track the changes that happens in the\n     * column indexes.\n     *\n     * @type {ChangesObservable}\n     */\n    _classPrivateFieldInitSpec(this, _hidingIndexMapObserver, null);\n    /**\n     * Holds the coords that points to the place where the column selection starts.\n     *\n     * @type {number|null}\n     */\n    _classPrivateFieldInitSpec(this, _focusInitialCoords, null);\n    /**\n     * Determines if there is performed the column selection.\n     *\n     * @type {boolean}\n     */\n    _classPrivateFieldInitSpec(this, _isColumnsSelectionInProgress, false);\n    /**\n     * Custom helper for getting widths of the nested headers.\n     *\n     * @private\n     * @type {GhostTable}\n     */\n    // @TODO This should be changed after refactor handsontable/utils/ghostTable.\n    _defineProperty(this, \"ghostTable\", new GhostTable(this.hot, (row, column) => this.getHeaderSettings(row, column)));\n    /**\n     * The flag which determines that the nested header settings contains overlapping headers\n     * configuration.\n     *\n     * @type {boolean}\n     */\n    _defineProperty(this, \"detectedOverlappedHeaders\", false);\n  }\n  static get PLUGIN_KEY() {\n    return PLUGIN_KEY;\n  }\n  static get PLUGIN_PRIORITY() {\n    return PLUGIN_PRIORITY;\n  }\n  /**\n   * Check if plugin is enabled.\n   *\n   * @returns {boolean}\n   */\n  isEnabled() {\n    return !!this.hot.getSettings()[PLUGIN_KEY];\n  }\n\n  /**\n   * Enables the plugin functionality for this Handsontable instance.\n   */\n  enablePlugin() {\n    var _this = this;\n    if (this.enabled) {\n      return;\n    }\n    const {\n      nestedHeaders\n    } = this.hot.getSettings();\n    if (!Array.isArray(nestedHeaders) || !Array.isArray(nestedHeaders[0])) {\n      warn(toSingleLine`Your Nested Headers plugin configuration is invalid. The settings has to be\\x20\n                        passed as an array of arrays e.q. [['A1', { label: 'A2', colspan: 2 }]]`);\n    }\n    this.addHook('init', () => _assertClassBrand(_NestedHeaders_brand, this, _onInit).call(this));\n    this.addHook('afterLoadData', function () {\n      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n        args[_key] = arguments[_key];\n      }\n      return _assertClassBrand(_NestedHeaders_brand, _this, _onAfterLoadData).call(_this, ...args);\n    });\n    this.addHook('beforeOnCellMouseDown', function () {\n      for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n        args[_key2] = arguments[_key2];\n      }\n      return _assertClassBrand(_NestedHeaders_brand, _this, _onBeforeOnCellMouseDown).call(_this, ...args);\n    });\n    this.addHook('afterOnCellMouseDown', function () {\n      for (var _len3 = arguments.length, args = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {\n        args[_key3] = arguments[_key3];\n      }\n      return _assertClassBrand(_NestedHeaders_brand, _this, _onAfterOnCellMouseDown).call(_this, ...args);\n    });\n    this.addHook('beforeOnCellMouseOver', function () {\n      for (var _len4 = arguments.length, args = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {\n        args[_key4] = arguments[_key4];\n      }\n      return _assertClassBrand(_NestedHeaders_brand, _this, _onBeforeOnCellMouseOver).call(_this, ...args);\n    });\n    this.addHook('beforeOnCellMouseUp', function () {\n      for (var _len5 = arguments.length, args = new Array(_len5), _key5 = 0; _key5 < _len5; _key5++) {\n        args[_key5] = arguments[_key5];\n      }\n      return _assertClassBrand(_NestedHeaders_brand, _this, _onBeforeOnCellMouseUp).call(_this, ...args);\n    });\n    this.addHook('beforeSelectionHighlightSet', function () {\n      for (var _len6 = arguments.length, args = new Array(_len6), _key6 = 0; _key6 < _len6; _key6++) {\n        args[_key6] = arguments[_key6];\n      }\n      return _assertClassBrand(_NestedHeaders_brand, _this, _onBeforeSelectionHighlightSet).call(_this, ...args);\n    });\n    this.addHook('modifyTransformStart', function () {\n      for (var _len7 = arguments.length, args = new Array(_len7), _key7 = 0; _key7 < _len7; _key7++) {\n        args[_key7] = arguments[_key7];\n      }\n      return _assertClassBrand(_NestedHeaders_brand, _this, _onModifyTransformStart).call(_this, ...args);\n    });\n    this.addHook('afterSelection', () => _assertClassBrand(_NestedHeaders_brand, this, _updateFocusHighlightPosition).call(this));\n    this.addHook('afterSelectionFocusSet', () => _assertClassBrand(_NestedHeaders_brand, this, _updateFocusHighlightPosition).call(this));\n    this.addHook('beforeViewportScrollHorizontally', function () {\n      for (var _len8 = arguments.length, args = new Array(_len8), _key8 = 0; _key8 < _len8; _key8++) {\n        args[_key8] = arguments[_key8];\n      }\n      return _assertClassBrand(_NestedHeaders_brand, _this, _onBeforeViewportScrollHorizontally).call(_this, ...args);\n    });\n    this.addHook('afterGetColumnHeaderRenderers', array => _assertClassBrand(_NestedHeaders_brand, this, _onAfterGetColumnHeaderRenderers).call(this, array));\n    this.addHook('modifyColWidth', function () {\n      for (var _len9 = arguments.length, args = new Array(_len9), _key9 = 0; _key9 < _len9; _key9++) {\n        args[_key9] = arguments[_key9];\n      }\n      return _assertClassBrand(_NestedHeaders_brand, _this, _onModifyColWidth).call(_this, ...args);\n    });\n    this.addHook('modifyColumnHeaderValue', function () {\n      for (var _len10 = arguments.length, args = new Array(_len10), _key10 = 0; _key10 < _len10; _key10++) {\n        args[_key10] = arguments[_key10];\n      }\n      return _assertClassBrand(_NestedHeaders_brand, _this, _onModifyColumnHeaderValue).call(_this, ...args);\n    });\n    this.addHook('beforeHighlightingColumnHeader', function () {\n      for (var _len11 = arguments.length, args = new Array(_len11), _key11 = 0; _key11 < _len11; _key11++) {\n        args[_key11] = arguments[_key11];\n      }\n      return _assertClassBrand(_NestedHeaders_brand, _this, _onBeforeHighlightingColumnHeader).call(_this, ...args);\n    });\n    this.addHook('beforeCopy', function () {\n      for (var _len12 = arguments.length, args = new Array(_len12), _key12 = 0; _key12 < _len12; _key12++) {\n        args[_key12] = arguments[_key12];\n      }\n      return _assertClassBrand(_NestedHeaders_brand, _this, _onBeforeCopy).call(_this, ...args);\n    });\n    this.addHook('beforeSelectColumns', function () {\n      for (var _len13 = arguments.length, args = new Array(_len13), _key13 = 0; _key13 < _len13; _key13++) {\n        args[_key13] = arguments[_key13];\n      }\n      return _assertClassBrand(_NestedHeaders_brand, _this, _onBeforeSelectColumns).call(_this, ...args);\n    });\n    this.addHook('afterViewportColumnCalculatorOverride', function () {\n      for (var _len14 = arguments.length, args = new Array(_len14), _key14 = 0; _key14 < _len14; _key14++) {\n        args[_key14] = arguments[_key14];\n      }\n      return _assertClassBrand(_NestedHeaders_brand, _this, _onAfterViewportColumnCalculatorOverride).call(_this, ...args);\n    });\n    this.addHook('modifyFocusedElement', function () {\n      for (var _len15 = arguments.length, args = new Array(_len15), _key15 = 0; _key15 < _len15; _key15++) {\n        args[_key15] = arguments[_key15];\n      }\n      return _assertClassBrand(_NestedHeaders_brand, _this, _onModifyFocusedElement).call(_this, ...args);\n    });\n    this.hot.columnIndexMapper.addLocalHook('cacheUpdated', () => _assertClassBrand(_NestedHeaders_brand, this, _updateFocusHighlightPosition).call(this));\n    this.hot.rowIndexMapper.addLocalHook('cacheUpdated', () => _assertClassBrand(_NestedHeaders_brand, this, _updateFocusHighlightPosition).call(this));\n    super.enablePlugin();\n    this.updatePlugin(); // @TODO: Workaround for broken plugin initialization abstraction.\n  }\n\n  /**\n   * Updates the plugin's state.\n   *\n   * This method is executed when [`updateSettings()`](@/api/core.md#updatesettings) is invoked with any of the following configuration options:\n   *  - [`nestedHeaders`](@/api/options.md#nestedheaders)\n   */\n  updatePlugin() {\n    if (!this.hot.view) {\n      // @TODO: Workaround for broken plugin initialization abstraction.\n      return;\n    }\n    const {\n      nestedHeaders\n    } = this.hot.getSettings();\n    _classPrivateFieldGet(_stateManager, this).setColumnsLimit(this.hot.countCols());\n    if (Array.isArray(nestedHeaders)) {\n      this.detectedOverlappedHeaders = _classPrivateFieldGet(_stateManager, this).setState(nestedHeaders);\n    }\n    if (this.detectedOverlappedHeaders) {\n      warn(toSingleLine`Your Nested Headers plugin setup contains overlapping headers. This kind of configuration\\x20\n                        is currently not supported.`);\n    }\n    if (this.enabled) {\n      // This line covers the case when a developer uses the external hiding maps to manipulate\n      // the columns' visibility. The tree state built from the settings - which is always built\n      // as if all the columns are visible, needs to be modified to be in sync with a dataset.\n      this.hot.columnIndexMapper.hidingMapsCollection.getMergedValues().forEach((isColumnHidden, physicalColumnIndex) => {\n        const actionName = isColumnHidden === true ? 'hide-column' : 'show-column';\n        _classPrivateFieldGet(_stateManager, this).triggerColumnModification(actionName, physicalColumnIndex);\n      });\n    }\n    if (!_classPrivateFieldGet(_hidingIndexMapObserver, this) && this.enabled) {\n      _classPrivateFieldSet(_hidingIndexMapObserver, this, this.hot.columnIndexMapper.createChangesObserver('hiding').subscribe(changes => {\n        changes.forEach(_ref => {\n          let {\n            op,\n            index: columnIndex,\n            newValue\n          } = _ref;\n          if (op === 'replace') {\n            const actionName = newValue === true ? 'hide-column' : 'show-column';\n            _classPrivateFieldGet(_stateManager, this).triggerColumnModification(actionName, columnIndex);\n          }\n        });\n        this.ghostTable.buildWidthsMap();\n      }));\n    }\n    this.ghostTable.setLayersCount(this.getLayersCount()).buildWidthsMap();\n    super.updatePlugin();\n  }\n\n  /**\n   * Disables the plugin functionality for this Handsontable instance.\n   */\n  disablePlugin() {\n    this.clearColspans();\n    _classPrivateFieldGet(_stateManager, this).clear();\n    _classPrivateFieldGet(_hidingIndexMapObserver, this).unsubscribe();\n    _classPrivateFieldSet(_hidingIndexMapObserver, this, null);\n    this.ghostTable.clear();\n    super.disablePlugin();\n  }\n\n  /**\n   * Returns an instance of the internal state manager of the plugin.\n   *\n   * @private\n   * @returns {StateManager}\n   */\n  getStateManager() {\n    return _classPrivateFieldGet(_stateManager, this);\n  }\n\n  /**\n   * Gets a total number of headers levels.\n   *\n   * @private\n   * @returns {number}\n   */\n  getLayersCount() {\n    return _classPrivateFieldGet(_stateManager, this).getLayersCount();\n  }\n\n  /**\n   * Gets column settings for a specified header. The returned object contains\n   * information about the header label, its colspan length, or if it is hidden\n   * in the header renderers.\n   *\n   * @private\n   * @param {number} headerLevel Header level (0 = most distant to the table).\n   * @param {number} columnIndex A visual column index.\n   * @returns {object}\n   */\n  getHeaderSettings(headerLevel, columnIndex) {\n    return _classPrivateFieldGet(_stateManager, this).getHeaderSettings(headerLevel, columnIndex);\n  }\n\n  /**\n   * Clear the colspans remaining after plugin usage.\n   *\n   * @private\n   */\n  clearColspans() {\n    if (!this.hot.view) {\n      return;\n    }\n    const {\n      _wt: wt\n    } = this.hot.view;\n    const headerLevels = wt.getSetting('columnHeaders').length;\n    const mainHeaders = wt.wtTable.THEAD;\n    const topHeaders = wt.wtOverlays.topOverlay.clone.wtTable.THEAD;\n    const topLeftCornerHeaders = wt.wtOverlays.topInlineStartCornerOverlay ? wt.wtOverlays.topInlineStartCornerOverlay.clone.wtTable.THEAD : null;\n    for (let i = 0; i < headerLevels; i++) {\n      const masterLevel = mainHeaders.childNodes[i];\n      if (!masterLevel) {\n        break;\n      }\n      const topLevel = topHeaders.childNodes[i];\n      const topLeftCornerLevel = topLeftCornerHeaders ? topLeftCornerHeaders.childNodes[i] : null;\n      for (let j = 0, masterNodes = masterLevel.childNodes.length; j < masterNodes; j++) {\n        masterLevel.childNodes[j].removeAttribute('colspan');\n        removeClass(masterLevel.childNodes[j], 'hiddenHeader');\n        if (topLevel && topLevel.childNodes[j]) {\n          topLevel.childNodes[j].removeAttribute('colspan');\n          removeClass(topLevel.childNodes[j], 'hiddenHeader');\n        }\n        if (topLeftCornerHeaders && topLeftCornerLevel && topLeftCornerLevel.childNodes[j]) {\n          topLeftCornerLevel.childNodes[j].removeAttribute('colspan');\n          removeClass(topLeftCornerLevel.childNodes[j], 'hiddenHeader');\n        }\n      }\n    }\n  }\n\n  /**\n   * Generates the appropriate header renderer for a header row.\n   *\n   * @private\n   * @param {number} headerLevel The index of header level counting from the top (positive\n   *                             values counting from 0 to N).\n   * @returns {Function}\n   * @fires Hooks#afterGetColHeader\n   */\n  headerRendererFactory(headerLevel) {\n    var _this2 = this;\n    const fixedColumnsStart = this.hot.view._wt.getSetting('fixedColumnsStart');\n    return (renderedColumnIndex, TH) => {\n      var _classPrivateFieldGet2;\n      const {\n        columnIndexMapper,\n        view\n      } = this.hot;\n      let visualColumnIndex = columnIndexMapper.getVisualFromRenderableIndex(renderedColumnIndex);\n      if (visualColumnIndex === null) {\n        visualColumnIndex = renderedColumnIndex;\n      }\n      TH.removeAttribute('colspan');\n      removeClass(TH, 'hiddenHeader');\n      const {\n        colspan,\n        isHidden,\n        isPlaceholder,\n        headerClassNames\n      } = (_classPrivateFieldGet2 = _classPrivateFieldGet(_stateManager, this).getHeaderSettings(headerLevel, visualColumnIndex)) !== null && _classPrivateFieldGet2 !== void 0 ? _classPrivateFieldGet2 : {\n        label: ''\n      };\n      if (isPlaceholder || isHidden) {\n        addClass(TH, 'hiddenHeader');\n      } else if (colspan > 1) {\n        var _wtOverlays$topInline, _wtOverlays$inlineSta;\n        const {\n          wtOverlays\n        } = view._wt;\n        const isTopInlineStartOverlay = (_wtOverlays$topInline = wtOverlays.topInlineStartCornerOverlay) === null || _wtOverlays$topInline === void 0 ? void 0 : _wtOverlays$topInline.clone.wtTable.THEAD.contains(TH);\n        const isInlineStartOverlay = (_wtOverlays$inlineSta = wtOverlays.inlineStartOverlay) === null || _wtOverlays$inlineSta === void 0 ? void 0 : _wtOverlays$inlineSta.clone.wtTable.THEAD.contains(TH);\n\n        // Check if there is a fixed column enabled, if so then reduce colspan to fixed column width.\n        const correctedColspan = isTopInlineStartOverlay || isInlineStartOverlay ? Math.min(colspan, fixedColumnsStart - renderedColumnIndex) : colspan;\n        if (correctedColspan > 1) {\n          TH.setAttribute('colspan', correctedColspan);\n        }\n      }\n      this.hot.view.appendColHeader(visualColumnIndex, TH, function () {\n        return _this2.getColumnHeaderValue(...arguments);\n      }, headerLevel);\n\n      // Replace the higher-order `headerClassName`s with the one provided in the plugin config, if it was provided.\n      if (!isPlaceholder && !isHidden) {\n        const innerHeaderDiv = TH.querySelector('div.relative');\n        if (innerHeaderDiv && headerClassNames && headerClassNames.length > 0) {\n          removeClass(innerHeaderDiv, this.hot.getColumnMeta(visualColumnIndex).headerClassName);\n          addClass(innerHeaderDiv, headerClassNames);\n        }\n      }\n    };\n  }\n\n  /**\n   * Returns the column header value for specified column and header level index.\n   *\n   * @private\n   * @param {number} visualColumnIndex Visual column index.\n   * @param {number} headerLevel The index of header level. The header level accepts positive (0 to N)\n   *                             and negative (-1 to -N) values. For positive values, 0 points to the\n   *                             top most header, and for negative direction, -1 points to the most bottom\n   *                             header (the header closest to the cells).\n   * @returns {string} Returns the column header value to update.\n   */\n  getColumnHeaderValue(visualColumnIndex, headerLevel) {\n    var _classPrivateFieldGet3;\n    const {\n      isHidden,\n      isPlaceholder\n    } = (_classPrivateFieldGet3 = _classPrivateFieldGet(_stateManager, this).getHeaderSettings(headerLevel, visualColumnIndex)) !== null && _classPrivateFieldGet3 !== void 0 ? _classPrivateFieldGet3 : {};\n    if (isPlaceholder || isHidden) {\n      return '';\n    }\n    return this.hot.getColHeader(visualColumnIndex, headerLevel);\n  }\n  /**\n   * Destroys the plugin instance.\n   */\n  destroy() {\n    _classPrivateFieldSet(_stateManager, this, null);\n    if (_classPrivateFieldGet(_hidingIndexMapObserver, this) !== null) {\n      _classPrivateFieldGet(_hidingIndexMapObserver, this).unsubscribe();\n      _classPrivateFieldSet(_hidingIndexMapObserver, this, null);\n    }\n    super.destroy();\n  }\n\n  /**\n   * Gets the tree data that belongs to the column headers pointed by the passed coordinates.\n   *\n   * @private\n   * @param {CellCoords} coords The CellCoords instance.\n   * @returns {object|undefined}\n   */\n  _getHeaderTreeNodeDataByCoords(coords) {\n    if (coords.row >= 0 || coords.col < 0) {\n      return;\n    }\n    return _classPrivateFieldGet(_stateManager, this).getHeaderTreeNodeData(coords.row, coords.col);\n  }\n}\nfunction _updateFocusHighlightPosition() {\n  var _this$hot;\n  const selection = (_this$hot = this.hot) === null || _this$hot === void 0 ? void 0 : _this$hot.getSelectedRangeLast();\n  if (!selection) {\n    return;\n  }\n  const {\n    highlight\n  } = selection;\n  const isNestedHeadersRange = highlight.isHeader() && highlight.col >= 0;\n  if (isNestedHeadersRange) {\n    const columnIndex = _classPrivateFieldGet(_stateManager, this).findLeftMostColumnIndex(highlight.row, highlight.col);\n    const focusHighlight = this.hot.selection.highlight.getFocus();\n\n    // Correct the highlight/focus selection to highlight the correct TH element\n    focusHighlight.visualCellRange.highlight.col = columnIndex;\n    focusHighlight.visualCellRange.from.col = columnIndex;\n    focusHighlight.visualCellRange.to.col = columnIndex;\n    focusHighlight.commit();\n  }\n}\n/**\n * Allows to control to which column index the viewport will be scrolled. To ensure that the viewport\n * is scrolled to the correct column for the nested header the most left and the most right visual column\n * indexes are used.\n *\n * @param {number} visualColumn A visual column index to which the viewport will be scrolled.\n * @returns {number}\n */\nfunction _onBeforeViewportScrollHorizontally(visualColumn) {\n  const selection = this.hot.getSelectedRangeLast();\n  if (!selection) {\n    return visualColumn;\n  }\n  const {\n    highlight\n  } = selection;\n  const isNestedHeadersRange = highlight.isHeader() && highlight.col >= 0;\n  if (!isNestedHeadersRange) {\n    return visualColumn;\n  }\n  const firstColumn = this.hot.view.getFirstFullyVisibleColumn();\n  const lastColumn = this.hot.view.getLastFullyVisibleColumn();\n  const mostLeftColumnIndex = _classPrivateFieldGet(_stateManager, this).findLeftMostColumnIndex(highlight.row, highlight.col);\n  const mostRightColumnIndex = _classPrivateFieldGet(_stateManager, this).findRightMostColumnIndex(highlight.row, highlight.col);\n\n  // do not scroll the viewport when the header is wider than the viewport\n  if (mostLeftColumnIndex < firstColumn && mostRightColumnIndex > lastColumn) {\n    return visualColumn;\n  }\n  return mostLeftColumnIndex < firstColumn ? mostLeftColumnIndex : mostRightColumnIndex;\n}\n/**\n * Allows to control which header DOM element will be used to highlight.\n *\n * @param {number} visualColumn A visual column index of the highlighted row header.\n * @param {number} headerLevel A row header level that is currently highlighted.\n * @param {object} highlightMeta An object with meta data that describes the highlight state.\n * @returns {number}\n */\nfunction _onBeforeHighlightingColumnHeader(visualColumn, headerLevel, highlightMeta) {\n  const headerNodeData = _classPrivateFieldGet(_stateManager, this).getHeaderTreeNodeData(headerLevel, visualColumn);\n  if (!headerNodeData) {\n    return visualColumn;\n  }\n  const {\n    columnCursor,\n    selectionType,\n    selectionWidth\n  } = highlightMeta;\n  const {\n    isRoot,\n    colspan\n  } = _classPrivateFieldGet(_stateManager, this).getHeaderSettings(headerLevel, visualColumn);\n  if (selectionType === HEADER_TYPE) {\n    if (!isRoot) {\n      return headerNodeData.columnIndex;\n    }\n  } else if (selectionType === ACTIVE_HEADER_TYPE) {\n    if (colspan > selectionWidth - columnCursor || !isRoot) {\n      // Prevents adding any CSS class names to the TH element\n      return null;\n    }\n  }\n  return visualColumn;\n}\n/**\n * Listens the `beforeCopy` hook that allows processing the copied column headers so that the\n * merged column headers do not propagate the value for each column but only once at the beginning\n * of the column.\n *\n * @private\n * @param {Array[]} data An array of arrays which contains data to copied.\n * @param {object[]} copyableRanges An array of objects with ranges of the visual indexes (`startRow`, `startCol`, `endRow`, `endCol`)\n *                                  which will copied.\n * @param {{ columnHeadersCount: number }} copiedHeadersCount An object with keys that holds information with\n *                                                            the number of copied headers.\n */\nfunction _onBeforeCopy(data, copyableRanges, _ref2) {\n  let {\n    columnHeadersCount\n  } = _ref2;\n  if (columnHeadersCount === 0) {\n    return;\n  }\n  for (let rangeIndex = 0; rangeIndex < copyableRanges.length; rangeIndex++) {\n    const {\n      startRow,\n      startCol,\n      endRow,\n      endCol\n    } = copyableRanges[rangeIndex];\n    const rowsCount = endRow - startRow + 1;\n    const columnsCount = startCol - endCol + 1;\n\n    // do not process dataset ranges and column headers where only one column is copied\n    if (startRow >= 0 || columnsCount === 1) {\n      break;\n    }\n    for (let column = startCol; column <= endCol; column++) {\n      for (let row = startRow; row <= endRow; row++) {\n        var _classPrivateFieldGet4;\n        const zeroBasedColumnHeaderLevel = rowsCount + row;\n        const zeroBasedColumnIndex = column - startCol;\n        if (zeroBasedColumnIndex === 0) {\n          continue; // eslint-disable-line no-continue\n        }\n        const isRoot = (_classPrivateFieldGet4 = _classPrivateFieldGet(_stateManager, this).getHeaderTreeNodeData(row, column)) === null || _classPrivateFieldGet4 === void 0 ? void 0 : _classPrivateFieldGet4.isRoot;\n        if (isRoot === false) {\n          data[zeroBasedColumnHeaderLevel][zeroBasedColumnIndex] = '';\n        }\n      }\n    }\n  }\n}\n/**\n * Allows blocking the column selection that is controlled by the core Selection module.\n *\n * @param {MouseEvent} event Mouse event.\n * @param {CellCoords} coords Cell coords object containing the visual coordinates of the clicked cell.\n * @param {CellCoords} TD The table cell or header element.\n * @param {object} controller An object with properties `row`, `column` and `cell`. Each property contains\n *                            a boolean value that allows or disallows changing the selection for that particular area.\n */\nfunction _onBeforeOnCellMouseDown(event, coords, TD, controller) {\n  const headerNodeData = this._getHeaderTreeNodeDataByCoords(coords);\n  if (headerNodeData) {\n    // Block the Selection module in controlling how the columns are selected. Pass the\n    // responsibility of the column selection to this plugin (see \"onAfterOnCellMouseDown\" hook).\n    controller.column = true;\n  }\n}\n/**\n * Allows to control how the column selection based on the coordinates and the nested headers is made.\n *\n * @param {MouseEvent} event Mouse event.\n * @param {CellCoords} coords Cell coords object containing the visual coordinates of the clicked cell.\n */\nfunction _onAfterOnCellMouseDown(event, coords) {\n  const headerNodeData = this._getHeaderTreeNodeDataByCoords(coords);\n  if (!headerNodeData) {\n    return;\n  }\n  _classPrivateFieldSet(_focusInitialCoords, this, coords.clone());\n  _classPrivateFieldSet(_isColumnsSelectionInProgress, this, true);\n  const {\n    selection\n  } = this.hot;\n  const currentSelection = selection.isSelected() ? selection.getSelectedRange().current() : null;\n  const columnsToSelect = [];\n  const {\n    columnIndex,\n    origColspan\n  } = headerNodeData;\n\n  // The Selection module doesn't allow it to extend its behavior easily. That's why here we need\n  // to re-implement the \"click\" and \"shift\" behavior. As a workaround, the logic for the nested\n  // headers must implement a similar logic as in the original Selection handler\n  // (see src/selection/mouseEventHandler.js).\n  const allowRightClickSelection = !selection.inInSelection(coords);\n  if (event.shiftKey && currentSelection) {\n    if (coords.col < currentSelection.from.col) {\n      columnsToSelect.push(currentSelection.getTopEndCorner().col, columnIndex, coords.row);\n    } else if (coords.col > currentSelection.from.col) {\n      columnsToSelect.push(currentSelection.getTopStartCorner().col, columnIndex + origColspan - 1, coords.row);\n    } else {\n      columnsToSelect.push(columnIndex, columnIndex + origColspan - 1, coords.row);\n    }\n  } else if (isLeftClick(event) || isRightClick(event) && allowRightClickSelection || isTouchEvent(event)) {\n    columnsToSelect.push(columnIndex, columnIndex + origColspan - 1, coords.row);\n  }\n\n  // The plugin takes control of how the columns are selected.\n  selection.selectColumns(...columnsToSelect);\n}\n/**\n * Makes the header-selection properly select the nested headers.\n *\n * @param {MouseEvent} event Mouse event.\n * @param {CellCoords} coords Cell coords object containing the visual coordinates of the clicked cell.\n * @param {HTMLElement} TD The cell element.\n * @param {object} controller An object with properties `row`, `column` and `cell`. Each property contains\n *                            a boolean value that allows or disallows changing the selection for that particular area.\n */\nfunction _onBeforeOnCellMouseOver(event, coords, TD, controller) {\n  if (!this.hot.view.isMouseDown()) {\n    return;\n  }\n  const headerNodeData = this._getHeaderTreeNodeDataByCoords(coords);\n  if (!headerNodeData) {\n    return;\n  }\n  const {\n    columnIndex,\n    origColspan\n  } = headerNodeData;\n  const selectedRange = this.hot.getSelectedRangeLast();\n  const topStartCoords = selectedRange.getTopStartCorner();\n  const bottomEndCoords = selectedRange.getBottomEndCorner();\n  const {\n    from\n  } = selectedRange;\n\n  // Block the Selection module in controlling how the columns and cells are selected.\n  // From now on, the plugin is responsible for the selection.\n  controller.column = true;\n  controller.cell = true;\n  const columnsToSelect = [];\n  const headerLevel = clamp(coords.row, -Infinity, -1);\n  if (coords.col < from.col) {\n    columnsToSelect.push(bottomEndCoords.col, columnIndex, headerLevel);\n  } else if (coords.col > from.col) {\n    columnsToSelect.push(topStartCoords.col, columnIndex + origColspan - 1, headerLevel);\n  } else {\n    columnsToSelect.push(columnIndex, columnIndex + origColspan - 1, headerLevel);\n  }\n  this.hot.selection.selectColumns(...columnsToSelect);\n}\n/**\n * Switches internal flag about selection progress to `false`.\n */\nfunction _onBeforeOnCellMouseUp() {\n  _classPrivateFieldSet(_isColumnsSelectionInProgress, this, false);\n}\n/**\n * The hook checks and ensures that the focus position that depends on the selected columns\n * range is always positioned within the range.\n */\nfunction _onBeforeSelectionHighlightSet() {\n  const {\n    navigableHeaders\n  } = this.hot.getSettings();\n  if (!this.hot.view.isMouseDown() || !_classPrivateFieldGet(_isColumnsSelectionInProgress, this) || !navigableHeaders) {\n    return;\n  }\n  const selectedRange = this.hot.getSelectedRangeLast();\n  const columnStart = selectedRange.getTopStartCorner().col;\n  const columnEnd = selectedRange.getBottomEndCorner().col;\n  const {\n    columnIndex,\n    origColspan\n  } = _classPrivateFieldGet(_stateManager, this).getHeaderTreeNodeData(_classPrivateFieldGet(_focusInitialCoords, this).row, _classPrivateFieldGet(_focusInitialCoords, this).col);\n  selectedRange.setHighlight(_classPrivateFieldGet(_focusInitialCoords, this));\n  if (origColspan > selectedRange.getWidth() || columnIndex < columnStart || columnIndex + origColspan - 1 > columnEnd) {\n    const headerLevel = _classPrivateFieldGet(_stateManager, this).findTopMostEntireHeaderLevel(clamp(columnStart, columnIndex, columnIndex + origColspan - 1), clamp(columnEnd, columnIndex, columnIndex + origColspan - 1));\n    selectedRange.highlight.row = headerLevel;\n    selectedRange.highlight.col = selectedRange.from.col;\n  }\n}\n/**\n * `modifyTransformStart` hook is called every time the keyboard navigation is used.\n *\n * @param {object} delta The transformation delta.\n */\nfunction _onModifyTransformStart(delta) {\n  const {\n    highlight\n  } = this.hot.getSelectedRangeLast();\n  const nextCoords = this.hot._createCellCoords(highlight.row + delta.row, highlight.col + delta.col);\n  const isNestedHeadersRange = nextCoords.isHeader() && nextCoords.col >= 0;\n  if (!isNestedHeadersRange) {\n    return;\n  }\n  const visualColumnIndexStart = _classPrivateFieldGet(_stateManager, this).findLeftMostColumnIndex(nextCoords.row, nextCoords.col);\n  const visualColumnIndexEnd = _classPrivateFieldGet(_stateManager, this).findRightMostColumnIndex(nextCoords.row, nextCoords.col);\n  if (delta.col < 0) {\n    const nextColumn = highlight.col >= visualColumnIndexStart && highlight.col <= visualColumnIndexEnd ? visualColumnIndexStart - 1 : visualColumnIndexEnd;\n    const notHiddenColumnIndex = this.hot.columnIndexMapper.getNearestNotHiddenIndex(nextColumn, -1);\n    if (notHiddenColumnIndex === null) {\n      // There are no visible columns anymore, so move the selection out of the table edge. This will\n      // be processed by the selection Transformer class as a move selection to the previous row (if autoWrapRow is enabled).\n      delta.col = -this.hot.view.countRenderableColumnsInRange(0, highlight.col);\n    } else {\n      delta.col = -Math.max(this.hot.view.countRenderableColumnsInRange(notHiddenColumnIndex, highlight.col) - 1, 1);\n    }\n  } else if (delta.col > 0) {\n    const nextColumn = highlight.col >= visualColumnIndexStart && highlight.col <= visualColumnIndexEnd ? visualColumnIndexEnd + 1 : visualColumnIndexStart;\n    const notHiddenColumnIndex = this.hot.columnIndexMapper.getNearestNotHiddenIndex(nextColumn, 1);\n    if (notHiddenColumnIndex === null) {\n      // There are no visible columns anymore, so move the selection out of the table edge. This will\n      // be processed by the selection Transformer class as a move selection to the next row (if autoWrapRow is enabled).\n      delta.col = this.hot.view.countRenderableColumnsInRange(highlight.col, this.hot.countCols());\n    } else {\n      delta.col = Math.max(this.hot.view.countRenderableColumnsInRange(highlight.col, notHiddenColumnIndex) - 1, 1);\n    }\n  }\n}\n/**\n * The hook observes the column selection from the Selection API and modifies the column range to\n * ensure that the whole nested column will be covered.\n *\n * @param {CellCoords} from The coords object where the selection starts.\n * @param {CellCoords} to The coords object where the selection ends.\n */\nfunction _onBeforeSelectColumns(from, to) {\n  const headerLevel = from.row;\n  const startNodeData = this._getHeaderTreeNodeDataByCoords({\n    row: headerLevel,\n    col: from.col\n  });\n  const endNodeData = this._getHeaderTreeNodeDataByCoords({\n    row: headerLevel,\n    col: to.col\n  });\n  if (to.col < from.col) {\n    // Column selection from right to left\n    if (startNodeData) {\n      from.col = startNodeData.columnIndex + startNodeData.origColspan - 1;\n    }\n    if (endNodeData) {\n      to.col = endNodeData.columnIndex;\n    }\n  } else if (to.col >= from.col) {\n    // Column selection from left to right or a single column selection\n    if (startNodeData) {\n      from.col = startNodeData.columnIndex;\n    }\n    if (endNodeData) {\n      to.col = endNodeData.columnIndex + endNodeData.origColspan - 1;\n    }\n  }\n}\n/**\n * `afterGetColumnHeader` hook callback - prepares the header structure.\n *\n * @param {Array} renderersArray Array of renderers.\n */\nfunction _onAfterGetColumnHeaderRenderers(renderersArray) {\n  renderersArray.length = 0;\n  for (let headerLayer = 0; headerLayer < _classPrivateFieldGet(_stateManager, this).getLayersCount(); headerLayer++) {\n    renderersArray.push(this.headerRendererFactory(headerLayer));\n  }\n}\n/**\n * Make the renderer render the first nested column in its entirety.\n *\n * @param {object} calc Viewport column calculator.\n */\nfunction _onAfterViewportColumnCalculatorOverride(calc) {\n  const headerLayersCount = _classPrivateFieldGet(_stateManager, this).getLayersCount();\n  let newStartColumn = calc.startColumn;\n  let nonRenderable = !!headerLayersCount;\n  for (let headerLayer = 0; headerLayer < headerLayersCount; headerLayer++) {\n    const startColumn = _classPrivateFieldGet(_stateManager, this).findLeftMostColumnIndex(headerLayer, calc.startColumn);\n    const renderedStartColumn = this.hot.columnIndexMapper.getRenderableFromVisualIndex(startColumn);\n\n    // If any of the headers for that column index is rendered, all of them should be rendered properly, see\n    // comment below.\n    if (startColumn >= 0) {\n      nonRenderable = false;\n    }\n\n    // `renderedStartColumn` can be `null` if the leftmost columns are hidden. In that case -> ignore that header\n    // level, as it should be handled by the \"parent\" header\n    if (isNumeric(renderedStartColumn) && renderedStartColumn < calc.startColumn) {\n      newStartColumn = renderedStartColumn;\n      break;\n    }\n  }\n\n  // If no headers for the provided column index are renderable, start rendering from the beginning of the upmost\n  // header for that position.\n  calc.startColumn = nonRenderable ? _classPrivateFieldGet(_stateManager, this).getHeaderTreeNodeData(0, newStartColumn).columnIndex : newStartColumn;\n}\n/**\n * `modifyColWidth` hook callback - returns width from cache, when is greater than incoming from hook.\n *\n * @param {number} width Width from hook.\n * @param {number} column Visual index of an column.\n * @returns {number}\n */\nfunction _onModifyColWidth(width, column) {\n  const cachedWidth = this.ghostTable.getWidth(column);\n  return width > cachedWidth ? width : cachedWidth;\n}\n/**\n * Listens the `modifyColumnHeaderValue` hook that overwrites the column headers values based on\n * the internal state and settings of the plugin.\n *\n * @param {string} value The column header value.\n * @param {number} visualColumnIndex The visual column index.\n * @param {number} headerLevel The index of header level. The header level accepts positive (0 to N)\n *                             and negative (-1 to -N) values. For positive values, 0 points to the\n *                             top most header, and for negative direction, -1 points to the most bottom\n *                             header (the header closest to the cells).\n * @returns {string} Returns the column header value to update.\n */\nfunction _onModifyColumnHeaderValue(value, visualColumnIndex, headerLevel) {\n  var _classPrivateFieldGet5;\n  const {\n    label\n  } = (_classPrivateFieldGet5 = _classPrivateFieldGet(_stateManager, this).getHeaderTreeNodeData(headerLevel, visualColumnIndex)) !== null && _classPrivateFieldGet5 !== void 0 ? _classPrivateFieldGet5 : {\n    label: ''\n  };\n  return label;\n}\n/**\n * `modifyFocusedElement` hook callback.\n *\n * @param {number} row Row index.\n * @param {number} column Column index.\n * @returns {HTMLTableCellElement} The `TH` element to be focused.\n */\nfunction _onModifyFocusedElement(row, column) {\n  if (row < 0) {\n    return this.hot.getCell(row, _classPrivateFieldGet(_stateManager, this).findLeftMostColumnIndex(row, column), true);\n  }\n}\n/**\n * Updates the plugin state after HoT initialization.\n */\nfunction _onInit() {\n  // @TODO: Workaround for broken plugin initialization abstraction.\n  this.updatePlugin();\n}\n/**\n * Updates the plugin state after new dataset load.\n *\n * @param {Array[]} sourceData Array of arrays or array of objects containing data.\n * @param {boolean} initialLoad Flag that determines whether the data has been loaded\n *                              during the initialization.\n */\nfunction _onAfterLoadData(sourceData, initialLoad) {\n  if (!initialLoad) {\n    this.updatePlugin();\n  }\n}","import \"core-js/modules/es.error.cause.js\";\nimport \"core-js/modules/es.array.push.js\";\nfunction _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == typeof i ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != typeof t || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != typeof i) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\nimport { isUndefined } from \"../../../helpers/mixed.mjs\";\nimport { warn } from \"../../../helpers/console.mjs\";\nimport { toSingleLine } from \"../../../helpers/templateLiteralTag.mjs\";\n/**\n * Helper class for the row-move-related operations.\n *\n * @private\n * @class RowMoveController\n */\nexport default class RowMoveController {\n  constructor(plugin) {\n    /**\n     * Reference to the Nested Rows plugin instance.\n     *\n     * @type {NestedRows}\n     */\n    _defineProperty(this, \"plugin\", void 0);\n    /**\n     * Reference to the Handsontable instance.\n     *\n     * @type {Handsontable.Core}\n     */\n    _defineProperty(this, \"hot\", void 0);\n    /**\n     * Reference to the Data Manager class instance.\n     *\n     * @type {DataManager}\n     */\n    _defineProperty(this, \"dataManager\", void 0);\n    /**\n     * Reference to the Collapsing UI class instance.\n     *\n     * @type {CollapsingUI}\n     */\n    _defineProperty(this, \"collapsingUI\", void 0);\n    this.plugin = plugin;\n    this.hot = plugin.hot;\n    this.dataManager = plugin.dataManager;\n    this.collapsingUI = plugin.collapsingUI;\n  }\n\n  /**\n   * `beforeRowMove` hook callback.\n   *\n   * @param {Array} rows Array of visual row indexes to be moved.\n   * @param {number} finalIndex Visual row index, being a start index for the moved rows. Points to where the elements\n   *   will be placed after the moving action. To check the visualization of the final index, please take a look at\n   *   [documentation](@/guides/rows/row-moving/row-moving.md).\n   * @param {undefined|number} dropIndex Visual row index, being a drop index for the moved rows. Points to where we\n   *   are going to drop the moved elements. To check visualization of drop index please take a look at\n   *   [documentation](@/guides/rows/row-moving/row-moving.md).\n   * @param {boolean} movePossible Indicates if it's possible to move rows to the desired position.\n   * @fires Hooks#afterRowMove\n   * @returns {boolean}\n   */\n  onBeforeRowMove(rows, finalIndex, dropIndex, movePossible) {\n    const improperUsage = this.displayAPICompatibilityWarning({\n      rows,\n      finalIndex,\n      dropIndex,\n      movePossible\n    });\n    if (improperUsage) {\n      return false;\n    }\n    this.movedToCollapsed = false;\n    const dropToLastRow = dropIndex === this.hot.countRows();\n    const physicalDropIndex = dropToLastRow ? this.hot.countSourceRows() : this.dataManager.translateTrimmedRow(dropIndex);\n    let allowMove = true;\n    const physicalStartIndexes = rows.map(rowIndex => {\n      // Don't do the logic for the rest of the rows, as it's bound to fail anyway.\n      if (!allowMove) {\n        return false;\n      }\n      const physicalRowIndex = this.dataManager.translateTrimmedRow(rowIndex);\n      allowMove = this.shouldAllowMoving(physicalRowIndex, physicalDropIndex);\n      return physicalRowIndex;\n    });\n    const willDataChange = physicalStartIndexes.indexOf(physicalDropIndex) === -1;\n    if (!allowMove || !willDataChange) {\n      return false;\n    }\n    const baseParent = this.getBaseParent(physicalStartIndexes);\n    const targetParent = this.getTargetParent(dropToLastRow, physicalDropIndex);\n    const sameParent = baseParent === targetParent;\n    this.movedToCollapsed = this.collapsingUI.areChildrenCollapsed(targetParent);\n\n    // Stash the current state of collapsed rows\n    this.collapsingUI.collapsedRowsStash.stash();\n    this.shiftCollapsibleParentsLocations(physicalStartIndexes, physicalDropIndex, sameParent);\n    this.moveRows(physicalStartIndexes, physicalDropIndex, targetParent);\n    this.dataManager.rewriteCache();\n    this.moveCellsMeta(physicalStartIndexes, physicalDropIndex);\n    this.collapsingUI.collapsedRowsStash.applyStash(false);\n\n    // TODO: Trying to mock real work of the `ManualRowMove` plugin. It was blocked by returning `false` below.\n    this.hot.runHooks('afterRowMove', rows, finalIndex, dropIndex, movePossible, movePossible && this.isRowOrderChanged(rows, finalIndex));\n\n    // Not necessary - added to keep compatibility with other plugins (namely: columnSummary).\n    this.hot.render();\n    this.selectCells(rows, dropIndex);\n    return false;\n  }\n\n  /**\n   * Display a `dragRows`/`moveRows` method compatibility warning if needed.\n   *\n   * @param {object} beforeMoveRowHookArgs A set of arguments from the `beforeMoveRow` hook.\n   * @returns {boolean} `true` if is a result of an improper usage of the moving API.\n   */\n  displayAPICompatibilityWarning(beforeMoveRowHookArgs) {\n    const {\n      rows,\n      finalIndex,\n      dropIndex,\n      movePossible\n    } = beforeMoveRowHookArgs;\n    let shouldTerminate = false;\n    if (isUndefined(dropIndex)) {\n      warn(toSingleLine`Since version 8.0.0 of the Handsontable the 'moveRows' method isn't used for moving rows\\x20\n      when the NestedRows plugin is enabled. Please use the 'dragRows' method instead.`);\n\n      // TODO: Trying to mock real work of the `ManualRowMove` plugin. It was blocked by returning `false` below.\n      this.hot.runHooks('afterRowMove', rows, finalIndex, dropIndex, movePossible, false);\n      shouldTerminate = true;\n    }\n    return shouldTerminate;\n  }\n\n  /**\n   * Check if the moving action should be allowed.\n   *\n   * @param {number} physicalRowIndex Physical start row index.\n   * @param {number} physicalDropIndex Physical drop index.\n   * @returns {boolean} `true` if it should continue with the moving action.\n   */\n  shouldAllowMoving(physicalRowIndex, physicalDropIndex) {\n    /*\n       We can't move rows when any of them is:\n       - a parent\n       - a top-level element\n       - is being moved to the top level\n       - is being moved to the position of any of the moved rows (not changing position)\n    */\n\n    return !(this.dataManager.isParent(physicalRowIndex) || this.dataManager.isRowHighestLevel(physicalRowIndex) || physicalRowIndex === physicalDropIndex || physicalDropIndex === 0);\n  }\n\n  /**\n   * Get the base row parent.\n   *\n   * @param {number} physicalStartIndexes Physical start row index.\n   * @returns {object|null} The base row parent.\n   */\n  getBaseParent(physicalStartIndexes) {\n    return this.dataManager.getRowParent(physicalStartIndexes[0]);\n  }\n\n  /**\n   * Get the target row parent.\n   *\n   * @param {boolean} dropToLastRow `true` if the row is moved to the last row of the table.\n   * @param {number} physicalDropIndex Physical drop row index.\n   * @returns {object|null} The target row parent.\n   */\n  getTargetParent(dropToLastRow, physicalDropIndex) {\n    let targetParent = this.dataManager.getRowParent(dropToLastRow ? physicalDropIndex - 1 : physicalDropIndex);\n\n    // If we try to move an element to the place of a top-level parent, snap the element to the previous top-level\n    // parent's children instead\n    if (targetParent === null || targetParent === undefined) {\n      targetParent = this.dataManager.getRowParent(physicalDropIndex - 1);\n    }\n    return targetParent;\n  }\n\n  /**\n   * Shift the cached collapsible rows position according to the move action.\n   *\n   * @param {number[]} physicalStartIndexes Physical start row indexes.\n   * @param {number} physicalDropIndex Physical drop index.\n   * @param {boolean} sameParent `true` if the row's being moved between siblings of the same parent.\n   */\n  shiftCollapsibleParentsLocations(physicalStartIndexes, physicalDropIndex, sameParent) {\n    if (!sameParent) {\n      if (Math.max(...physicalStartIndexes) <= physicalDropIndex) {\n        this.collapsingUI.collapsedRowsStash.shiftStash(physicalStartIndexes[0], physicalDropIndex, -1 * physicalStartIndexes.length);\n      } else {\n        this.collapsingUI.collapsedRowsStash.shiftStash(physicalDropIndex, physicalStartIndexes[0], physicalStartIndexes.length);\n      }\n    }\n  }\n\n  /**\n   * Move the rows at the provided coordinates.\n   *\n   * @param {number[]} physicalStartIndexes Physical indexes of the rows about to be moved.\n   * @param {number} physicalDropIndex Physical drop index.\n   * @param {object} targetParent Parent of the destination row.\n   */\n  moveRows(physicalStartIndexes, physicalDropIndex, targetParent) {\n    const moveToLastChild = physicalDropIndex === this.dataManager.getRowIndex(targetParent) + this.dataManager.countChildren(targetParent) + 1;\n    this.hot.batchRender(() => {\n      physicalStartIndexes.forEach(physicalStartIndex => {\n        this.dataManager.moveRow(physicalStartIndex, physicalDropIndex, this.movedToCollapsed, moveToLastChild);\n      });\n    });\n  }\n\n  /**\n   * Move the cell meta for multiple rows.\n   *\n   * @param {number[]} baseIndexes Array of indexes for the rows being moved.\n   * @param {number} targetIndex Index of the destination of the move.\n   */\n  moveCellsMeta(baseIndexes, targetIndex) {\n    const rowsOfMeta = [];\n    const movingDown = Math.max(...baseIndexes) < targetIndex;\n    baseIndexes.forEach(baseIndex => {\n      rowsOfMeta.push(this.hot.getCellMetaAtRow(baseIndex));\n    });\n    this.hot.spliceCellsMeta(baseIndexes[0], baseIndexes.length);\n    this.hot.spliceCellsMeta(targetIndex - (movingDown ? rowsOfMeta.length : 0), 0, ...rowsOfMeta);\n  }\n\n  /**\n   * Select cells after the move.\n   *\n   * @param {Array} rows Array of visual row indexes to be moved.\n   * @param {undefined|number} dropIndex Visual row index, being a drop index for the moved rows. Points to where we\n   *   are going to drop the moved elements. To check visualization of drop index please take a look at\n   *   [documentation](@/guides/rows/row-moving/row-moving.md).\n   */\n  selectCells(rows, dropIndex) {\n    const rowsLen = rows.length;\n    let startRow = 0;\n    let endRow = 0;\n    let selection = null;\n    let lastColIndex = null;\n    if (this.movedToCollapsed) {\n      let physicalDropIndex = null;\n      if (rows[rowsLen - 1] < dropIndex) {\n        physicalDropIndex = this.dataManager.translateTrimmedRow(dropIndex - rowsLen);\n      } else {\n        physicalDropIndex = this.dataManager.translateTrimmedRow(dropIndex);\n      }\n      const parentObject = this.dataManager.getRowParent(physicalDropIndex === null ? this.hot.countSourceRows() - 1 : physicalDropIndex - 1);\n      const parentIndex = this.dataManager.getRowIndex(parentObject);\n      startRow = this.dataManager.untranslateTrimmedRow(parentIndex);\n      endRow = startRow;\n    } else if (rows[rowsLen - 1] < dropIndex) {\n      endRow = dropIndex - 1;\n      startRow = endRow - rowsLen + 1;\n    } else {\n      startRow = dropIndex;\n      endRow = startRow + rowsLen - 1;\n    }\n    selection = this.hot.selection;\n    lastColIndex = this.hot.countCols() - 1;\n    selection.setRangeStart(this.hot._createCellCoords(startRow, 0));\n    selection.setRangeEnd(this.hot._createCellCoords(endRow, lastColIndex), true);\n  }\n\n  // TODO: Reimplementation of function which is inside the `ManualRowMove` plugin.\n  /**\n   * Indicates if order of rows was changed.\n   *\n   * @param {Array} movedRows Array of visual row indexes to be moved.\n   * @param {number} finalIndex Visual row index, being a start index for the moved rows. Points to where the elements\n   *   will be placed after the moving action. To check the visualization of the final index, please take a look at\n   *   [documentation](@/guides/rows/row-moving/row-moving.md).\n   * @returns {boolean}\n   */\n  isRowOrderChanged(movedRows, finalIndex) {\n    return movedRows.some((row, nrOfMovedElement) => row - nrOfMovedElement !== finalIndex);\n  }\n}"],"names":[],"sourceRoot":""}