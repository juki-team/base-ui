(self.webpackChunk_juki_team_base_ui=self.webpackChunk_juki_team_base_ui||[]).push([[31080],{"./node_modules/canvas-roundrect-polyfill/roundRect.js":()=>{(()=>{"use strict";function roundRect(x,y,w,h,radii){if(![x,y,w,h].every(input=>Number.isFinite(input)))return;let upperLeft,upperRight,lowerRight,lowerLeft;if(4===(radii=function parseRadiiArgument(value){const type=typeof value;if("undefined"===type||null===value)return[0];if("function"===type)return[NaN];if("object"===type)return"function"==typeof value[Symbol.iterator]?[...value].map(elem=>{const elemType=typeof elem;return"undefined"===elemType||null===elem?0:"function"===elemType?NaN:"object"===elemType?toDOMPointInit(elem):toUnrestrictedNumber(elem)}):[toDOMPointInit(value)];return[toUnrestrictedNumber(value)]}(radii)).length)upperLeft=toCornerPoint(radii[0]),upperRight=toCornerPoint(radii[1]),lowerRight=toCornerPoint(radii[2]),lowerLeft=toCornerPoint(radii[3]);else if(3===radii.length)upperLeft=toCornerPoint(radii[0]),upperRight=toCornerPoint(radii[1]),lowerLeft=toCornerPoint(radii[1]),lowerRight=toCornerPoint(radii[2]);else if(2===radii.length)upperLeft=toCornerPoint(radii[0]),lowerRight=toCornerPoint(radii[0]),upperRight=toCornerPoint(radii[1]),lowerLeft=toCornerPoint(radii[1]);else{if(1!==radii.length)throw new RangeError(`${getErrorMessageHeader(this)} ${radii.length} is not a valid size for radii sequence.`);upperLeft=toCornerPoint(radii[0]),upperRight=toCornerPoint(radii[0]),lowerRight=toCornerPoint(radii[0]),lowerLeft=toCornerPoint(radii[0])}const corners=[upperLeft,upperRight,lowerRight,lowerLeft],negativeCorner=corners.find(({x,y})=>x<0||y<0);negativeCorner?.x<0&&negativeCorner.x;if(!corners.some(({x,y})=>!Number.isFinite(x)||!Number.isFinite(y))){if(negativeCorner)throw new RangeError(`${getErrorMessageHeader(this)} Radius value ${negativeCorner} is negative.`);!function fixOverlappingCorners(corners){const[upperLeft,upperRight,lowerRight,lowerLeft]=corners,factors=[Math.abs(w)/(upperLeft.x+upperRight.x),Math.abs(h)/(upperRight.y+lowerRight.y),Math.abs(w)/(lowerRight.x+lowerLeft.x),Math.abs(h)/(upperLeft.y+lowerLeft.y)],minFactor=Math.min(...factors);if(minFactor<=1)for(const radii of corners)radii.x*=minFactor,radii.y*=minFactor}(corners),w<0&&h<0?(this.moveTo(x-upperLeft.x,y),this.ellipse(x+w+upperRight.x,y-upperRight.y,upperRight.x,upperRight.y,0,1.5*-Math.PI,-Math.PI),this.ellipse(x+w+lowerRight.x,y+h+lowerRight.y,lowerRight.x,lowerRight.y,0,-Math.PI,-Math.PI/2),this.ellipse(x-lowerLeft.x,y+h+lowerLeft.y,lowerLeft.x,lowerLeft.y,0,-Math.PI/2,0),this.ellipse(x-upperLeft.x,y-upperLeft.y,upperLeft.x,upperLeft.y,0,0,-Math.PI/2)):w<0?(this.moveTo(x-upperLeft.x,y),this.ellipse(x+w+upperRight.x,y+upperRight.y,upperRight.x,upperRight.y,0,-Math.PI/2,-Math.PI,1),this.ellipse(x+w+lowerRight.x,y+h-lowerRight.y,lowerRight.x,lowerRight.y,0,-Math.PI,1.5*-Math.PI,1),this.ellipse(x-lowerLeft.x,y+h-lowerLeft.y,lowerLeft.x,lowerLeft.y,0,Math.PI/2,0,1),this.ellipse(x-upperLeft.x,y+upperLeft.y,upperLeft.x,upperLeft.y,0,0,-Math.PI/2,1)):h<0?(this.moveTo(x+upperLeft.x,y),this.ellipse(x+w-upperRight.x,y-upperRight.y,upperRight.x,upperRight.y,0,Math.PI/2,0,1),this.ellipse(x+w-lowerRight.x,y+h+lowerRight.y,lowerRight.x,lowerRight.y,0,0,-Math.PI/2,1),this.ellipse(x+lowerLeft.x,y+h+lowerLeft.y,lowerLeft.x,lowerLeft.y,0,-Math.PI/2,-Math.PI,1),this.ellipse(x+upperLeft.x,y-upperLeft.y,upperLeft.x,upperLeft.y,0,-Math.PI,1.5*-Math.PI,1)):(this.moveTo(x+upperLeft.x,y),this.ellipse(x+w-upperRight.x,y+upperRight.y,upperRight.x,upperRight.y,0,-Math.PI/2,0),this.ellipse(x+w-lowerRight.x,y+h-lowerRight.y,lowerRight.x,lowerRight.y,0,0,Math.PI/2),this.ellipse(x+lowerLeft.x,y+h-lowerLeft.y,lowerLeft.x,lowerLeft.y,0,Math.PI/2,Math.PI),this.ellipse(x+upperLeft.x,y+upperLeft.y,upperLeft.x,upperLeft.y,0,Math.PI,1.5*Math.PI)),this.closePath(),this.moveTo(x,y)}function toDOMPointInit(value){const{x,y,z,w}=value;return{x,y,z,w}}function toUnrestrictedNumber(value){return+value}function toCornerPoint(value){const asNumber=toUnrestrictedNumber(value);return Number.isFinite(asNumber)?{x:asNumber,y:asNumber}:Object(value)===value?{x:toUnrestrictedNumber(value.x??0),y:toUnrestrictedNumber(value.y??0)}:{x:NaN,y:NaN}}}function getErrorMessageHeader(instance){return`Failed to execute 'roundRect' on '${function getConstructorName(instance){return Object(instance)===instance&&instance instanceof Path2D?"Path2D":instance instanceof globalThis?.CanvasRenderingContext2D?"CanvasRenderingContext2D":instance instanceof globalThis?.OffscreenCanvasRenderingContext2D?"OffscreenCanvasRenderingContext2D":instance?.constructor.name||instance}(instance)}':`}Path2D.prototype.roundRect??=roundRect,globalThis.CanvasRenderingContext2D&&(globalThis.CanvasRenderingContext2D.prototype.roundRect??=roundRect),globalThis.OffscreenCanvasRenderingContext2D&&(globalThis.OffscreenCanvasRenderingContext2D.prototype.roundRect??=roundRect)})()}}]);